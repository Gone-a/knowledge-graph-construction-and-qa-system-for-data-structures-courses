[
  {
    "sentence": "叶子节点没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入和删除操作效率较低，",
    "head": "插入",
    "tail": "删除",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "若它的右子树不空，则右子树上",
    "head": "右子树",
    "tail": "右子树",
    "head_offset": "3",
    "tail_offset": "10"
  },
  {
    "sentence": "树中没有子节点的节点即叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "4",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树每个节点最多有两个子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树中没有子节点的节点即叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "4",
    "tail_offset": "11"
  },
  {
    "sentence": "线性表是n个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点的核心特征是没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树中没有子节点的节点即叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "4",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树每个节点最多有两个子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数组是相同类型数据元素的有序集合",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数组是相同类型数据元素的有序集合",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树中没有子节点的节点就是叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "4",
    "tail_offset": "12"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是相同类型数据元素的有序集合",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中没有子节点的节点就是叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "4",
    "tail_offset": "12"
  },
  {
    "sentence": "树中没有前驱节点的节点即为根节点",
    "head": "前驱节点",
    "tail": "根节点",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数组是存储相同类型数据的有序集合",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "线性表数据元素一对一相邻且有顺序",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "数组是存储相同类型数据的有序集合",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数组是存储相同类型数据的有序集合",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数组是相同类型数据元素的有序集合",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是相同类型数据元素的有序集合",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树中没有子节点的节点就是叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "4",
    "tail_offset": "12"
  },
  {
    "sentence": "树中没有子节点的节点就是叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "4",
    "tail_offset": "12"
  },
  {
    "sentence": "树中没有子节点的节点就是叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "4",
    "tail_offset": "12"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数组是相同类型数据元素的有序集合",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "回路是图中一条起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "叶子节点是树中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "单链表通过节点指针依次相连存储数据",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "若任意节点的右子树不空，则右子树上",
    "head": "右子树",
    "tail": "右子树",
    "head_offset": "6",
    "tail_offset": "13"
  },
  {
    "sentence": "选择基准元素分治排序使数组快速有序",
    "head": "排序",
    "tail": "数组",
    "head_offset": "8",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是一棵树中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性表是n个数据元素构成的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "叶子节点是一棵树中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是一棵树中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是一棵树中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是一棵树中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "交换排序通过比较交换元素位置实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树的节点包含数据且有指向子节点的链接",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数组是存储相同数据类型元素的有序集合",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "叶子节点是数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的一种算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中数据元素及指向子树的分支构成节点",
    "head": "数据元素",
    "tail": "子树",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "数组是存储相同数据类型元素的有序集合",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是零个或多个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "叶子节点是数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "选择基准分区递归排序以达快速有序效果",
    "head": "递归",
    "tail": "排序",
    "head_offset": "6",
    "tail_offset": "8"
  },
  {
    "sentence": "树结构中没有子节点的节点就是叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "6",
    "tail_offset": "14"
  },
  {
    "sentence": "线性表是零个或多个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性表是零个或多个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "线性表是零个或多个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表通过链表存储顶点及邻接顶点信息",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "线性表是数据元素按顺序排列的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中数据元素及指向子树的分支构成节点",
    "head": "数据元素",
    "tail": "子树",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点包含数据且有指向子节点的链接",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的一种算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性表是零个或多个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的高效算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是存储相同数据类型元素的有序集合",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是具有相同数据类型元素的有序集合",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是具有相同数据类型元素的有序集合",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树中数据元素及指向子树的分支构成节点",
    "head": "数据元素",
    "tail": "子树",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "回路是从一点出发又回到该点的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "叶子节点是数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "线性表是数据元素一对一排列的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "叶子节点是数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的一种算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点是数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "叶子节点是数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的高效算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是具有相同数据类型元素的有序集合",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树的子树有左右之分，次序不能颠倒",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "数组是具有相同数据类型元素的有序集合",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的一种算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是利用堆结构特性进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "根节点是树形结构起始点无父节点有子节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树是一种分层数据结构包含根节点和子节点",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "12",
    "tail_offset": "16"
  },
  {
    "sentence": "线性结构数据元素间存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "图中任意两点都存在路径相连的图是连通图",
    "head": "路径",
    "tail": "连通图",
    "head_offset": "9",
    "tail_offset": "16"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "堆排序利用堆结构特性对数据进行排序操作",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "比较排序通过元素间比较确定最终排序顺序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "连通图是任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树是一种分层数据结构包含根节点及子节点",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "12",
    "tail_offset": "16"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据逻辑结构指数据元素间抽象的逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "交换排序通过比较交换元素位置来实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "交换排序通过比较交换元素位置来完成排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "根节点是树结构起始点无父节点有子节点等",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据逻辑结构是数据元素间逻辑关系的整体",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "根节点是树结构起始点，无父节点有子节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "非线性结构中数据元素之间存在多对多关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "叶子节点是指在树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树是一种分层数据结构包含根节点及子节点",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "12",
    "tail_offset": "16"
  },
  {
    "sentence": "邻接表以链表形式存储图中顶点及邻接关系",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "在树结构中通过特定路径查找特定节点元素",
    "head": "路径",
    "tail": "查找",
    "head_offset": "9",
    "tail_offset": "11"
  },
  {
    "sentence": "图中任意两点都存在路径相连的图是连通图",
    "head": "路径",
    "tail": "连通图",
    "head_offset": "9",
    "tail_offset": "16"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "队列特点是先进先出，元素按顺序入队出队",
    "head": "队列",
    "tail": "入队",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "链表是通过指针将节点连接起来的数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "叶子节点是指在树结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据逻辑结构是数据元素间逻辑关系的整体",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "通过分治策略将数组分成两部分并递归排序",
    "head": "数组",
    "tail": "递归",
    "head_offset": "7",
    "tail_offset": "15"
  },
  {
    "sentence": "选择基准分两部分递归排序以实现快速排序",
    "head": "递归",
    "tail": "排序",
    "head_offset": "8",
    "tail_offset": "10"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "交换排序通过比较交换元素位置来实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "数据逻辑结构是数据元素间逻辑关系的整体",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数据逻辑结构是数据元素间逻辑关系的整体",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表节点有前驱和后继指针可双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "交换排序通过比较交换元素位置来实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "连通图是图中任意两点都存在路径相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "图中任意两点都存在路径相连的图是连通图",
    "head": "路径",
    "tail": "连通图",
    "head_offset": "9",
    "tail_offset": "16"
  },
  {
    "sentence": "队列特点是先进先出，元素按顺序入队出队",
    "head": "队列",
    "tail": "入队",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "连通图是图中任意两点都存在路径相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性结构中数据元素存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "队列特点是先进先出，元素按顺序入队出队",
    "head": "队列",
    "tail": "入队",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树是一种分层数据结构包含根节点和子节点",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "12",
    "tail_offset": "16"
  },
  {
    "sentence": "数据逻辑结构是数据元素间逻辑关系的整体",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "连通图是任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "非线性结构中数据元素之间的关系不呈线性",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "选择基准值分治将数组分成两部分递归排序",
    "head": "数组",
    "tail": "递归",
    "head_offset": "8",
    "tail_offset": "15"
  },
  {
    "sentence": "队列特点是先进先出，元素按顺序入队出队",
    "head": "队列",
    "tail": "入队",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "交换排序通过比较交换元素位置来实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "数据逻辑结构是数据元素间逻辑关系的整体",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "非线性结构中数据元素之间的关系不呈线性",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "叶子节点是指在树状结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "回路是图中从某顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的一种排序算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "在树结构中，没有子节点的节点即为叶子节点",
    "head": "子节点",
    "tail": "叶子节点",
    "head_offset": "8",
    "tail_offset": "16"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互到达",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "回路是图中从一顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据逻辑结构核心概念是数据元素间逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "满二叉树是每一层节点数都达到最大的二叉树",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "在有序数组中通过不断折半查找目标值的方法",
    "head": "数组",
    "tail": "查找",
    "head_offset": "3",
    "tail_offset": "12"
  },
  {
    "sentence": "回路是在电路中电流能够循环流动的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "双向链表是节点含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "双向链表是节点含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互连通",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "循环链表是尾节点指针指向头节点的链表结构",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "回路是图中从某顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回路是从某节点出发又回到该节点的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据逻辑结构核心概念是数据元素间逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "数组是相同类型数据的有序集合通过下标访问",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互连通",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性表是数据元素按线性关系排列的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "根节点是树结构中位于顶端没有父节点的节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "线性结构数据元素之间存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "数据逻辑结构核心概念是数据元素间逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是指在树状结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "交换排序是通过元素交换位置实现排序的方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的一种排序算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性数据结构有根节点及子树关系",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "12",
    "tail_offset": "16"
  },
  {
    "sentence": "满二叉树是每一层节点数都达到最大的二叉树",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "回路是图中从某顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互到达",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接矩阵用二维数组表示图中顶点间邻接关系",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是数据元素一对一线性关系的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的高效排序算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "在有序数组中通过不断折半比较查找目标元素",
    "head": "数组",
    "tail": "查找",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "交换排序通过比较与交换元素位置来实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "双向链表是节点含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "堆排序是利用堆这种数据结构进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "双向链表是节点含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "图的顶点是图结构中用于表示数据元素的节点",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互连通",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的节点有一个或多个子节点且有唯一根节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互到达",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "叶子节点的核心特征是在树结构中没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "满二叉树是每一层节点数都达到最大的二叉树",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "选择基准值将数组分两部分，递归排序子数组",
    "head": "数组",
    "tail": "递归",
    "head_offset": "6",
    "tail_offset": "13"
  },
  {
    "sentence": "树是一种非线性数据结构有根节点和子树关系",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "12",
    "tail_offset": "16"
  },
  {
    "sentence": "回路是图中从某顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互到达",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "图的顶点是图结构中代表数据元素的基本单元",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是数据结构中没有子节点的末端节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "双向链表是节点含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "堆排序利用堆结构，将数据排序且具有高效性",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "双向链表是节点含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "交换排序通过比较与交换元素位置来实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回路是能沿一定路径回到起点的闭合线路结构",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆排序是利用堆这种数据结构进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是数据元素通过指针连接的线性存储结构",
    "head": "链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "叶子节点的核心特征是在树结构中没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "满二叉树是每一层节点数都达到最大的二叉树",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性表数据元素一对一相邻且有先后顺序关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "线性表是数据元素一对一排列且有顺序的结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "双向链表是节点含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接表通过链表存储图中顶点及邻接顶点信息",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "父节点是在树形结构中位于子节点之上的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "回路是图中从某顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树是每一层节点数都达到最大的二叉树",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "双向链表是节点含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互连通",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "满二叉树是每一层节点数都达到最大的二叉树",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "邻接矩阵用二维数组表示图中顶点间邻接关系",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表是节点有前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "非线性结构中数据元素间关系不满足线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表是尾节点指针指向头节点的链表结构",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "根节点是树结构中位于顶端没有父节点的节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互连通",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "交换排序通过比较与交换元素位置来完成排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回路是在电路中电流能够循环流动的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "叶子节点是指在树状结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "链表是通过节点指针依次连接而成的数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "叶子节点的核心特征是在树结构中没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "选择基准值将数组分两部分，递归排序各部分",
    "head": "数组",
    "tail": "递归",
    "head_offset": "6",
    "tail_offset": "13"
  },
  {
    "sentence": "通过选择基准元素将数组分两部分并递归排序",
    "head": "数组",
    "tail": "递归",
    "head_offset": "9",
    "tail_offset": "16"
  },
  {
    "sentence": "堆排序利用堆结构特性高效地对数据进行排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "邻接表以链表形式存储图中顶点及相关边信息",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "连通图是任意两点之间都存在路径可相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互连通",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接表通过链表存储图中顶点及邻接顶点信息",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "循环链表是首尾相连的链表，无明显头尾节点",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树是一种分层数据结构且有根节点及子树关系",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "12",
    "tail_offset": "16"
  },
  {
    "sentence": "单链表通过节点指针依次相连，数据存储离散",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "图的顶点是图结构中用于表示数据元素的节点",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性结构数据元素之间存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "循环链表是尾节点指针指向头节点的链表结构",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "连通图中任意两点之间都存在路径可相互到达",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "在有序数组中通过不断二分区间查找目标元素",
    "head": "数组",
    "tail": "查找",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "交换排序通过比较与交换元素位置来实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数组是存储相同类型数据的有序集合且内存连续",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "单链表是节点通过指针依次连接形成的线性结构",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以全面了解结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "回路是在图中从某顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "双向链表每个节点有前驱和后继指针可双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "非线性结构中数据元素之间存在非一对一的关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问其所有节点的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "非线性结构中数据元素之间的关系不呈线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是由节点组成通过指针相连的线性数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "图是由顶点集合及顶点间边集合构成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "12"
  },
  {
    "sentence": "根节点是树结构中处于顶端无父节点的起始节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "双向链表是节点包含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "链表是通过指针将节点连接起来的线性数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "回溯法按选优条件深度优先搜索并适时回溯找解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "比较排序通过元素间比较确定其相对顺序来排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "非线性结构中数据元素之间存在非一对一的关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "递归基础是递归函数中终止递归调用的初始条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "递归基础是递归函数中无需递归调用的最简情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回路是在图中从一顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点以遍历图或树",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "回路是在图中从某顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "双向链表是节点包含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "单链表是一种每个节点只含一个指针域的线性表",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问其所有节点的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "数据逻辑结构特点是数据元素间抽象关系的体现",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "按顺序依次查找数据序列中目标元素的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "5",
    "tail_offset": "17"
  },
  {
    "sentence": "根节点是树结构中处于顶层无父节点的起始节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "根节点是树结构中处于顶层无父节点的起始节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性结构中数据元素之间存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "快速排序以基准值分区，递归分治实现高效排序",
    "head": "快速排序",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以全面了解结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "连通图是任意两点间都存在路径可相互到达的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "双向链表是节点包含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "交换排序是通过元素交换位置来实现排序的方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "根节点是树结构中位于顶端无父节点的起始节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点以遍历图或树",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "双向链表是节点包含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "归并排序是将数组分治后合并有序子数组来排序",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是相同类型数据的有序集合且内存连续存储",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉树每个节点最多有两个子节点且有层次结构",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以全面了解结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点以遍历图或树",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树结构中位于顶层无父节点的起始节点是根节点",
    "head": "父节点",
    "tail": "根节点",
    "head_offset": "9",
    "tail_offset": "18"
  },
  {
    "sentence": "双向链表是节点包含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "归并排序将数组分治后合并，使有序性逐步提升",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "树是一种分层结构，有根节点且子节点关系明确",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "10",
    "tail_offset": "14"
  },
  {
    "sentence": "数组是相同类型数据的有序集合且内存连续存储",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "双向链表是节点包含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "链表是通过指针连接节点来存储数据的线性结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定最终排序顺序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "非线性结构中数据元素之间存在非一对一的关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "按特定顺序访问二叉树中所有节点的操作叫遍历",
    "head": "访问",
    "tail": "二叉树",
    "head_offset": "5",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表是节点包含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "选择基准值将数组分两部分，递归对两部分排序",
    "head": "数组",
    "tail": "递归",
    "head_offset": "6",
    "tail_offset": "13"
  },
  {
    "sentence": "在有序数组中通过不断折半查找目标元素的方法",
    "head": "数组",
    "tail": "查找",
    "head_offset": "3",
    "tail_offset": "12"
  },
  {
    "sentence": "回溯法按选优条件深度优先搜索并适时回溯找解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回溯法按选优条件深度优先搜索并适时回溯求解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数组是存储相同类型数据的有序集合且内存连续",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "父节点在数据结构中是比子节点层次更高的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树是一种分层结构，有根节点且子节点关系明确",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "10",
    "tail_offset": "14"
  },
  {
    "sentence": "根节点是树结构中处于顶层无父节点的起始节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "非线性结构中数据元素之间的关系不呈线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "交换排序是通过元素交换位置来实现排序的方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "回溯法按选优条件深度优先搜索并适时回溯找解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回路是在图中从一顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "按顺序逐个检查元素以查找目标元素的查找方式",
    "head": "查找",
    "tail": "查找",
    "head_offset": "10",
    "tail_offset": "17"
  },
  {
    "sentence": "双向链表是节点包含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点以遍历图或树",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "数据逻辑结构指数据元素间抽象关系不依赖存储",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以全面了解结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "数组是存储相同类型数据的有序集合且内存连续",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "按顺序逐个比较元素查找目标直至找到或遍历完",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "9",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回溯法按选优条件深度优先搜索并适时回溯求解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问其节点的操作方式",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以全面了解结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "非线性结构中数据元素之间存在非一对一的关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回路是数据结构中从起点出发又回到起点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "在有序数组中通过不断折半查找目标元素的方法",
    "head": "数组",
    "tail": "查找",
    "head_offset": "3",
    "tail_offset": "12"
  },
  {
    "sentence": "线性结构中数据元素之间存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "链表是由节点组成通过指针连接的数据存储结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回路是在图中从某节点出发又回到该节点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "顺序查找按顺序逐个检查数据元素直至找到目标",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "回路是在图中从一顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "叶子节点的核心特征是在树状结构中没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉树每个节点最多有两个子节点且有层次结构",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "叶子节点的核心特征是在树状结构中没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "根节点是树结构起始点无父节点且具有特殊地位",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据逻辑结构特点指数据元素间抽象关系及特性",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以全面了解结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "回路是在图中从一顶点出发又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "单链表是一种每个节点只含一个指针域的线性表",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "递归基础是递归函数中无需递归调用的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "线性表是由零个或多个数据元素组成的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "链表是由节点组成通过指针连接的数据存储结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "父节点在数据结构中是比子节点层级更高的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性结构中数据元素之间存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "非线性结构中数据元素之间的关系不呈线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径能够相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "双向链表每个节点有前驱和后继指针可双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "双向链表每个节点有前驱和后继指针可双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数据逻辑结构特点指数据元素间抽象关系及特性",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "叶子节点的核心特征是在树状结构中没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "交换排序是通过元素间比较与交换位置实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "回路是在电路中能形成电流循环流动的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "递归基础是递归函数中无需递归调用的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点下方的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "递归基础是递归函数中终止递归调用的初始条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "非线性结构中数据元素间的关系不满足线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点确保全面不重复",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "非线性结构中数据元素之间的关系不呈线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问其节点的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "回路是数据结构中从起点出发又回到起点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "递归基础是递归函数中终止递归调用的初始条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "双向链表每个节点有前驱和后继指针可双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "非线性结构中数据元素之间存在非一对一的关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图是任意两点间都存在路径可相互到达的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "选择基准元素将数组分两部分，递归排序各部分",
    "head": "数组",
    "tail": "递归",
    "head_offset": "7",
    "tail_offset": "14"
  },
  {
    "sentence": "交换排序是通过元素交换位置来实现排序的方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树结构中位于顶端无父节点的起始节点是根节点",
    "head": "父节点",
    "tail": "根节点",
    "head_offset": "9",
    "tail_offset": "18"
  },
  {
    "sentence": "顺序查找按顺序逐个检查数据元素直至找到目标",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "在有序数组中通过不断比较中间值来查找目标值",
    "head": "数组",
    "tail": "查找",
    "head_offset": "3",
    "tail_offset": "16"
  },
  {
    "sentence": "线性结构中数据元素之间存在一对一的线性关系",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "非线性结构中数据元素之间的关系不呈线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "双向链表是节点包含前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "递归基础是递归函数中无需递归调用的最简情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "交换排序是通过元素间比较与交换位置来实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "存储结构核心概念是数据元素及其关系的存储方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性表是数据元素有序排列且有一对一关系的序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "存储结构特点包括数据元素存储及关系呈现方式等",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "比较排序通过元素间比较确定元素相对顺序来排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树的度是指一棵树中，其节点拥有子树的最大数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "每次从未排序序列中选最小元素放已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "16"
  },
  {
    "sentence": "指针是存储变量内存地址的变量用于间接访问数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "非线性结构中数据元素之间的关系不满足线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是内存地址的变量，用于间接访问和操作数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "对于最小堆，父节点的值小于或等于其子节点的值",
    "head": "堆",
    "tail": "父节点",
    "head_offset": "4",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且唯一的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以完整呈现树结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置进行排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置完成排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "堆排序基于堆结构，通过选择和交换实现数据排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置完成排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树状结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "回溯法基础特点是按条件深度优先搜索并适时回溯",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "图中任意两点都存在路径可相互连通的图是连通图",
    "head": "路径",
    "tail": "连通图",
    "head_offset": "9",
    "tail_offset": "19"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回路是在电路或系统中能形成电流循环的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "回路是在电路或系统中能形成电流循环的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "连通图是图中任意两点都存在路径可相互到达的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "归并排序是将数组分治后合并以达有序的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "循环链表是尾节点指向头节点形成环形结构的链表",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "从数据序列开头依次逐个查找目标元素的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "11",
    "tail_offset": "18"
  },
  {
    "sentence": "树的深度是从根节点到最远叶节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序通过比较元素大小来确定其最终排序位置",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "顺序查找是从数据序列开头依次逐个查找目标元素",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回溯法基础特点是按条件深度优先搜索并适时回溯",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的度是指一棵树中，其节点拥有子树的最大数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "栈具有后进先出的特点即最后入栈的元素最先出栈",
    "head": "栈",
    "tail": "入栈",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "子节点是树状结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树的查找基于树形结构通过特定路径确定元素位置",
    "head": "查找",
    "tail": "路径",
    "head_offset": "2",
    "tail_offset": "14"
  },
  {
    "sentence": "循环链表是一种尾节点指针指向头节点的链表结构",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二分查找在有序数组中通过不断折半查找目标元素",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆排序利用堆结构将数据排序，根节点最大或最小",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "在有序数组中通过不断二分比较查找目标值的方法",
    "head": "数组",
    "tail": "查找",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "树是一种有根节点且子节点关系唯一的非线性结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点到最远叶节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定其最终排序位置",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以完整呈现树结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "每次从未排序序列中选最小元素放已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "16"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以全面了解树结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "指针是存储变量内存地址的变量具有间接访问特性",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树是一种分层结构有根且子树不相交的非线性结构",
    "head": "子树",
    "tail": "非线性结构",
    "head_offset": "11",
    "tail_offset": "17"
  },
  {
    "sentence": "循环链表是尾节点指向头节点形成循环的链表结构",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "快速排序通过选择基准值将数组分两部分递归排序",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "链表是通过节点指针连接数据元素的线性数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是n个具有相同特性的数据元素的有限序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "双向链表是每个节点有前驱和后继指针的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树是一种有根节点且子节点关系唯一的非线性结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "回溯法基础特点是按条件深度优先搜索并适时回溯",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的深度是从根节点到最远叶节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中位于顶端没有父节点的特殊节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "图是由顶点集合及顶点间边的集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "13"
  },
  {
    "sentence": "选择基准分两部分递归排序使数组有序的排序算法",
    "head": "选择基准",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问树中所有节点的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "链表由节点组成，节点间通过指针相连以存储数据",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "广度优先搜索按层次依次访问节点以找到目标节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是指在树状数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置进行排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "选择基准值将数组分两部分递归排序以达快速有序",
    "head": "数组",
    "tail": "递归",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "存储结构核心概念是数据元素及其关系的存储方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据逻辑结构定义核心概念是数据元素间逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "13"
  },
  {
    "sentence": "图是由顶点集合及顶点间边的集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "13"
  },
  {
    "sentence": "映射是集合间元素按规则对应关系的一种数学概念",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "指针是存储变量内存地址的变量用于间接访问数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性表是数据元素一对一排列且有先后顺序的结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "树是一种分层结构有根且子树不相交的非线性结构",
    "head": "子树",
    "tail": "非线性结构",
    "head_offset": "11",
    "tail_offset": "17"
  },
  {
    "sentence": "子节点是树状结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置存储数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "每次从未排序序列中选最小元素放已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "16"
  },
  {
    "sentence": "叶子节点是指在树状数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "数据逻辑结构定义核心概念是数据元素间逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "13"
  },
  {
    "sentence": "数据逻辑结构定义核心概念是数据元素间逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "13"
  },
  {
    "sentence": "子节点是树状结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "比较排序通过比较元素大小来确定其最终排序位置",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "链表是通过节点指针依次相连存储数据的线性结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "图中任意两点都存在路径可相互连通的图是连通图",
    "head": "路径",
    "tail": "连通图",
    "head_offset": "9",
    "tail_offset": "19"
  },
  {
    "sentence": "非线性结构中数据元素之间的关系不满足线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置完成排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树状结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "深度优先搜索按深度推进，优先探索一条路径到底",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "广度优先搜索按层次依次访问节点以找到目标节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "根节点是树结构中位于顶端没有父节点的特殊节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置进行排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树每个节点左右子树高度差绝对值不超1",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "平衡二叉树每个节点左右子树高度差绝对值不超1",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "图是由顶点集合及顶点间边的集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "13"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "从数据序列开头依次逐个查找目标元素的查找方式",
    "head": "查找",
    "tail": "查找",
    "head_offset": "11",
    "tail_offset": "18"
  },
  {
    "sentence": "交换排序核心概念是通过比较交换元素位置来排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "平衡二叉树每个节点左右子树高度差绝对值不超1",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置完成排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点是指在树状数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "指针是存储变量内存地址的变量具有间接访问特性",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据逻辑结构定义核心概念是数据元素间逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置完成排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置完成排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置进行排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种有根节点且子节点关系唯一的非线性结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "数据逻辑结构定义核心概念是数据元素间逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "13"
  },
  {
    "sentence": "每个数据元素包含数据和指针两部分，指针指向下",
    "head": "数据元素",
    "tail": "指针",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "按照特定顺序访问二叉树中所有节点的操作叫遍历",
    "head": "访问",
    "tail": "二叉树",
    "head_offset": "6",
    "tail_offset": "8"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是由根节点和若干子树构成的层次结构数据结构",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断折半查找目标值",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于自身右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以完整呈现树结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树的节点是包含数据及指向子节点链接的基本单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "平衡二叉树每个节点左右子树高度差绝对值不超1",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "每次从未排序序列中选最小元素放已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "16"
  },
  {
    "sentence": "子节点是树状结构中直接连接在父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "归并排序将数组分成子数组排序后合并成有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "指针是存储变量内存地址的变量具有间接访问特性",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "链表由节点组成，节点含数据及指针指向下一节点",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "存储结构核心概念是数据元素及其关系的存储方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "连通图是图中任意两点都存在路径可相互连通的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树的度是指一棵树中，其节点拥有子树的最大数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置进行排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是数据结构中树状结构的起始节点无父节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点是指在树状数据结构中没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以全面了解树结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "将未排序数据插入已排序序列的合适位置完成排序",
    "head": "排序",
    "tail": "插入",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "每次从未排序序列中选最小元素与未排序首位交换",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "16"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "每次从未排序序列中选最小元素放已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "16"
  },
  {
    "sentence": "树是由根节点和若干子树构成的层次结构数据结构",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "树是一种递归定义的包含根节点及子树的非线性结构",
    "head": "递归",
    "tail": "根节点",
    "head_offset": "4",
    "tail_offset": "11"
  },
  {
    "sentence": "数据逻辑结构特点指数据元素间抽象关系不依赖存储",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "数据逻辑结构特点指数据元素间抽象关系及组织形式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是具有相同数据类型元素的有序集合且内存连续",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表由节点组成，节点通过指针相连，数据存储灵活",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "归并排序是将数组分治后合并有序子数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点以遍历图或树结构",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列的合适位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "按顺序逐个检查数据元素以查找目标元素的查找方式",
    "head": "数据元素",
    "tail": "查找",
    "head_offset": "7",
    "tail_offset": "12"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回路是从一点出发经一系列节点后又回到该点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "叶子节点是数据结构中树状结构里没有子节点的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "递归基础是递归函数中无需再次递归调用的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "栈是一种限定仅在表尾进行插入和删除操作的线性表",
    "head": "表尾",
    "tail": "插入",
    "head_offset": "8",
    "tail_offset": "12"
  },
  {
    "sentence": "按顺序逐个查找数据直至找到目标或遍历完所有数据",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "5",
    "tail_offset": "16"
  },
  {
    "sentence": "堆是一种完全二叉树，父节点键值大于或小于子节点",
    "head": "完全二叉树",
    "tail": "父节点",
    "head_offset": "4",
    "tail_offset": "10"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的算法，先建堆再调整",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树每个节点最多有两个子节点且有特定层次结构",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序查找是按顺序逐个检查数据元素以确定目标元素",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点以遍历图或树结构",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "数据逻辑结构特点指数据元素间抽象关系及组织方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "图由顶点集合及顶点间边的集合组成的一种数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "12"
  },
  {
    "sentence": "链表由节点组成各节点通过指针相连数据存储不连续",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到地址以快速存取数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "指针是存储变量内存地址并能通过它访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "递归基础是递归函数中最简单无需再递归的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找可行解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "从数据序列开头依次查找目标元素直至找到或遍历完",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "9",
    "tail_offset": "20"
  },
  {
    "sentence": "归并排序是将数组分块排序后合并成有序数组的算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是由节点组成，节点间通过指针连接的数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "回路是从一点出发经一系列节点后又回到该点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "比较排序是基于元素间比较进行顺序排列的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "比较排序是基于元素间比较进行顺序排列的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "邻接表以链表形式存储图中顶点及与其相邻顶点信息",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "递归基础是递归函数中无需递归调用即可终止的条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列的合适位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序查找按顺序逐个检查元素直至找到目标或遍历完",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性查找按顺序逐个检查元素直至找到目标或遍历完",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "递归基础是递归函数中无需再次递归调用的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "比较排序是基于元素间比较进行顺序排列的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "指针是存储变量内存地址并可通过它访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "数据类型定义是规定数据取值范围及操作集合的概念",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差不超过1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是通过指针将节点连接起来形成的线性数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及邻接关系的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "数据逻辑结构特点指数据元素间抽象关系及组织形式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列的合适位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差不超过1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找可行解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "归并排序是将数组分块排序后合并成有序数组的算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "哈希表是通过哈希函数将键映射到值的一种数据结构",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种分层结构数据，有根节点且各节点有子节点",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "12",
    "tail_offset": "20"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序通过元素间比较确定其相对顺序来进行排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "堆是一种完全二叉树，父节点键值大于或小于子节点",
    "head": "完全二叉树",
    "tail": "父节点",
    "head_offset": "4",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是比较相邻元素大小并交换位置的排序算法",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "线性表是数据元素有序排列且存在一对一关系的序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "归并排序是将数组分治后合并有序子数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中从根节点到最远叶节点最长简单路径上边的数目",
    "head": "根节点",
    "tail": "路径",
    "head_offset": "3",
    "tail_offset": "16"
  },
  {
    "sentence": "二叉树每个节点最多有两个子节点且有特定结构关系",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "指针是存储变量内存地址并能通过它访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "冒泡排序是比较相邻元素大小并交换位置的排序算法",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "循环链表是链表尾节点指向头节点形成环的数据结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回溯法是通过尝试所有可能路径求解问题的算法策略",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "按顺序逐个检查数据元素以查找目标元素的查找方法",
    "head": "数据元素",
    "tail": "查找",
    "head_offset": "7",
    "tail_offset": "12"
  },
  {
    "sentence": "简单排序是通过比较与交换元素位置实现排序的方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "顺序查找是从数据序列开头依次查找目标元素的方法",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "递归基础是递归函数中无需再次递归调用的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "图由顶点集合及顶点间边的集合组成的一种数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "12"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列的合适位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树是一种有根节点且子树互不相交的非线性数据结构",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中数据元素及指向子树分支构成的基本单位是节点",
    "head": "数据元素",
    "tail": "子树",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点是包含数据及指向子节点的链接的基本单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "递归基础是递归函数中无需再次递归调用的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列的合适位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索并适时回溯的算法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "递归基础是递归函数中无需再次递归调用的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找可行解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间来求解问题",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "比较排序是基于元素间比较进行顺序排列的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中各节点的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点以遍历图或树结构",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "归并排序是将数组分治后合并有序子数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序查找按顺序逐个检查元素直至找到目标或遍历完",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "比较排序是基于元素间比较进行顺序排列的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "选择基准分治递归将数组按基准值划分为两部分排序",
    "head": "递归",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "9"
  },
  {
    "sentence": "数据结构中稳定性指排序前后相等元素相对位置不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "图是由顶点集合及顶点间边的集合所组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "13"
  },
  {
    "sentence": "堆是一种完全二叉树，父节点键值大于或小于子节点",
    "head": "完全二叉树",
    "tail": "父节点",
    "head_offset": "4",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找可行解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "线性结构是数据元素之间存在一对一线性关系的结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构指数据元素及其关系在计算机内的存储方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "深度优先搜索是按深度优先依次访问节点的搜索方法",
    "head": "深度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据逻辑结构特点指数据元素间抽象关系不依赖存储",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "树中数据元素及指向子树分支构成的基本单位是节点",
    "head": "数据元素",
    "tail": "子树",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中各节点的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "邻接表通过链表存储顶点及相连顶点信息体现图结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据结构中稳定性指排序前后相等元素相对位置不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "数据结构中稳定性指相同元素排序前后相对位置不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "5",
    "tail_offset": "13"
  },
  {
    "sentence": "简单排序是通过比较和交换元素位置实现排序的方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "递归基础是递归函数中无需再次递归调用的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数据逻辑结构特点指数据元素间抽象关系不依赖存储",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法是通过尝试多种路径并回退来求解问题的方法",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序查找按顺序逐个检查元素直至找到目标或遍历完",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性查找按顺序逐个检查元素直至找到目标或遍历完",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的无向图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素间比较进行顺序排列的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点以遍历图或树结构",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点以遍历图或树结构",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "从数据序列首个元素起依次查找目标元素的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "12",
    "tail_offset": "19"
  },
  {
    "sentence": "根节点是树结构中位于顶端没有前驱节点的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数据逻辑结构定义的核心概念是数据元素间逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "14"
  },
  {
    "sentence": "深度优先搜索按深度推进探索，优先往深处扩展路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "从数据序列开头依次查找目标元素直至找到或遍历完",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "9",
    "tail_offset": "20"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列的合适位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回溯法是通过尝试多种路径并回退来求解问题的方法",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "图由顶点集合及顶点间边的集合构成的一种数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "12"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长路径长度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归函数中无需递归调用的终止条件情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "从数据序列开头依次查找目标元素直到找到或遍历完",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "9",
    "tail_offset": "20"
  },
  {
    "sentence": "交换排序是通过比较交换元素位置来实现排序的方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "归并排序是将序列分治后合并有序子序列的排序算法",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "线性结构是数据元素之间存在一对一线性关系的结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "递归基础是递归函数中无需递归调用的最简情况定义",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点右子树值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径的无向图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树是一种分层结构，有根且子树不相交的非线性结构",
    "head": "子树",
    "tail": "非线性结构",
    "head_offset": "12",
    "tail_offset": "18"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "顺序查找按顺序逐个检查元素直至找到目标或遍历完",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "按顺序逐个检查数据元素以查找目标元素的查找方法",
    "head": "数据元素",
    "tail": "查找",
    "head_offset": "7",
    "tail_offset": "12"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索并适时回溯的方法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "归并排序是将数组分治后合并有序子数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是存储变量内存地址并可通过它访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "二叉树遍历按特定顺序访问节点以完整呈现树形结构",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "顺序查找是按顺序逐个检查数据元素以确定目标元素",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "快速排序是通过一趟排序将数组分为两部分并递归排序",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "链表是通过节点指针依次连接存储数据的线性数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种尾节点指向头节点形成循环的链表结构",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素直至找到目标元素",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "回溯法基础特点是按条件深度优先搜索解空间找可行解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "比较排序是通过元素间比较确定其相对顺序的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "每趟从待排序元素中选最小（大）值与未排序首位交换",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树是所有节点都有左右子树且叶子层满的二叉树",
    "head": "满二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "快速排序是通过一趟排序将数据分为两部分并递归排序",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆是一种特殊数据结构，父节点键值大于或小于子节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "11",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种包含根节点且节点间有层次关系的非线性结构",
    "head": "根节点",
    "tail": "非线性结构",
    "head_offset": "6",
    "tail_offset": "19"
  },
  {
    "sentence": "满二叉树是除叶子外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "深度优先搜索是按深度优先依次访问节点直至完成搜索",
    "head": "深度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "抽象数据类型是对数据及操作进行抽象描述的数据类型",
    "head": "抽象数据类型",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表是一种尾节点指向头节点形成循环的链表结构",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索按深度依次访问节点直至无法深入再回溯",
    "head": "深度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "快速排序是通过一趟排序将数组分为两部分并递归排序",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "指针是存储变量内存地址并通过该地址访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "每次从未排序数据中选最小（大）值放已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后再合并的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆是一种特殊数据结构，父节点键值大于或小于子节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "11",
    "tail_offset": "21"
  },
  {
    "sentence": "映射是一种元素对应关系一个集合到另一个集合的对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图是指图中任意两个顶点之间都存在路径相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "深度优先搜索是按路径延伸到最深层再回溯的搜索方法",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "指针是存储变量内存地址并通过该地址访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "父节点是在树形结构中位于上一层可连接子节点的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "指针是内存中存储变量地址并可通过它访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "深度优先搜索沿一条路径深入探索直到无法继续再回溯",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "单链表通过节点指针依次连接，每个节点指向下一节点",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索沿一条路径深入探索直到无法继续再回溯",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "队列的特点是先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "在数据结构中，稳定性指排序后相同元素相对位置不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "7",
    "tail_offset": "11"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后再合并的排序方法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "深度优先搜索沿一条路径深入探索直至无法继续才回溯",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树是一种有根节点且子节点具有层次关系的非线性结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表通过节点指针依次相连，每个节点只知后继节点",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素直至找到目标元素",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "每次从未排序数据中选最小（大）值放已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "指针是内存中存储变量地址并能通过它访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "子节点是树状结构中直接连接在某个父节点之下的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "在树形结构中父节点是直接有子节点连接于其下的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "6",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图是任意两个顶点之间都存在路径可相互到达的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "图中任意两点之间都存在路径可相互连通的图是连通图",
    "head": "路径",
    "tail": "连通图",
    "head_offset": "11",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种分层结构且根节点唯一子树不相交的数据结构",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "9",
    "tail_offset": "14"
  },
  {
    "sentence": "树的查找基于树形结构从根节点开始按特定规则找目标",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "快速排序是通过一趟排序将数组分为两部分并递归排序",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆是一种特殊数据结构，父节点键值大于或小于子节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "11",
    "tail_offset": "21"
  },
  {
    "sentence": "线性表是数据元素有序排列且有唯一前驱和后继的序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "堆是一种特殊树形结构，父节点键值大于或小于子节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "11",
    "tail_offset": "21"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找解的方法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "链表是通过指针将离散存储的节点顺序连接的数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "线性表是数据元素有序排列且有前驱和后继关系的序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "哈希表是通过哈希函数将键映射到存储位置的数据结构",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "哈希表是通过哈希函数将键映射到存储位置的数据结构",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索并适时回溯求解问题",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "链表通过节点指针相连，数据存储不连续且可灵活增减",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是内存中存储变量地址并可通过其访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且唯一位于顶层的节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是除叶子外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "哈希表通过哈希函数将数据映射到特定位置以快速存取",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树遍历是按特定顺序访问二叉树中所有节点的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "数组是存储相同类型数据的有序集合具有特定内存结构",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "哈希表是通过哈希函数将键映射到存储位置的数据结构",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是存储变量内存地址且可通过地址访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标值位置",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "树是一种有根节点且子节点具有层次关系的非线性结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表是一种每个节点只含一个指针域的链式存储结构",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "哈希表通过哈希函数将数据映射到特定位置以快速存取",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "递归基础是递归函数中无需递归调用可直接求解的情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "快速排序是通过一趟排序将数组分为两部分并递归排序",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "回路是在电路中电流能沿其流动并回到起点的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "哈希表是通过哈希函数将键映射到存储位置的数据结构",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "哈希表是通过哈希函数将键映射到存储位置的数据结构",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "在数据结构中稳定性指相同元素排序前后相对位置不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "6",
    "tail_offset": "14"
  },
  {
    "sentence": "单链表由节点组成每个节点含数据及指向下一节点指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树是一种包含根节点且节点间有层次关系的非线性结构",
    "head": "根节点",
    "tail": "非线性结构",
    "head_offset": "6",
    "tail_offset": "19"
  },
  {
    "sentence": "按顺序逐个查找数据元素直至找到目标元素的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "5",
    "tail_offset": "7"
  },
  {
    "sentence": "树是一种有根节点且子节点具有层次关系的非线性结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "循环链表是一种链表其尾节点指针指向头节点形成循环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆是一种特殊数据结构，父节点键值大于或小于子节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "11",
    "tail_offset": "21"
  },
  {
    "sentence": "哈希表是通过哈希函数将键映射到存储位置的数据结构",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标值位置",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "每次从未排序数据中选最小（大）值与未排序首位交换",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "每次从未排序元素中选最小（大）值放已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树是除叶子外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "哈希表是通过哈希函数将键映射到存储位置的数据结构",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表由节点组成，节点包含数据及指向下一节点的指针",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "在树形结构中位于顶层没有父节点的起始节点是根节点",
    "head": "父节点",
    "tail": "根节点",
    "head_offset": "12",
    "tail_offset": "21"
  },
  {
    "sentence": "回路是在电路中电流能从电源出发回到电源的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "指针是存储变量内存地址并通过该地址访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "深度优先搜索是按路径延伸方向深入探索直至无法继续",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树是一种有根节点且子节点具有层次关系的非线性结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "循环链表是链表尾节点指向头节点形成循环的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "满二叉树是除叶子外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "满二叉树是除叶子外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "循环链表是链表尾节点指向头节点形成循环的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后再合并的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种有根节点且子节点具有层次关系的非线性结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "快速排序是通过一趟排序将数据分为两部分并递归排序",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "快速排序是通过一趟排序将数组分成两部分并递归排序",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "每趟从未排序元素中选最小（大）值与未排序首位交换",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "单链表由节点组成每个节点含数据及指向下一节点指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树是一种有根节点且子节点具有层次关系的非线性结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "5",
    "tail_offset": "9"
  },
  {
    "sentence": "连通图是指图中任意两个顶点之间都存在路径相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "按顺序逐个检查数据元素直至找到目标元素的查找方法",
    "head": "数据元素",
    "tail": "查找",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "指针是存储变量内存地址并可通过它访问该变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "线性表是数据元素有序排列且有唯一前驱和后继的序列",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "每次从未排序数据中选最小（大）值放已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径长度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "在树形结构中，父节点是指其下面连接有子节点的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "7",
    "tail_offset": "18"
  },
  {
    "sentence": "树查找基于树结构从根节点开始按特定规则找目标元素",
    "head": "查找",
    "tail": "树",
    "head_offset": "1",
    "tail_offset": "5"
  },
  {
    "sentence": "链表是通过指针连接节点且数据存储不连续的数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "回路是在电路中电流能沿其流动并形成闭合路径的部分",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "快速排序是通过一趟排序将数据分为两部分再分别排序",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "队列的核心性质是先进先出即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表是由节点组成且每个节点只指向下一节点的线性表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "简单排序是按特定规则依次比较交换元素位置的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "广度优先搜索按层次依次扩展节点先访问距离起始点近的",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "归并排序是将数组分成子数组分别排序再合并的排序方法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树顶端的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断折半查找目标值的方法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "链表是由节点组成，节点包含数据及指向下一节点的指针",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "队列是一种先进先出、按顺序存储和操作数据的线性结构",
    "head": "队列",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子节点的树形数据结构",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断二分区间来定位目标值",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "指针是存储变量内存地址，能间接访问和修改数据的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "单链表由节点组成，每个节点指向下一节点形成线性结构",
    "head": "单链表",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "回路是在电路中电流能够依次通过各元件形成的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及邻接顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "堆是一种特殊数据结构满足父节点键值大于或小于子节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "12",
    "tail_offset": "22"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标值的方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置以快速存取数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "循环链表是一种首尾相连的链表，无明显头指针和尾指针",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "比较排序是基于元素比较来确定元素相对位置的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "堆是一种特殊的数据结构，父节点键值大于或小于子节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "12",
    "tail_offset": "22"
  },
  {
    "sentence": "在树形结构中位于顶层、没有父节点的起始节点是根节点",
    "head": "父节点",
    "tail": "根节点",
    "head_offset": "13",
    "tail_offset": "22"
  },
  {
    "sentence": "图是一种由顶点集合及顶点间的关系集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "7",
    "tail_offset": "16"
  },
  {
    "sentence": "指针是存储变量内存地址并可通过它间接访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置以快速存取数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉搜索树中左子树节点值小于根节点小于右子树节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序通过元素间比较确定元素间相对次序来实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "每趟从未排序元素中选最小（大）值与未排序首元素交换",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉搜索树中左子树节点值小于根节点小于右子树节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "堆是一种满足父节点键值大于或小于子节点的完全二叉树",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "6",
    "tail_offset": "16"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索并适时回溯求解的方法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉搜索树中左子树节点值小于根节点小于右子树节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "队列是一种先进先出、按顺序存储与操作数据的线性结构",
    "head": "队列",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置以快速存取数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是通过比较元素大小来确定元素最终位置的排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定其相对次序的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉搜索树中左子树节点值小于根节点小于右子树节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断折半查找目标值的方法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "从根节点到最远叶子节点所经最长路径的边数为树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断二分区间确定目标位置",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "无向图是一种图结构其中任意两个顶点之间的边没有方向",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "每次从未排序数据中选最小（大）值置于已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "19"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置以快速存取数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标值的方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "从根节点到最远叶子节点经过的最长路径长度即树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树的最顶层的节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "从数据序列开头依次查找目标元素的查找方法叫顺序查找",
    "head": "查找",
    "tail": "查找",
    "head_offset": "9",
    "tail_offset": "16"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树顶端的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及邻接顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "队列是一种先进先出、按顺序存储与操作数据的线性结构",
    "head": "队列",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "链表是由节点组成的线性数据结构，节点间通过指针相连",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索直到无法继续",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "栈具有后进先出的特点，即最后进入栈的元素最先离开栈",
    "head": "栈",
    "tail": "栈",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "链表是由节点组成，节点间通过指针相连的线性数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断折半查找目标值的方法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树顶端的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "归并排序是将数组分块排序后合并成有序数组的排序方法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是左右两个子树高度差不超过1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标值的方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "队列的核心性质是先进先出即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回溯法按选优条件深度优先搜索尝试，遇不可行退回再选",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断折半查找目标值的方法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "每次从未排序数据中选最小（大）值置于已排序序列末尾",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "19"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定其相对位置的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "每次从未排序数据中选最小（大）值与未排序首元素交换",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉搜索树中左子树节点值小于根节点小于右子树节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断折半查找目标值的方法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "指针是内存中存储变量地址并通过该地址访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "队列是一种先进先出、按顺序存储和操作数据的线性结构",
    "head": "队列",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "每次从未排序数据中选最小（大）值与未排序首元素交换",
    "head": "排序",
    "tail": "排序",
    "head_offset": "4",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉搜索树中左子树节点值小于根节点小于右子树节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是由节点组成的线性数据结构，节点间通过指针相连",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "平衡二叉树是左右两个子树高度差不超过1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "图是一种由顶点集合及顶点间的关系集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "7",
    "tail_offset": "16"
  },
  {
    "sentence": "指针是存储变量内存地址并可通过该地址访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及邻接顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "快速排序是通过选择基准值将数组分为两部分并递归排序",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "队列的核心性质是先进先出即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标值的方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子节点的树形数据结构",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标值的方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断折半查找目标值的方法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树顶端的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树是包含根节点及若干子树且子树互不相交的非线性结构",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "4",
    "tail_offset": "10"
  },
  {
    "sentence": "冒泡排序是比较相邻元素大小并交换位置逐步排序的算法",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是通过指针连接节点，数据存储分散的线性数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "单链表是由节点组成且每个节点只含一个指针域的线性表",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及邻接顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径能够相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "满二叉树是除叶节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "抽象数据类型是数据值及操作封装在独立单元的数据类型",
    "head": "抽象数据类型",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置以快速存取数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "指针是存储变量内存地址并可通过该地址访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性结构是数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "回路是从一节点出发经一系列节点后又回到该节点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "指针是存储变量内存地址并能通过该地址访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉搜索树中左子树节点值小于根节点小于右子树节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆是一种满足父节点键值大于或小于子节点的完全二叉树",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "6",
    "tail_offset": "16"
  },
  {
    "sentence": "指针是存储变量内存地址并可通过它间接访问变量的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子节点的树形数据结构",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树顶端的起始节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定其相对顺序的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的一种数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径的图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是相邻元素比较交换使大值如气泡上浮的排序法",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树以求解的方法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "图是一种由顶点集合及顶点间的关系集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "7",
    "tail_offset": "16"
  },
  {
    "sentence": "链表是通过指针连接节点存储数据且逻辑上相邻的线性结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "冒泡排序是比较相邻元素大小并按规则交换位置的排序算法",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "插入排序是逐个将元素插入已排序序列合适位置的排序方法",
    "head": "插入排序",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种分层结构有根节点且子节点唯一的非线性数据结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "9",
    "tail_offset": "13"
  },
  {
    "sentence": "从根节点到最远叶节点最长简单路径上边的数目即树的高度",
    "head": "根节点",
    "tail": "路径",
    "head_offset": "1",
    "tail_offset": "14"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "队列的核心性质是先进先出即先进入队列的元素先离开队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "简单排序是对数据按特定规则依次比较交换位置的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序，将数据调整为堆再提取元素",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "队列的核心性质是先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "回路是从一节点出发经一系列节点又回到该节点的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "回路是图中一条至少包含一条边的、起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "线性表是数据元素有序排列且有唯一前驱和后继的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "平衡二叉树是左右两个子树高度差绝对值不超过1的二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "比较排序是通过比较元素大小来确定其最终位置的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "从根节点到最远叶节点所经最长路径上的节点数为树的深度",
    "head": "根节点",
    "tail": "路径",
    "head_offset": "1",
    "tail_offset": "14"
  },
  {
    "sentence": "队列具有先进先出的特点，即先进入队列的元素先离开队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组的算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标元素的方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "简单排序是对数据按特定规则依次比较交换位置的排序方式",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对位置的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的节点是树结构中包含数据及指向子节点链接的基本单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找可行解的方法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组的算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的查找是在给定的树结构中寻找特定数据元素的操作过程",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "17"
  },
  {
    "sentence": "简单排序是对数据按特定规则依次比较交换位置的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是左右子树高度差绝对值不超过1的二叉排序树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序，将数据调整为堆后依次取出",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是比较相邻元素大小并按规则交换位置的排序算法",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树是一种分层结构有根节点且子节点唯一的非线性数据结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "9",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图是指图中任意两个顶点之间都存在路径能够相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "简单排序是对数据按特定规则依次比较交换位置的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "指针是内存中存储变量地址并能通过该地址访问变量的概念",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "循环链表是一种链表尾节点指向头节点形成环形的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断折半快速定位元素的方法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性表是数据元素有序排列且有唯一前驱和后继的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "简单排序是对数据按特定规则依次比较交换位置的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图是指图中任意两个顶点之间都存在路径能够相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "平衡二叉树是左右两个子树高度差绝对值不超过1的二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "哈希表通过哈希函数将数据映射到特定位置以实现快速查找",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "连通图是图中任意两个顶点之间都存在路径能够相连通的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找可行解的方法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找可行解的方法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "从根节点到最远叶节点最长简单路径上边的数目即树的高度",
    "head": "根节点",
    "tail": "路径",
    "head_offset": "1",
    "tail_offset": "14"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点具有包含数据元素以及指向其子节点的指针的特点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "递归基础是递归函数中最简单可直接求解无需再递归的情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "深度优先搜索是按路径延伸至最深层节点再回溯的搜索方法",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树是一种分层结构且每个节点有唯一父节点（根节点除外）",
    "head": "父节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "20"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标元素的方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "递归基础是递归函数中最简单可直接求解无需再递归的情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断缩小区间找目标值的方法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "平衡二叉树是左右两个子树高度差绝对值不超过1的二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性查找是逐一检查数据元素直到找到目标元素的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表通过节点指针依次相连，每个节点只存后继节点地址",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组的算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "归并排序是将数组分成子数组分别排序后再合并的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表是一种链表尾节点指向头节点形成循环的链表结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "简单排序是对数据按特定规则依次比较交换位置的排序方式",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性表是数据元素有序排列且有唯一前驱和后继的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "从根节点到最远叶子节点所经过的最长路径长度即树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "单链表通过节点指针依次相连存储数据，各节点地址不连续",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是具有相同数据类型的 n 个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "从根节点到最远叶子节点所经过的最长路径长度即树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "连通图是指图中任意两个顶点之间都存在路径能够相连的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的边的最大数目",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "从根节点到最远叶子节点所经过的最长路径长度为树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找可行解的方法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "满二叉树是除叶子节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "叶子节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是左右两个子树高度差绝对值不超过1的二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "从根节点到最远叶子节点所经过的最长路径长度即树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "简单排序是对数据按特定规则依次比较交换位置的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树是一种分层结构有根节点且子节点唯一的非线性数据结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "9",
    "tail_offset": "13"
  },
  {
    "sentence": "从根节点到最远叶节点所经最长路径上边的数目即树的深度",
    "head": "根节点",
    "tail": "路径",
    "head_offset": "1",
    "tail_offset": "14"
  },
  {
    "sentence": "满二叉树是除叶子节点外每个节点都有两个子节点的二叉树",
    "head": "满二叉树",
    "tail": "叶子节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "简单排序是对数据按特定规则依次比较交换位置的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "从根节点到最远叶节点最长简单路径上边的数目即树的高度",
    "head": "根节点",
    "tail": "路径",
    "head_offset": "1",
    "tail_offset": "14"
  },
  {
    "sentence": "回溯法是按选优条件深度优先搜索解空间树找可行解的算法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的节点是树结构中包含数据及指向子节点链接的基本单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "图是一种由顶点集合以及顶点间的边集合所组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "7",
    "tail_offset": "16"
  },
  {
    "sentence": "树是n个节点的有限集，有且仅有一个根节点且有若干子树",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "17",
    "tail_offset": "24"
  },
  {
    "sentence": "二叉树的特点是每个节点最多有两棵子树且子树有左右之分",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "线性表是具有相同数据类型的 n 个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "在树形结构中一个节点的直接前驱节点就是该节点的父节点",
    "head": "前驱节点",
    "tail": "父节点",
    "head_offset": "13",
    "tail_offset": "23"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标元素的方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标元素的方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置的排序方法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "从根节点到最远叶子节点所经最长路径上边的数目为树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "在树结构中按特定规则找到目标节点的操作是树查找核心概念",
    "head": "树",
    "tail": "查找",
    "head_offset": "20",
    "tail_offset": "21"
  },
  {
    "sentence": "从根节点到最远叶子节点所经最长路径上的节点数即树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素以确定目标值的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆是一种满足父节点键值与子节点键值特定关系的完全二叉树",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其相邻顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且唯一直接位于树顶端的节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其邻接顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列组成的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其相邻顶点关系的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆是一种满足父节点键值与子节点键值特定关系的完全二叉树",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "单链表是由节点组成，每个节点含数据及指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其相邻顶点关系的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点是包含数据及指向子节点的指针的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "从根节点到最远叶子节点所经最长路径上的节点数即树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度是从根节点到最远叶节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "队列的核心性质是先进先出，即先进入队列的元素先离开队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且唯一直接位于树顶端的节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其相邻顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点是包含数据及指向子节点的链接的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "在树状结构中，一个节点的直接后继节点即为该节点的子节点",
    "head": "后继节点",
    "tail": "子节点",
    "head_offset": "14",
    "tail_offset": "24"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置快速存储和查找数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树的最顶层的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置的排序方法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径相连的图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "从根节点到最远叶子节点所经最长路径上的节点数为树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点是树状结构中包含数据及指向子节点链接的基本单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其相邻顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其相邻顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "在树形数据结构中位于树顶端没有前驱节点的节点就是根节点",
    "head": "前驱节点",
    "tail": "根节点",
    "head_offset": "15",
    "tail_offset": "24"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "在树结构中按特定规则找到目标元素的操作是树查找核心概念",
    "head": "树",
    "tail": "查找",
    "head_offset": "20",
    "tail_offset": "21"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置的排序方法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点是包含一个数据元素及若干指向其子树的分支的结构",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其相邻顶点关系的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图是指图中任意两个顶点之间都存在路径能够相连通的图",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "快速排序是通过选择基准元素将数组划分为两部分并递归排序",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "从根节点到最远叶子节点所经最长路径上的节点数为树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "指针是存储变量内存地址并可通过其访问变量的一种数据类型",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "广度优先搜索按层次依次访问节点直至找到目标或遍历完所有",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "从根节点到最远叶子节点所经最长路径上的节点数为树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是按顺序逐个检查元素直至找到目标元素的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "23"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置快速存储和查找数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "单链表是一种每个节点只包含一个指针指向下一节点的线性表",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "在树形数据结构中位于树顶端没有前驱节点的节点就是根节点",
    "head": "前驱节点",
    "tail": "根节点",
    "head_offset": "15",
    "tail_offset": "24"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其相邻顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入已排序序列合适位置的排序方法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "队列的核心性质是先进先出，即先进入队列的元素先离开队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的节点是包含数据及指向子节点的链接的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与其相邻顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "深度优先搜索是按路径延伸到底再回溯找其他路径的搜索策略",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径能够相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "在树形结构中，位于树的最顶端没有前驱节点的节点就是根节点",
    "head": "前驱节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "25"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点是包含数据以及指向子节点的链接的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "在图论中回路是指一条至少包含一条边且起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "26"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "按特定顺序访问二叉树中所有节点的操作是二叉树遍历核心概念",
    "head": "访问",
    "tail": "二叉树",
    "head_offset": "5",
    "tail_offset": "7"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与它相邻接顶点的一种数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "哈希表是通过哈希函数将键映射到特定位置存储数据的数据结构",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "在树形结构中，根节点是没有前驱节点且位于树顶端的起始节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "7",
    "tail_offset": "13"
  },
  {
    "sentence": "从根节点到最远叶子节点所经最长路径包含的节点数为树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "1",
    "tail_offset": "7"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点其核心性质为没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的节点是包含数据及指向子节点的指针等相关信息的结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "在树形数据结构中，位于树的顶部没有父节点的节点就是根节点",
    "head": "父节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "25"
  },
  {
    "sentence": "单链表是由节点组成，每个节点包含数据及指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "树的节点是包含数据以及指向子节点的链接的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点是包含数据以及指向子节点的链接的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "子节点是树结构中与某个父节点直接相连且处于其下一层的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径能够相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "在树形结构中，位于树的顶部没有前驱节点的节点被称为根节点",
    "head": "前驱节点",
    "tail": "根节点",
    "head_offset": "15",
    "tail_offset": "25"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点是一棵树中没有子节点的节点其核心性质为没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图的核心性质是图中任意两个顶点之间都存在路径能够相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "在树形结构中，位于树的最顶端没有前驱节点的节点就是根节点",
    "head": "前驱节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "25"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图是由顶点的有穷非空集合和顶点之间边的集合组成的数据结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "19"
  },
  {
    "sentence": "数据类型是一个值的集合和定义在这个值集上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "链表是一种通过指针将一组数据元素按顺序链接起来的数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表是用链表存储图中顶点及与它相邻接顶点信息的数据结构",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点是包含数据元素及若干指向子树的分支的基本结构单元",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "单链表是由节点组成的线性表，节点含数据及指向下一节点指针",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是左右两个子树的高度差的绝对值不超过1的二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "在图论中回路是指一条至少包含一条边且起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "26"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数组是具有相同数据类型且元素存储在连续内存位置的数据集合",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点是包含一个数据元素及若干指向子树的分支的结构单元",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点其核心性质是没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "链表是一种通过指针将一组数据元素按顺序链接起来的数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "归并排序是将数组分成子数组排序后合并成有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径能够相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且唯一具有特殊地位的起始节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径能够相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点所经过的最长路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径能够相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "映射是一种元素对应关系，一个集合元素对应另一集合唯一元素",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "在树形数据结构中，位于树的顶部没有父节点的节点就是根节点",
    "head": "父节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "25"
  },
  {
    "sentence": "树的节点是包含数据以及指向子节点的链接的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树的起始位置的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "在图论中回路是指一条至少包含一条边且起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "26"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径能够相连",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "数据类型是一个值的集合和定义在这个值集上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点是包含数据元素及指向其子树的分支的基本数据结构单元",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性的核心性质是在排序过程中，相等元素的相对次序保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "从起始节点出发沿一条路径深入探索直到无法继续再回溯找新路径",
    "head": "路径",
    "tail": "路径",
    "head_offset": "10",
    "tail_offset": "27"
  },
  {
    "sentence": "单链表是一种链式存储的线性表由节点组成每个节点含数据和指针",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "从起始节点出发沿一条路径深入探索直到无法继续再回溯找新路径",
    "head": "路径",
    "tail": "路径",
    "head_offset": "10",
    "tail_offset": "27"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是按顺序逐个检查数据元素直至找到目标元素的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "12"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点是树结构中的数据元素，包含数据项及指向子节点的分支",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "有向图是一种图结构其中边具有方向即从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是在树形结构中没有前驱节点且唯一直接位于树顶端的节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "连通图是一个无向图，其中任意两个顶点之间都存在一条路径相连",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "广度优先搜索按层次依次访问节点直至找到目标或遍历完所有节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "从起始节点出发沿一条路径深入探索直到无法继续再回溯找新路径",
    "head": "路径",
    "tail": "路径",
    "head_offset": "10",
    "tail_offset": "27"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性的核心性质是在排序过程中，相等元素的相对次序保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "有向图是一种图结构其中边具有方向即从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树中左子树节点值小于根节点且右子树节点值大于根节点",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图是一个无向图，其中任意两个顶点之间都存在一条路径相连",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是由顶点集和边集组成的一种图结构其中边是顶点的无序对",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "叶子节点是一棵树中没有子节点的节点，其核心性质为没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表是一种链式存储的线性表由节点组成每个节点含数据和指针",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点是包含数据及若干指向子节点的分支的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "在图论中回路是图中一条至少包含一条边且起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "27"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "连通图是一个无向图，其中任意两个顶点之间都存在一条路径相连",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据类型是一个值的集合以及定义在这个值集上的一组操作的总称",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点是树结构中的数据元素，包含数据项及指向子节点的分支",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索按层次依次访问节点直至找到目标或遍历完所有节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点，其核心性质是没有子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点是包含数据及若干指向子节点的分支的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径能够连通的图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树状数据结构中位于树的最顶端没有前驱节点的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点是包含一个数据元素及若干指向其子树的分支的结构单元",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是由顶点集和边集组成的一种图结构其中边是顶点的无序对",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "单链表是由节点组成的线性表，节点含数据及指向下一节点的指针",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度是指从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点值右子树值大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而进行排序的算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长简单路径上的边数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中没有父节点且处于树的最顶端具有特殊地位的节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法是通过尝试多条路径来求解问题并在不满足条件时回退的方法",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而进行排序的算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "深度为k有n个结点的二叉树，若与同层满二叉树对应结点位置相同",
    "head": "二叉树",
    "tail": "满二叉树",
    "head_offset": "10",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树是除最后一层外每层节点数满且最后层靠左排列的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点值右子树值大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "在树形数据结构中，根节点是没有前驱节点且位于树顶端的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "9",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点值右子树值大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "非线性结构中至少存在一个数据元素有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树的顶端具有特殊地位的节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中连续存储的有序集合",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而进行排序的算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "单链表是一种链式存储的线性表每个节点含数据和指针指向下一节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "完全二叉树是除最后一层外每层节点数满且最后层靠左排列的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径能够相连通的图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径能够相互连通",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中连续存储的有序集合",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "深度优先搜索是沿一条路径深入探索直到无法继续再回溯的搜索方法",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "在树形数据结构中，位于树的最顶端没有前驱节点的节点就是根节点",
    "head": "前驱节点",
    "tail": "根节点",
    "head_offset": "18",
    "tail_offset": "27"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点值右子树值大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉搜索树中每个节点左子树值小于该节点值右子树值大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "在图论中回路是指图中一条至少包含一条边且起点和终点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "28"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "在树形数据结构中，一个节点的直接后继节点被称为该节点的子节点",
    "head": "后继节点",
    "tail": "子节点",
    "head_offset": "16",
    "tail_offset": "27"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中连续存储的有序集合",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树中从根节点到最远叶子节点的最长简单路径上的边数就是树的高度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "叶子节点是一棵树中没有子节点的节点其核心性质为不存在任何子节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的节点是树结构中的数据元素，包含数据项及指向其子树节点的链接",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加至最远叶节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是除最后一层外每层节点数满且最后一层靠左排列的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "平衡二叉树左右子树高度差绝对值不超过1且左右子树都是平衡二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "完全二叉树是除最后一层外每层节点数满且最后一层靠左对齐的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "完全二叉树是除最后一层外每层节点数满且最后一层靠左对齐的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点是包含数据以及指向子节点的指针或引用的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "平衡二叉树左右子树高度差绝对值不超过1且左右子树都是平衡二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "在图论中，回路是指一条路径中第一个顶点和最后一个顶点相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "5",
    "tail_offset": "11"
  },
  {
    "sentence": "树的节点包含数据元素以及指向其子节点的链接并且具有唯一的根节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种包含根节点且每个节点有零个或多个子节点的非线性数据结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "6",
    "tail_offset": "20"
  },
  {
    "sentence": "二叉树的特点是每个节点最多有两个子节点且具有递归定义的树形结构",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的高度的核心性质是从根节点到最远叶节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "平衡二叉树左右子树高度差绝对值不超过1且左右子树都是平衡二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "完全二叉树是除最后一层外每层节点数满且最后一层靠左对齐的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素间相对次序从而进行排序的算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "对于一个最小堆，每个节点的值都小于或等于其子节点的值，并且堆是",
    "head": "堆",
    "tail": "堆",
    "head_offset": "6",
    "tail_offset": "29"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加至最远叶节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是除最后一层外每层节点数满且最后一层靠左对齐的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数或节点数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的度是指一棵树中，最大的节点度，而节点度是节点拥有子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆排序是利用堆结构进行排序的算法，将数据构建成堆后依次取出元素",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点是树结构中的基本单元包含数据元素及指向其子树节点的指针",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加至最远叶节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "单链表是由节点组成的线性表，每个节点含数据及指向下一节点的指针",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "单链表通过节点指针依次相连存储数据，逻辑上相邻物理上不一定相邻",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的有限序列",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "完全二叉树是除最后一层外每层节点数满且最后一层靠左对齐的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "递归基础的核心性质是存在可直接求解而无需再次递归调用的最简情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二叉搜索树中每个节点的左子树值小于该节点值右子树值大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加至最远叶节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈具有后进先出的特点且操作受限，仅允许在栈顶进行插入和删除操作",
    "head": "栈",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "队列具有先进先出的特点即元素按照进入的先后顺序依次从队列中取出",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "完全二叉树是除最后一层外每层节点数满且最后一层靠左排列的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "存储结构的核心特征是数据元素及其关系在计算机存储器中的存储方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列的合适位置的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加直至叶节点所经过的最大层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "在树形结构中一个节点的子节点所对应的上一级节点就是该节点的父节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "11",
    "tail_offset": "29"
  },
  {
    "sentence": "树的高度的核心性质是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度为k有n个结点的二叉树，除第k层外其余层满且最左子树深度为k",
    "head": "二叉树",
    "tail": "左子树",
    "head_offset": "10",
    "tail_offset": "25"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而进行排序的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元包含数据元素及指向其子节点的分支",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的高度的核心性质是从根节点到最远叶子节点的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元包含数据项以及指向其子节点的指针",
    "head": "树的节点",
    "tail": "数据项",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的高度的核心性质是从根节点到最远叶节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的度是树内各节点的度的最大值其中节点的度是节点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且处于树的起始位置具有特殊地位的节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件使递归过程能够终止的初始情况定义",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "根节点是树结构中没有父节点且处于树的最顶层具有特殊地位的起始节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "稳定性的特点的核心特征是在排序过程中，相等元素的相对顺序保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的深度是从根节点开始，到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性的特点的核心特征是在排序过程中，相等元素的相对顺序保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的查找是在给定的树结构中按照特定规则寻找特定数据元素的操作过程",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "23"
  },
  {
    "sentence": "深度优先搜索是从起始节点出发沿一条路径深入探索直到无法继续再回溯",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而进行排序的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "树的深度是从根节点开始，到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中递归调用终止的条件即直接给出问题最简形式的解",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "深度优先搜索是从起始节点出发沿一条路径深入探索直到无法继续再回溯",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "在树形结构中一个节点若有直接后继节点则该节点为其后继节点的父节点",
    "head": "后继节点",
    "tail": "后继节点",
    "head_offset": "14",
    "tail_offset": "24"
  },
  {
    "sentence": "树的度是树内各结点的度的最大值其中结点的度是结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "树中节点的度是该节点拥有子树的数目，树的度是树内各节点度的最大值",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "12",
    "tail_offset": "18"
  },
  {
    "sentence": "对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "集合",
    "tail": "集合",
    "head_offset": "2",
    "tail_offset": "15"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且处于树的起始位置具有特殊地位的节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度是从根节点开始，到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "稳定性是指在数据结构中，相同元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "单链表通过节点指针依次连接，每个节点包含数据及指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "链表是由节点组成的线性数据结构，节点包含数据及指向下一节点的指针",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "数据的物理结构的核心性质是数据元素及其关系在计算机存储器内的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "树的节点是树结构中的数据元素，包含数据项及指向子节点的分支等信息",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "递归基础是递归函数中直接给出结果而无需再次递归调用自身的最简情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树的查找是在给定的树结构中按照特定规则寻找特定数据元素的操作过程",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉树的核心性质包括在二叉树的第i层上至多有2的i-1次方个结点",
    "head": "二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长路径到最远叶子节点所经过的边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素之间比较来确定元素相对次序从而进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中节点的最大度数称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个元素是否属于这个集合是确定的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长路径到最远叶子节点所经过的边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，到最远叶子节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的度是树内各结点的度的最大值其中结点的度是指结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "在树形数据结构中父节点是指其直接有子节点且是子节点的前驱节点的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "8",
    "tail_offset": "17"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点所经过的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点，处于树的起始位置，具有特殊地位的节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "指针的核心性质是其存储内存地址并可通过该地址访问和操作内存中的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "路径是图中顶点与顶点之间经过边的有序序列且路径长度是路径上边的数目",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的度是树内各结点的度的最大值其中结点的度是指结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的边数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加直到最远叶子节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加直到最远叶子节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点所经过的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图是一个无向图，若其中任意两个顶点之间都存在路径相连则为连通图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中一个节点的子树数目称为该节点的度，树中节点的最大度数称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "回路是图中一条起点和终点相同的路径且除起点和终点外其余顶点均不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树的高度的核心性质是从根节点到最远叶子节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循先进后出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "确定性是指对于一个给定的集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "12",
    "tail_offset": "27"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素间相对次序从而进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "对于最小堆，每个节点的值都小于或等于其子节点的值，并且堆是一种完全",
    "head": "堆",
    "tail": "堆",
    "head_offset": "4",
    "tail_offset": "27"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中节点的最大度数称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，到最远叶子节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度的核心性质是从根节点到最远叶子节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中节点的最大度数称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "二叉树的核心性质包括：在二叉树的第i层上至多有2的i-1次方个节点",
    "head": "二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的高度的核心性质是从根节点到最远叶子节点的最长简单路径上边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "在树形结构中，若一个节点有直接子节点，则该节点为这些子节点的父节点",
    "head": "子节点",
    "tail": "子节点",
    "head_offset": "15",
    "tail_offset": "26"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，到最远叶子节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长路径到最远叶子节点所经过的边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序过程中，相等的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的度是树内各结点的度的最大值其中结点的度是指结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中一个节点的子树数目称为该节点的度，树中节点的最大度数称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "在树形结构中一个节点的子节点所对应的直接上层节点就是该节点的父节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "11",
    "tail_offset": "30"
  },
  {
    "sentence": "数据类型的核心特征是定义了一组值的集合以及可作用于这些值的一组操作",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "队列的核心特征是其操作遵循先进先出原则即先进入队列的元素先离开队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "树的度的核心特征是树中所有结点的度的最大值即一棵树中最大的子树数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "树的度是树内各节点的度的最大值，其中节点的度是节点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长路径到最远叶子节点所经过的边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度树中各节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，到最远叶子节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长路径到最远叶子节点所经过的边的数量",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循先进后出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点所经过的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点是树结构中的基本单元包含数据元素以及指向其子节点的若干指针",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "比较排序通过比较元素之间的大小关系来确定元素的相对顺序从而进行排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "确定性是指对于一个给定的集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "12",
    "tail_offset": "27"
  },
  {
    "sentence": "树中各节点度的最大值即为树的度且树中每个节点的度都小于或等于树的度",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "12",
    "tail_offset": "30"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "稳定性是指在排序过程中，相等元素的相对位置在排序前后保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循先进后出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "无向图是由顶点集和边集组成的一种图结构其中边集中的边是顶点的无序对",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长路径到最远叶子节点所经过的边的数量",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长路径到最远叶子节点所经过的边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "队列的特点的核心特征是先进先出即元素按照进入队列的先后顺序依次出队",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元包含数据元素及指向其子树节点的分支",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "确定性是指对于一个给定的集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "12",
    "tail_offset": "27"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度树中各节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度树中各节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的、在内存中按顺序存储的一种数据结构",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度树中各节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度树中各节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，到最远叶子节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度树中各节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "30"
  },
  {
    "sentence": "对于最小堆，每个节点的值都小于或等于其子节点的值，并且堆是一种完全",
    "head": "堆",
    "tail": "堆",
    "head_offset": "4",
    "tail_offset": "27"
  },
  {
    "sentence": "树的深度的核心性质是从根节点到最远叶子节点的最长简单路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "确定性是指对于一个给定的集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "12",
    "tail_offset": "27"
  },
  {
    "sentence": "回路是图中一条起点和终点相同的路径且除起点和终点外路径上的顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据类型的核心特征是规定了数据的取值范围以及可对该数据执行的操作集合",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "树的节点的核心特征是具有一个数据元素以及零个或多个指向其子节点的指针",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，用一个单链表存储其所有邻接顶点",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "父节点是在树形结构中，其直接有子节点相连且处于比子节点更高层次的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置，将无序数组转换为有序数组的排序方法",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的度是指树中所有结点的度的最大值其中结点的度是该结点拥有子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长简单路径到最远叶节点所经过的边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置，将无序数组转换为有序数组的排序方法",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，到最远叶子节点所经过的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的查找是在树这种数据结构中通过特定方法寻找满足特定条件的节点的操作",
    "head": "查找",
    "tail": "树",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，通过链表形式存储其所有邻接顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，具有后进先出的特点",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "集合具有确定性，即给定一个集合，任何一个元素是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "递归基础是递归函数中直接给出结果而无需再次递归调用自身的最简情况定义",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树中一个节点的子树数目称为该节点的度，而树的度是树内各节点度的最大值",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "树中节点的度是指该节点拥有子树的数目，而树的度是树内各节点度的最大值",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "13",
    "tail_offset": "20"
  },
  {
    "sentence": "回路是图中一条起点和终点相同的路径且除起点和终点外路径上的顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数据类型具有特定的取值范围、存储方式、操作集合以及语义含义等核心性质",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中各节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "31"
  },
  {
    "sentence": "树的度是指树中所有结点的度的最大值其中结点的度是该结点拥有子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "稳定性是指在排序算法中，相等的元素在排序前后的相对位置保持不变的特点",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，通过链表形式存储其所有邻接顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的度是树内各结点的度的最大值，其中结点的度是该结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点所经过的最长简单路径上的边数或节点数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定其相对次序从而对数据进行排序的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针域指向头节点，从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回路的核心性质是其起点和终点相同且路径中至少包含一条边并形成封闭路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，直到最远叶子节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，使得整个链表形成一个环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，具有后进先出的特点",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "简单排序是对数据序列按特定规则比较和交换元素位置以使其有序的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，遵循先进后出的原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中每个节点一次且仅一次的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "回路是图中一条起点和终点相同的路径且路径中除起点和终点外的顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "循环链表是一种链表结构其尾节点的指针域指向头节点从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "父节点是在树形结构中，其直接有子节点且处于比子节点更高层次关系的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树的节点是树结构中的基本单元包含数据元素以及指向其子节点的指针或引用",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "循环链表的核心特征是表尾节点的指针域指向表头节点从而使链表形成一个环",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "稳定性的核心性质是在排序过程中，相等元素的相对顺序在排序前后保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的度是指树中所有结点的度的最大值其中结点的度是该结点拥有子树的个数",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "数据类型定义的核心性质包括有一组值的集合以及定义在该集合上的一组操作",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "比较排序是一种基于比较元素间大小关系来确定元素最终排列顺序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，用一个单链表存储其所有邻接顶点",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，直到最远叶子节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "稳定性的核心性质是在排序过程中，相等元素的相对顺序在排序前后保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树中一个节点的子树数目称为该节点的度，而树的度是树内各节点度的最大值",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "树的度是树中所有结点的度的最大值，其中结点的度是该结点拥有子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "回路是图中一条起点和终点相同的路径且路径中除起点和终点外的顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，用一个单链表存储其所有邻接顶点",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "非线性结构中至少存在一个数据元素有两个或两个以上的直接前驱或直接后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "队列的特点是先进先出，即按照进入队列的先后顺序，先进入的元素先出队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的高度的核心特征是从根节点到最远叶子节点之间的最长简单路径上的边数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "比较排序是一种基于比较元素间大小关系来确定元素最终排列顺序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "插入排序的核心性质是将未排序数据插入到已排序序列的合适位置以完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长简单路径到最远叶节点所经过的边的数目",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据类型的核心特征是定义了一组值的集合以及可以作用于这些值的一组操作",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "数据类型的核心特征是定义了数据的取值范围以及可对该数据执行的操作集合",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "简单排序是对数据序列按特定规则比较和交换元素位置以使其有序的排序方式",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（若图为有向图则路径有方向）",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "树中一个节点的子树数目称为该节点的度，树中所有节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "32"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每个节点且仅访问一次的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "子节点是树结构中直接被另一个节点（父节点）所连接且处于其下一层级的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "父节点是在树形结构中，直接与一个或多个子节点相连且位于子节点之上的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "在树形结构中，根节点是没有前驱节点且位于树的顶部具有特殊地位的起始节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "7",
    "tail_offset": "13"
  },
  {
    "sentence": "比较排序的核心性质是通过元素间的比较来确定元素间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置从而完成排序的一种算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "比较排序的核心性质是其排序过程仅通过元素间的比较来确定元素间的相对次序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "插入排序的核心性质是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉树每个节点最多有两棵子树，并且二叉树的子树有左右之分，次序不能颠倒",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "比较排序的核心性质是其排序过程仅通过元素间的比较来确定元素间的相对次序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中所有节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "32"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每个节点且仅访问一次的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "稳定性是指在排序过程中，相等元素之间的相对位置在排序前后保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中满足终止条件、不再进行递归调用的初始情况或边界条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "数据类型的核心特征是它定义了数据的取值范围以及可对该数据执行的操作集合",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "插入排序的核心性质是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的节点是包含数据及指向子节点的指针（若存在子节点）的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的度是树内各节点的度的最大值，其中节点的度是指该节点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "单链表是一种由节点组成的线性数据结构，节点包含数据和指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树中各节点度的最大值即为树的度且树的度反映了树中节点分支情况的最大程度",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "12",
    "tail_offset": "16"
  },
  {
    "sentence": "归并排序的核心性质是将数组分成两个子数组分别排序后再合并成一个有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "插入排序的核心性质是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "线性表的核心性质是具有有限个数据元素且数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数据类型具有其特定的取值范围、存储方式、操作集合以及语义含义等核心性质",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置从而完成排序的一种算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中所有节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "32"
  },
  {
    "sentence": "比较排序的核心性质是其排序过程仅通过元素之间的比较来确定元素的相对次序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的度是指树中所有结点的度的最大值，其中结点的度是该结点拥有子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中所有节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "32"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是不是这个集合的元素就确定了",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "队列的特点是先进先出，即先进入队列的元素先出队列，后进入的元素后出队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "稳定性是指在排序过程中，相等元素之间的相对顺序在排序前后保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中所有节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "32"
  },
  {
    "sentence": "回路是图中一条起点和终点相同的路径且路径中除起点和终点外其他顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "递归基础的核心特征是存在无需再次递归调用自身就能直接给出结果的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "父节点是在树形结构中直接与一个或多个子节点相连且处于较高层次位置的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "简单排序是对数据元素进行比较和交换等操作以将其按特定顺序排列的排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置从而完成排序的一种算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "指针的核心性质是其存储内存地址并可通过该地址间接访问和操作内存中的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "树中一个节点的子树数目称为该节点的度，树中所有节点度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "32"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，都通过链表形式存储其所有邻接顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "指针是一种变量其值为内存中另一个变量的地址用于间接访问该内存位置的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素在排序结果中的相对位置",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件从而使递归过程能够终止的初始情况或条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下到最远叶子节点所经过的最长路径上的节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种树形结构每个节点最多有两个子节点分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "父节点是树结构中一个节点，它有零个或多个子节点且是子节点的直接前驱节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "比较排序的核心性质是其排序过程仅通过元素间的比较来确定元素间的相对次序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "从树的根节点开始，到最远叶子节点所经过的最长路径上的节点数就是树的深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "3",
    "tail_offset": "12"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元包含数据项以及指向其子节点的指针或引用",
    "head": "树的节点",
    "tail": "数据项",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据类型的核心特征是它定义了数据的取值范围以及可对该数据执行的操作集合",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "插入排序的核心性质是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "比较排序是基于元素间比较操作来确定元素间相对次序从而实现排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列组成的集合且内存中存储地址连续",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表是一种由节点组成的线性数据结构，节点包含数据和指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，到最远叶子节点所经过的节点层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每个节点一次且仅一次的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针指向头节点，使得链表形成一个环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每个节点且仅访问一次的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，而树的度是树中所有节点的度的最大值",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "简单排序是对数据序列通过比较和交换等操作逐步将其排列成有序状态的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "单链表是一种由节点组成的线性数据结构每个节点包含数据和指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "简单排序是对数据序列按特定规则依次比较和交换元素位置以使其有序的排序方式",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元，包含数据元素以及指向其子节点的若干分支",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "简单排序是对数据序列通过特定比较和交换等操作逐步将元素按序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "比较排序的核心性质是其排序过程仅通过元素间的比较操作来确定元素的相对次序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来将无序数组转变为有序数组的排序算法",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是元素按照先进先出的原则进行入队和出队操作",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "稳定性是指在数据结构中，相同关键字的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中每个节点一次且仅一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "稳定性是指在数据结构中，相同关键字的元素在排序前后相对位置保持不变的性质",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "稳定性的核心性质是对于输入数据中的相等元素，排序后它们的相对顺序保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "集合具有确定性即对于一个给定的集合，任何一个元素是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "指针的核心性质是其存储的是内存地址，通过该地址可以访问和操作内存中的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据元素",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中所有节点的度的最大值称为树的度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "33"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置，将无序序列逐步调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "稳定性是指在数据结构中，相同关键字的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "比较排序的核心性质是其排序过程仅通过元素间的比较操作来确定元素的相对次序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "稳定性是指在数据结构中，相同关键字元素的相对次序在排序前后保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素在有序序列中相对位置从而实现排序的算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "稳定性是指在数据结构中，相同关键字的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "交换排序是一种通过比较元素并交换位置，将无序数组转变为有序数组的排序算法",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二叉树每个节点最多有两棵子树，且子树有左右之分，是一种重要的树形数据结构",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值以表示其某种属性或代价等",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中最简单的情况，它直接给出问题的解而无需进一步递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "无向图是一种图结构，其中边没有方向，任意两个顶点之间若存在边则可双向通行",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是一种变量其值为内存中另一个变量的地址用于间接访问该变量所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "稳定性是指在数据结构中，相同关键字元素在排序前后的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置来逐步将无序序列转变为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "树的度是指树中所有结点的度的最大值，其中结点的度是该结点拥有的子树的个数",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "稳定性是指在数据结构中，相同关键字元素的相对位置在排序前后保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "稳定性是指在数据结构中，相同关键字的元素在排序前后相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元，包含数据元素以及指向其子节点的若干分支",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来将无序序列转换为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "二叉树是一种树形结构，每个节点最多有两个子节点，分别为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的节点是包含数据以及指向其子节点的指针（若有子节点）的基本数据结构单元",
    "head": "树的节点",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "深度优先搜索是从起始节点出发沿一条路径深入探索直到无法继续再回溯找新路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "简单排序是对数据序列通过比较和交换等基本操作将其按特定顺序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "简单排序是对数据序列通过比较和交换等基本操作将其按特定顺序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储方式包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "22"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来将无序序列转换为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置，将无序序列逐步调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置，将无序序列逐步转换为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "父节点具有比子节点更高一层的层级关系且在树形结构中是子节点的直接前驱节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的度的核心特征是树中所有结点的度的最大值，即树中各结点子树个数的最大值",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "顺序表具有随机访问特性，即可以通过下标直接访问元素，时间复杂度为O(1)",
    "head": "访问",
    "tail": "访问",
    "head_offset": "7",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中每个节点一次且仅一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "树的节点是包含数据以及指向子节点的链接的基本数据结构单元用于构成树形结构",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，其操作遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中每个节点一次且仅一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单位，包含数据元素以及指向其子节点的若干分支",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "存储结构的特点是指数据元素及其关系在计算机存储器中的表示方式所具有的特性",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数组具有固定大小，元素类型相同，通过下标访问，内存中连续存储这些核心特征",
    "head": "数组",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来将无序序列转换为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "映射的核心性质是对于集合A中的任意一个元素在集合B中都有唯一的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "归并排序的核心性质是将一个数组分成两个子数组分别排序后再合并成一个有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "映射的核心性质是对于集合A中的任意一个元素在集合B中都有唯一的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "深度优先搜索是从起始节点出发沿一条路径深入探索直到无法继续再回溯的搜索策略",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "单链表是一种由节点组成的线性数据结构，每个节点包含数据和指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度，其中结点的度是指该结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "14",
    "tail_offset": "32"
  },
  {
    "sentence": "指针的核心性质是其存储内存地址并可通过该地址间接访问和操作所指向的内存单元",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的节点是包含数据以及指向其子节点的指针（若存在子节点）的基本数据结构单元",
    "head": "树的节点",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "栈具有后进先出的特点，其核心性质是元素按照后进先出的顺序进行入栈和出栈操作",
    "head": "栈",
    "tail": "入栈",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "简单排序是对数据序列通过比较和交换等操作逐步将元素按特定顺序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "交换排序是指通过比较和交换元素位置，将无序序列逐步转换为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "数据类型定义的核心特征是规定了数据的取值范围以及在该数据上可进行的操作集合",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "归并排序的核心性质是将一个序列分成两个子序列分别排序后再合并成一个有序序列",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "循环链表的核心特征是表尾节点的指针域指向表头节点，从而使整个链表形成一个环",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "单链表是一种由节点组成的线性数据结构，每个节点包含数据及指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "映射的核心性质是对于集合A中的任意一个元素在集合B中都有唯一的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素之间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "树的度是指一棵树中所有结点的度的最大值，其中结点的度是该结点拥有子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "比较排序是一种基于比较元素之间大小关系来确定元素最终排序位置的数据排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "插入排序的特点的核心性质是将未排序数据插入到已排序序列的合适位置以完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性查找的核心性质是按顺序依次对数据序列中的每个元素进行比较以查找目标元素",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "31"
  },
  {
    "sentence": "栈具有后进先出的特点，其核心性质是元素按照后进先出的顺序进行入栈和出栈操作",
    "head": "栈",
    "tail": "入栈",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素之间的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素之间的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "归并排序的核心性质是将一个数组分成两个子数组分别排序后再合并成一个有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性表是零个或多个数据元素的有限序列，其中数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "线性表是零个或多个数据元素的有限序列，其中数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每个节点一次且仅一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "单链表是一种由节点组成的线性数据结构，每个节点包含数据及指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素之间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉树的遍历是按照某种规则依次访问二叉树中的每个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而对数据序列进行排序的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "树的度的核心特征是树中所有结点的度的最大值，即树中各结点的子树个数的最大值",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点且是树中所有其他节点的祖先节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关且独立于计算机",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "映射的核心性质是对于集合A中的任意一个元素在集合B中都有唯一的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式包括数据元素的存储及其关系的存储",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度，其中结点的度是指该结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "14",
    "tail_offset": "32"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而对元素序列进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉搜索树中每个节点的值大于其左子树所有节点的值且小于其右子树所有节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "循环链表的核心特征是表中最后一个结点的指针域指向头结点，整个链表形成一个环",
    "head": "循环链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉树的遍历是按照某种规则依次访问二叉树中的每个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "比较排序是一种基于比较元素之间大小关系来确定元素最终排列顺序的数据排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "回路是图中一条起点和终点相同的路径且路径中除起点和终点外其他顶点不重复经过",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "单链表是一种由节点组成的线性数据结构，每个节点包含数据和指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素之间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "二叉树是一种树形结构，每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "比较排序的核心性质是其排序过程仅通过元素间的比较操作来确定元素间的相对次序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "单链表是一种由节点组成的线性数据结构，每个节点包含数据和指向下一节点的指针",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "比较排序的核心性质是其排序过程仅通过元素之间的比较操作来确定元素的相对顺序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度且树中每个结点的度是该结点拥有子树的个数",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "14",
    "tail_offset": "32"
  },
  {
    "sentence": "递归基础的特点的核心特征是存在无需递归调用即可直接求解的最简情况或终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的边数或节点数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，在排序前后其相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "映射的核心性质是对于集合A中的任意一个元素在集合B中都有唯一的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "父节点是在树形结构中，直接与一个或多个子节点相连且处于子节点之上层级的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "有向图是一种图结构其中边具有方向性即每条边都有一个特定的起始顶点和终止顶点",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "映射是集合 A 到集合 B 的一种对应关系使 A 中元素在 B 中有唯一对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树是一种树形结构，其每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树遍历是按照某种规则依次访问二叉树中所有节点且每个节点仅被访问一次的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素的存储方式以及数据元素之间关系的表示方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "满二叉树是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "递归基础是递归算法中最简单情况，通常是无需递归调用即可直接得出结果的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数组转变为有序数组的排序算法",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "简单排序是对数据元素序列通过比较和交换等操作逐步将其排列成有序序列的排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "简单排序是对数据元素序列通过比较和交换等操作逐步将其排列成有序序列的排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每一个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "满二叉树是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树是一种包含根节点且具有层次结构，每个节点有零个或多个子节点的非线性数据结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "6",
    "tail_offset": "27"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "指针的核心性质是其存储的是变量的内存地址并可通过该地址间接访问和操作对应变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值以表示该边的某种属性或代价等",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，排序前后它们的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每一个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "数据的逻辑结构的定义的核心性质是描述数据元素之间的逻辑关系且与数据的存储无关",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "18"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的物理结构的核心性质包括数据元素的存储方式以及数据元素之间关系的表示方法",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件从而直接给出结果无需进一步递归调用的初始情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "在树形结构中，若一个节点存在直接后继节点，那么该节点即为这些后继节点的父节点",
    "head": "后继节点",
    "tail": "后继节点",
    "head_offset": "16",
    "tail_offset": "30"
  },
  {
    "sentence": "映射的核心特征包括对于集合A中的任意一个元素在集合B中都有唯一的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度即树中一个结点的子树个数的最大值为该树的度",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "14",
    "tail_offset": "25"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素间相对次序从而对数据序列进行排序的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，树中其他节点都直接或间接与根节点相连",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "栈具有先进后出的特点即后进入栈的元素先出栈且操作上仅在栈顶进行插入和删除操作",
    "head": "栈",
    "tail": "出栈",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "简单排序是对数据序列通过特定比较和交换等操作逐步将其排列成有序状态的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素间相对次序从而对数据进行排序的一种排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "插入排序的特点的核心性质是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种树形结构，其每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "父节点具有比子节点更高一层的层级关系且对其下的子节点具有直接的关联和控制关系",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础的核心性质是存在递归终止条件使得递归调用能够停止且能直接给出明确结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "在树形数据结构中若存在一个节点有直接后继节点则该节点是其直接后继节点的父节点",
    "head": "后继节点",
    "tail": "后继节点",
    "head_offset": "18",
    "tail_offset": "30"
  },
  {
    "sentence": "插入排序的特点的核心性质是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种树形结构，其每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问所指向的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "比较排序是基于元素之间比较来确定元素相对次序从而对元素序列进行排序的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构且左右子树有顺序之分不能随意颠倒",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "父节点是在树形结构中，其下方连接有一个或多个子节点且自身没有直接父节点的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "在图论中回路是指从图中某一顶点出发，沿图的边经过若干顶点后又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "36"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素相对次序从而进行排序的一种排序算法类型",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "满二叉树是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每一个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "交换排序是一种通过比较元素并交换位置来逐步将无序序列调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "数据的逻辑结构的特点是反映数据元素之间逻辑关系而不考虑其在计算机中的存储方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "比较排序是一种基于元素之间比较操作来确定元素相对顺序从而对序列进行排序的算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "二叉树是一种树形结构，其每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "在图论中，回路是指一条起点和终点相同的路径且路径中除起点和终点外的顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "5",
    "tail_offset": "19"
  },
  {
    "sentence": "二叉树是一种树形结构，其每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "满二叉树是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "递归基础的特点的核心特征是存在无需再次递归调用自身就能直接得出结果的最简情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "简单排序是对数据元素按照特定规则进行比较和交换等操作以使其有序排列的排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "满二叉树是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "简单排序是对数据元素按照特定规则进行比较和交换等操作以使其有序排列的排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "满二叉树是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "交换排序是通过比较元素大小并交换位置，将无序序列逐步调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "二叉树是一种树形结构，其每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来逐步将无序数组转变为有序数组的排序方法",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "线性表是一种由有限个数据元素组成的序列，其中数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "插入排序的特点的核心性质是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来将无序序列逐步调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "树的度是指一棵树中所有结点的度的最大值，其中结点的度是该结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "二叉树的遍历是指按照某种规则依次访问二叉树中的每个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定其相对次序从而对元素序列进行排序的一种排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "交换排序是一种通过比较元素并交换位置来逐步将无序数组转变为有序数组的排序方法",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "插入排序的特点的核心性质是将未排序数据插入到已排序序列的合适位置从而完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树顶端，处于最高层次具有特殊地位的起始节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "指针的核心性质是其存储了变量的内存地址，通过该地址可以访问和操作所指向的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "满二叉树是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "在一个无向图中，如果任意两个顶点之间都存在路径相连，那么这个无向图就是连通图",
    "head": "无向图",
    "tail": "路径",
    "head_offset": "3",
    "tail_offset": "21"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来逐步将无序序列转变为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "二分查找是在有序数组中，通过不断将区间缩小一半来查找目标值的一种高效查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "简单排序是对数据元素按照特定规则进行比较和交换等操作以使其有序排列的排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉树的遍历是指按照某种规则依次访问二叉树中的每一个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "比较排序的核心特征是通过比较元素之间的大小关系来确定元素在排序结果中的相对位置",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "映射的核心性质是对于集合A中的任意一个元素在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树的核心性质是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，用于表示该边的某种属性或代价",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中满足终止条件可直接得出结果而无需再次递归调用自身的初始情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "在树形结构中，一个节点若存在直接后继节点，那么该节点就是其直接后继节点的父节点",
    "head": "后继节点",
    "tail": "后继节点",
    "head_offset": "16",
    "tail_offset": "31"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行某一运算过程以求解问题的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "满二叉树的核心特征是除最后一层无任何子节点外，每一层上的所有节点都有两个子节点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "映射的核心性质是对于集合A中的任意一个元素在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "映射的核心性质是对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的高度的核心特征是从树的根节点到最远叶子节点所经过的最长路径上的边数或节点数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，在排序前后它们的相对位置保持不变的性质",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，在排序前后它们的相对顺序保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一特点",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，在排序前后它们的相对位置保持不变的性质",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "抽象数据类型具有数据的逻辑结构、定义在该结构上的一组操作以及数据的封装性等特点",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，用于表示边的某种属性或代价等",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式包括数据元素的存储表示及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "映射的核心特征为对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "在图中，从某一顶点出发，沿某些边经过一些顶点后又回到该出发点的一条路径称为回路",
    "head": "路径",
    "tail": "回路",
    "head_offset": "33",
    "tail_offset": "37"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间缩小一半来查找特定目标值的一种高效查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度其核心性质是树中各结点度的最大值决定了树的度",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "14",
    "tail_offset": "36"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，在排序前后它们的相对位置保持不变的性质",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "队列的核心特征是其元素按照先进先出的原则进行处理，即先进入队列的元素先离开队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "映射的核心特征是对于集合A中的每一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树的核心特征是除最后一层无任何子节点外，每一层上的所有节点都有两个子节点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "简单排序是对数据序列通过特定比较和交换等操作逐步将元素按一定顺序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "加权图是一种图结构其中每条边都被赋予一个数值权重以表示边的某种属性如距离成本等",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的集合，在内存中占用连续的存储空间",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度，即树中一个结点的子树个数的最大值为该树的度",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "14",
    "tail_offset": "26"
  },
  {
    "sentence": "二叉树是一种树形结构，它的每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别递归排序后再合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可间接访问其所指向的变量",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，在排序前后它们的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树是一种树形结构，它的每个节点最多有两个子节点，分别称为左子节点和右子节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "数据类型的核心特征是规定了数据所具有的值的集合以及可以对这些值执行的操作的集合",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点的核心性质为先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别递归排序后再合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相同关键字的元素，排序前后其相对位置保持不变的性质",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "比较排序是一种排序算法，其通过对元素间的比较来确定元素间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素相对次序从而对元素序列进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，在排序前后其相对位置保持不变的一种特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的边数体现出的树的层次数量特征",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉树的遍历是按照某种规则依次访问二叉树中的每个节点，使得每个节点仅被访问一次",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "映射的核心特征是对于集合A中的每一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树的核心特征是除最后一层无任何子节点外，每一层上的所有节点都有两个子节点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础的核心特征是存在无需进一步递归调用就能直接给出结果的最简情况或边界条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一特点",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "在树形结构中，若一个节点存在直接后继节点，那么该节点就是其直接后继节点的父节点",
    "head": "后继节点",
    "tail": "后继节点",
    "head_offset": "16",
    "tail_offset": "31"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储方式，包括数据元素的存储表示及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相同关键字的元素，排序前后其相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点的核心性质为先进先出，即先进入队列的元素先出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置以实现快速的数据存储和检索",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一特点",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "归并排序是将一个序列分成两个子序列分别递归排序后再合并成一个有序序列的排序算法",
    "head": "归并排序",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，用于表示该边的某种属性或代价",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定规则依次访问二叉树中的每个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，在排序前后它们的相对顺序保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "满二叉树的核心性质是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "加权图是一种图结构其中每条边都被赋予一个权重用于表示该边的某种代价或属性等特征",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相等的元素，在排序前后它们的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "映射的核心特征是对于集合A中的每一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树的核心性质是除最后一层无任何子节点外，每一层上的所有节点都有两个子节点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，是独立于计算机的",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素之间的相对次序从而实现排序的一种排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "映射的核心特征是对于集合A中的每一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树的核心特征是除最后一层无任何子节点外，每一层上的所有节点都有两个子节点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "递归基础是递归算法中最简单的情况，它直接返回一个已知值而不进行进一步的递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "满二叉树的核心性质是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树的核心特征是除最后一层无任何子节点外，每一层上的所有节点都有两个子节点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据",
    "head": "数组",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "数据的逻辑结构的特点是描述数据元素之间逻辑关系，与数据的存储无关且独立于计算机",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "线性表是零个或多个数据元素的有限序列且该序列中的元素之间存在着一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "满二叉树的核心特征是除最后一层无任何子节点外，每一层上的所有节点都有两个子节点",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一特点",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度的核心特征是从树的根节点到最远叶子节点所经过的最长路径上的边数或节点数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，都有一个链表来存储与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数据序列调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "树的节点是树结构中的基本组成部分，具有一个数据元素以及零个或多个指向子节点的指针",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，用一个单链表来存储与该顶点相邻接的所有顶点",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "递归基础是递归算法中最简单情况，是无需再次递归调用自身就能直接给出结果的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "队列的核心特征是先进先出，即先进入队列的元素会先被取出，后进入队列的元素后被取出",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "无向图是一种图结构其中任意两个顶点之间的边没有方向且顶点集和边集共同构成该图结构",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "数据结构中稳定性是指在排序过程中，相等元素之间的相对顺序在排序前后保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "5",
    "tail_offset": "11"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其核心性质为元素按照后进先出的顺序进行入栈和出栈操作",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "33",
    "tail_offset": "36"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而将输入序列转换为有序序列的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "在树形数据结构中父节点是其直接子节点的上一级节点且拥有指向这些子节点的引用或链接",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "8",
    "tail_offset": "15"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数据序列调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "平衡二叉树左右两个子树的高度差的绝对值不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "映射的核心特征是对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回路的核心性质是从回路中任一顶点出发，沿回路的边可以遍历回该顶点且经过的边不重复",
    "head": "回路",
    "tail": "回路",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其核心性质为元素按照后进先出的顺序进行入栈和出栈操作",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "33",
    "tail_offset": "36"
  },
  {
    "sentence": "二叉搜索树的特点是每个节点的值大于其左子树所有节点的值且小于其右子树所有节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过对元素之间进行比较来确定元素的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "平衡二叉树左右两个子树的高度差的绝对值不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "循环链表的核心特征是表中最后一个节点的指针域指向头节点，从而使整个链表形成一个环",
    "head": "循环链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定规则依次访问二叉树中的每一个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "简单排序是对数据序列通过比较和交换元素位置等操作逐步将其排列成有序序列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过该指针可间接访问其所指向的变量",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "树的度是指一棵树中，所有结点的度的最大值，其中结点的度是指该结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "映射的核心特征是对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是一种基于元素之间比较操作来确定元素相对顺序从而对数据进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "队列的核心特征是先进先出，即先进入队列的元素会先被取出，后进入队列的元素后被取出",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来将无序数据序列逐步调整为有序序列的排序算法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "二叉搜索树中，若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其核心性质为元素按照后进先出的顺序进行入栈和出栈操作",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "33",
    "tail_offset": "36"
  },
  {
    "sentence": "在树形数据结构中父节点是指其直接有子节点与之相连且处于比子节点更高层次关系的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "8",
    "tail_offset": "17"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行某一计算过程以逼近问题解的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度其核心特征为树中各结点度的最大值代表了该树的度",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "14",
    "tail_offset": "37"
  },
  {
    "sentence": "在数据结构中稳定性是指在排序算法执行过程中，相等元素的相对位置在排序前后保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来将无序数据序列逐步调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间抽象化的相互关系，它不考虑数据在计算机中的存储方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "在数据结构中，稳定性是指在排序算法中，相等元素在排序前后的相对顺序保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "7",
    "tail_offset": "13"
  },
  {
    "sentence": "父节点具有比其子节点更高层级的特点，是子节点在数据结构层次关系中直接的上一层节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是一对一的，存在一对多、多对一或多对多的关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "队列的核心特征是先进先出，即先进入队列的元素会先被取出，后进入队列的元素后被取出",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度的核心特征是从树的根节点开始，沿着最长路径到最远叶子节点所经过的边的数量",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "递归基础具有明确的终止条件且在该条件下能直接给出简单明确的结果而无需再次递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件且可直接得出结果而无需再次递归调用的初始情况定义",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数据序列调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序序列逐步调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行某一运算步骤以逼近问题解的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来将无序数据序列逐步调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定规则依次访问二叉树中的每一个节点且仅访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "平衡二叉树左右两个子树的高度差的绝对值不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数据序列调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，都用一个链表来存储与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉搜索树中每个节点的左子树所有节点值小于该节点值且右子树所有节点值大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "循环链表的核心特征是表中最后一个节点的指针域指向头节点，从而使整个链表形成一个环",
    "head": "循环链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构包括根节点且每个节点的子树有左右之分",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "比较排序是通过对元素之间进行比较来确定元素间的相对次序从而实现排序的一种排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元，具有一个数据元素以及零个或多个指向子节点的指针",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "线性表是一种由同类型数据元素构成的有限序列，其中数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过该指针可间接访问其所指向的变量",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "父节点是在树形数据结构中，其直接有子节点与之相连且处于比子节点更高层次位置的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问其所指向的变量",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值权重，用于表示边的某种性质或代价等",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点的核心性质是其与父节点存在特定关联关系且是树形结构中父节点下直接相连的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "指针的核心性质是其存储了变量的内存地址，通过该地址可以直接访问和操作所指向的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过该指针可间接访问其所指向的变量",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "映射的核心特征是对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是一种基于元素之间比较来确定元素相对次序从而对元素序列进行排序的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "树的度是指一棵树中，所有结点的度的最大值，其中结点的度是指该结点拥有的子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "映射的核心特征是对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素间相对次序从而将元素序列排成有序序列的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "递归基础是递归算法中最简单情况，通常是无需再次递归调用就能直接得出结果的终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "满二叉树是深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件可直接得到结果而无需再次递归调用自身的初始情况定义",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "叶子节点的核心特征是没有子节点，它处于树状结构的末端，是数据结构中不再有分支的节点",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过该指针可以间接访问其所指向的变量",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别进行排序后再合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "递归基础是递归算法中最简单情况，在此情况下递归函数直接返回一个确定值而不再调用自身",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心性质为：对于最大堆，父节点的值大于或等于其子节点的值",
    "head": "堆",
    "tail": "父节点",
    "head_offset": "23",
    "tail_offset": "25"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性通过特定路径在树中搜索特定元素以确定其是否存在及位置",
    "head": "查找",
    "tail": "路径",
    "head_offset": "2",
    "tail_offset": "19"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归排序后再合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "无向图是由顶点集和边集组成的图，其中边集是顶点集的无序对集合且每条边都连接两个顶点",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "指针的核心性质是其存储了变量的内存地址，通过该地址能够对所指向的变量进行访问和操作",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其特点为：除最后一层外，每一层上的节点数均达到最大值",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式包括数据元素的存储表示及其逻辑关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "在树形结构中，父节点是直接有子节点连接在其下方，且自身不是任何其他节点子节点的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "7",
    "tail_offset": "14"
  },
  {
    "sentence": "回路是在图中从一个顶点出发，沿着边连续移动，最终回到起始顶点且经过的边不重复的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中当问题规模达到最小时可直接得出结果而无需再次递归调用的特定情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括数据元素的表示和关系的表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素在排序结果中的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "非线性结构的核心性质是结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过该指针可以间接访问其所指向的变量",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "树的节点是包含数据元素及若干指向子树的分支且具有层次关系从而构成树形结构的基本单元",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "子节点是树结构中直接被父节点所连接的节点，具有与父节点存在直接连接关系这一核心性质",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "无向图是一种由顶点集合及顶点间的边集合组成的图结构其中边是没有方向的顶点之间的连接",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "非线性结构的核心性质是结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的有限序列并存储在一块连续的内存空间中",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "交换排序是通过比较元素并交换不满足顺序要求的元素位置来对序列进行排序的一种排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数体现出的树的层次数量特征",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "队列的特点是先进先出即元素按照进入队列的先后顺序依次从队列头部取出，队尾插入新元素",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的节点是包含数据以及指向子节点的链接的基本数据单元用于构成具有层次关系的树形结构",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行特定计算步骤逐步逼近问题解的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每一个节点且每个节点仅被访问一次的操作",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是一种变量其值为内存中另一个变量或对象的地址用于间接访问和操作该内存位置的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "递归基础是递归函数中当输入满足特定简单条件时直接返回确定值而不再进行递归调用的情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其特点为：除最后一层外，每一层上的节点数均达到最大值",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序的核心性质是其通过元素之间的比较来确定元素的相对顺序从而对元素序列进行排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别进行排序后再合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括数据元素的表示和关系的表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是由顶点集和边集组成其中边集是顶点的无序对集合顶点之间通过边相连且边没有方向",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而将给定元素序列排成有序序列的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "堆的核心性质是父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其所有子节点的值",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "7",
    "tail_offset": "36"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而将给定序列按升序或降序排列的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "二叉搜索树的核心特征是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归排序后再合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据以实现快速查找",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "根节点是树结构中的起始节点，它没有父节点，是整个树结构的入口点且具有独一无二的地位",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长简单路径上的节点数体现出的树的一种特性",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行特定计算步骤逐步逼近问题解的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据元素",
    "head": "数组",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "比较排序是一种基于元素间比较来确定元素相对次序从而实现对一组元素进行排序的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素在排序序列中的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素间相对次序从而将输入序列转化为有序序列的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "交换排序是一种通过比较元素并交换不满足顺序要求的元素位置来对数据序列进行排序的方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素在排序序列中的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针的核心性质是其存储的是变量的内存地址，通过该地址可以直接访问和操作所指向的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归排序后再合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是基于元素间的比较来确定元素之间的相对次序从而对元素序列进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括数据元素的表示和关系的表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "映射具有对于集合A中的任意一个元素在集合B中都有唯一确定的元素与之对应这一核心性质",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据类型是对数据的一种分类，它规定了数据所具有的值的集合以及可以对这些值执行的操作",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括数据元素的表示和关系的表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到一个特定的索引位置来存储和检索数据元素",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "简单排序是对数据序列通过比较元素大小并进行交换等操作，将其按特定顺序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "树的高度的核心特征是从树的根节点到最远叶子节点之间所经过的最长路径上的边数或节点数",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的逻辑结构的特点是描述数据元素之间抽象的逻辑关系而不考虑其在计算机中的存储方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是一对一的线性关系，存在一对多、多对多等复杂关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过该指针可以访问和操作其所指向的变量",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过对元素之间进行比较来确定元素之间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而将给定元素序列排列成有序序列的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "比较排序是基于元素间比较操作来确定元素间相对次序从而实现对数据序列进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "双向链表是一种每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针的数据结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过对元素之间进行比较来确定元素之间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是一对一的，可能存在一对多、多对一或多对多的关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数或节点数所体现出的树的深度特征",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是一种排序算法，其通过比较元素之间的大小关系来确定元素在排序序列中的最终位置",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树遍历的核心性质是按照某种特定顺序访问二叉树中的每一个节点且每个节点仅被访问一次",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树的节点是树结构中的基本单元，包含数据以及指向子节点的指针或引用从而构成树形层次关系",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "指针的核心性质是其存储的是变量的内存地址，通过该地址能够直接访问和操作所指向变量的值",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机的存储结构",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点的特殊节点，它处于树的起始位置，是树中所有其他节点的祖先",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "简单排序是对数据序列通过比较元素大小并交换位置等方式逐步将其按特定顺序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数或节点数所代表的树的垂直深度度量",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "比较排序是一种基于元素之间比较操作来确定元素相对顺序从而对数据序列进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "在数据结构中，稳定性是指对于具有相同关键字的元素，排序前后这些元素的相对位置保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "7",
    "tail_offset": "25"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储表示及其逻辑关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "树的度的核心特征是树中所有结点的度的最大值，它反映了树中各结点拥有子树数量的最多情况",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "树的高度是从根节点开始，沿最长简单路径到最远叶子节点所经过的边数加1（空树高度为0）",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址用于指向该变量从而实现对该变量的间接访问",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行特定计算步骤以逐步逼近问题解的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "在数据结构中稳定性是指在排序算法执行过程中，相等元素之间的相对顺序在排序前后保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "稳定性是指在数据结构中，若存在两个相等的元素，在排序前后它们的相对位置保持不变的性质",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置从而完成排序的一种简单直观的排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其特点包括：除最后一层外，每一层上的节点数均达到最大值",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，用于表示边的某种属性或代价等",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是一种图结构其中任意两个顶点之间的边没有方向且顶点集合与边集合共同构成图的结构",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过对元素之间进行比较来确定元素之间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度，即树中一个结点的子树个数的最大值为树的度这一特征",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "14",
    "tail_offset": "26"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和修改所指向变量的值",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数据序列逐步调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "双向链表是一种每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针的数据结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储表示及其逻辑关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "栈的核心特征是具有后进先出的特点即最后进入栈的元素最先出栈而最先进入栈的元素最后出栈",
    "head": "出栈",
    "tail": "出栈",
    "head_offset": "27",
    "tail_offset": "40"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过比较元素之间的大小关系来确定元素的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的查找是在树这种数据结构中基于树的特性从节点集合里按特定规则找到目标元素的操作过程",
    "head": "查找",
    "tail": "树",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点是包含数据及指向子节点的链接的基本数据结构单元，是构成树型数据结构的基础元素",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素之间的相对次序从而对数据序列进行排序的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "递归基础是递归定义中确定的最基本情况，具有无需通过递归调用即可直接确定结果的核心性质",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和修改所指向变量的值",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个结点的二叉树，其中每一层上的结点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "集合的核心特征包括确定性，即对于一个给定的集合，任何一个元素是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储表示及其逻辑关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数据序列逐步转换为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "递归基础的核心性质是存在直接可解的最简情况，在此基础上通过递归关系逐步解决更复杂问题",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是一对一的，存在一对多、多对一或多对多等复杂关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "指针的核心性质是其存储的是内存地址，通过该地址可以访问和操作存储在对应内存位置的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置以实现快速的数据查找插入和删除操作",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "交换排序是通过比较序列中元素并交换逆序元素位置，将无序序列逐步调整为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中数据元素之间存在着一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其核心特征包括：是一个方阵，行数和列数与图的顶点数相同",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件可直接得出结果无需再次递归调用的初始情况或简单条件定义",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树的遍历是按照某种规则依次访问二叉树中的每个节点，使得每个节点被访问且仅被访问一次",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "比较排序的核心特征是通过比较元素之间的大小关系来确定元素在排序序列中的位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "在树形结构中，若存在一个节点，它有一个或多个子节点，那么这个节点就是这些子节点的父节点",
    "head": "子节点",
    "tail": "子节点",
    "head_offset": "22",
    "tail_offset": "36"
  },
  {
    "sentence": "有向图是一种图结构，其中边具有方向，即从一个顶点指向另一个顶点，顶点之间的连接是单向的",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据类型是对数据的一种分类方式，它定义了数据所具有的值的集合以及可以对这些值执行的操作",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且唯一的起始节点，它位于树的顶端，是树整体结构的核心起始点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，用于表示该边的某种属性或代价等",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "非线性结构的核心性质是在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性通过特定遍历方式从根节点出发沿着分支路径逐步查找目标元素",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "19"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素在有序序列中的相对位置从而实现排序的一种排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性通过特定的遍历或比较方式在树中定位特定元素以获取所需信息",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "无向图的核心特征是由顶点集合和边集合组成，其中边是没有方向的，即顶点之间的连接是双向的",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数体现出的树在纵向层次上的特性",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针的核心性质是其存储的是变量的内存地址，通过该地址可以访问和操作对应变量所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机存储空间中的存储方式包括数据元素的存储表示及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "27"
  },
  {
    "sentence": "递归基础的特点的核心特征是存在无需再次递归调用自身就能直接给出结果的终止条件或最简情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "交换排序是一种通过比较元素并交换不满足顺序要求的元素位置来对数据序列进行排序的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "树的节点是包含数据以及指向子节点的链接的基本数据单元，是构成树型数据结构的基础组成部分",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "比较排序的核心性质是其排序过程仅通过元素间的比较操作来确定元素间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序表是一种线性表，其核心特征包括：它的逻辑结构是线性的，元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "逻辑结构",
    "head_offset": "6",
    "tail_offset": "20"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "非线性结构的核心性质是在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点且处于树的起始位置是树中所有其他节点的祖先",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间抽象化的相互关系，这种关系不考虑数据在计算机中的存储方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置以实现快速的数据插入删除和查找操作",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "回路是数据结构中从一个顶点出发，沿某条路径遍历，最后又回到该顶点的路径所构成的结构特点",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的集合，这些元素在内存中占用连续的存储单元",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据的逻辑结构的特点是描述数据元素之间逻辑关系而不考虑其在计算机中的存储方式及实现细节",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每一个节点且每个节点仅被访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "栈的特点的核心性质是后进先出即最后进入栈的元素最先被弹出且只能在栈顶进行插入和删除操作",
    "head": "插入",
    "tail": "删除",
    "head_offset": "36",
    "tail_offset": "39"
  },
  {
    "sentence": "简单排序是对数据序列通过比较元素大小并交换位置等方式，将其按特定顺序排列的一种排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "树的度是指一棵树中最大的节点度即树中各节点度的最大值其中节点的度是该节点拥有子树的数目",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和操作其所指向的变量",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "比较排序的核心特征是通过比较元素之间的大小关系来确定元素在排序序列中的位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件且无需再次递归调用、可直接给出结果的初始情况或边界条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "邻接表的核心特征是用链表来表示图，对于图中的每个顶点，都有一个链表来存储其所有邻接顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是由一个顶点指向另一个顶点的有序对",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉树的遍历是按照某种规则依次访问二叉树中的每个节点，使得每个节点被访问且仅被访问一次",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "简单排序是对给定数据序列通过比较和交换元素位置等方式，使其按特定顺序排列的一种排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二叉树是一种树形结构，每个节点最多有两个子节点，其核心性质包括：每个节点至多有两棵子树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "映射具有对于集合 A 中的任意一个元素在集合 B 中都有唯一确定的元素与之对应这一特点",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称其具有特定的取值范围和行为特点",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点是包含数据元素及若干指向其子树的分支，用于构成树形结构的数据结构的基本组成部分",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问所指向的变量存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "迭代法的核心特征是基于初始值，按照固定的迭代公式不断重复计算，使得结果逐步逼近问题的解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "比较排序的核心特征是其排序过程主要基于元素之间的比较操作来确定元素的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心性质是通过比较元素并交换位置，逐步将无序序列转变为有序序列",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的度的核心特征是树中所有结点的度的最大值即树内各结点的度的取值范围中的最大值就是树的度",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "指针的核心性质是其存储的是变量的内存地址，通过该地址可以对所指向的变量进行间接访问和操作",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，并且可以通过下标来访问和修改元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而将给定元素序列重新排列成有序序列的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的值大于其左子树所有节点的值且小于其右子树所有节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是一对一的，而是存在一对多、多对一或多对多的复杂关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "简单排序是对数据元素序列进行比较和交换等操作，按照特定顺序将元素排列成有序序列的排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而将给定元素序列重新排列成有序序列的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该变量所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行某一运算过程以逼近问题解的数值计算方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "稳定性的核心性质是对于已排序的输入序列，排序算法在排序过程中能保持相等元素的相对顺序不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，且从根节点出发可以遍历到树中的其他所有节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "在图论中回路是指一条路径其起点和终点是同一个顶点且路径上除起点和终点外的其他顶点均不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "10"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是从一个顶点指向另一个顶点的有序对",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "递归基础是递归算法中当问题规模减小到某一特定值时可直接得出结果而无需进一步递归调用的情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该地址所指向的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "递归基础是递归算法中最简单情况，即不依赖递归调用自身就能直接得出结果的终止条件或初始情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "循环链表的核心特征是链表中最后一个节点的指针域指向头节点，从而使整个链表形成一个环形结构",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是基于元素之间比较来确定其相对次序从而将给定元素序列重新排列成有序序列的排序方式",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "有向图的核心性质是由顶点和有向边组成，边具有方向，且从一个顶点到另一个顶点的路径是有向的",
    "head": "有向图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，根节点所在层为第1层，直到最远叶节点所经过的层数",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图是一种数据结构，由顶点集合以及顶点之间的边的集合组成，顶点之间的边描述了顶点之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "12",
    "tail_offset": "23"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素间相对次序从而将给定元素序列按升序或降序排列的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而将给定元素序列重新排列成有序序列的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "交换排序是通过比较序列中元素并交换逆序对元素位置来逐步将无序序列转变为有序序列的排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "树的节点是包含数据以及指向其子节点的链接的基本数据单元是树这种数据结构中构成树的各个元素",
    "head": "树的节点",
    "tail": "树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "比较排序是基于元素间比较操作来确定元素之间的相对次序从而对数据序列进行排序的一种排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是一对一的，而是存在一对多、多对一或多对多的复杂关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "满二叉树是一棵二叉树且其每一层的节点数都达到最大值，即除叶子节点外每个节点都有两个子节点",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "子节点是树结构或图结构等数据结构中，与某个特定节点（父节点）直接相连且处于较低层次的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "无向图是由顶点集和边集组成，其中边集是顶点集的无序对集合，顶点之间通过边相连且边没有方向",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机中的存储表示及其存储方式，包括数据元素的表示和关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "在树形结构中，根节点是没有前驱节点且唯一的节点，它处于树的顶端位置，是整个树结构的起始点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "7",
    "tail_offset": "13"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是由一个顶点指向另一个顶点的有序对",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质包括：若图中有n个顶点，则邻接矩阵是n阶方阵",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "在树形结构中，根节点是没有前驱节点且位于树的顶端、作为树中所有其他节点的起始点的特殊节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "7",
    "tail_offset": "13"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权值，用于表示与边相关的某种度量或属性",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表的核心性质是最后一个节点的指针指向头节点从而形成一个环形结构使得链表可以循环遍历",
    "head": "循环链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的节点是树中的数据元素及指向其子树的分支所构成的基本单元包含数据项以及指向子节点的指针",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该地址所对应的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "满二叉树是一种二叉树，其中每个节点要么有两个子节点，要么没有子节点，且叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "指针是一种变量其值为内存中另一个变量或对象的地址通过该指针可以间接访问其所指向的内存位置",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值代表与这条边相关的某种数量指标",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心性质是通过比较元素并交换位置，逐步将无序序列转变为有序序列",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据类型的定义的核心性质包括具有一组值、定义了一组操作以及规定了这些操作所施加的值的集合",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "二叉搜索树的核心性质是每个节点的值大于其左子树中所有节点的值且小于其右子树中所有节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "二叉树的核心性质是在任意一棵二叉树中，度为0的结点（即叶子结点）总是比度为2的结点多一个",
    "head": "二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心性质是通过比较元素并交换位置，将无序序列逐步转换为有序序列",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "加权图是一种图结构，其中图的每条边都被赋予一个数值作为权值，用于表示该边的某种属性或代价",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据以实现高效的查找操作",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机存储器中的存储方式包括数据元素的存储表示及其逻辑关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "26"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心性质是通过比较元素并交换位置，将无序序列逐步转换为有序序列",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "映射是一种特殊的二元关系，对于集合A中的每一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "循环链表的核心性质是最后一个节点的指针指向头节点从而形成一个环形结构使得链表能够循环遍历",
    "head": "循环链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机内存或存储设备中的存储方式包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "30"
  },
  {
    "sentence": "在数据结构中，稳定性是指对于相等的元素，排序算法在排序前后这些相等元素的相对位置保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "树的节点是包含数据元素以及指向其子节点的若干分支且具有层次关系的树状结构中的基本组成单元",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心性质是通过比较元素并交换位置来逐步将无序序列转变为有序序列",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表的核心性质是最后一个节点的指针指向头节点从而形成一个环形结构使得链表可以循环遍历",
    "head": "循环链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，用于表示与边相关的某种度量或代价",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相同输入，排序算法在排序前后相同元素的相对位置保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该地址所对应的变量",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "栈的核心特征是后进先出即最后进入栈的元素最先被弹出栈，且栈只允许在一端进行插入和删除操作",
    "head": "出栈",
    "tail": "栈",
    "head_offset": "24",
    "tail_offset": "28"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是从一个顶点指向另一个顶点的有序对",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权值，用于表示与边相关的某种数量或度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合组成的图结构其中边是没有方向的顶点之间的连接关系",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "比较排序是一种排序算法，其核心性质是通过元素间的比较操作来确定元素间的相对次序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机内存或存储设备中的存储方式，包括数据元素的存储及其关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "31"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有唯一父节点且是其分支所指向的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "映射是一种特殊的二元关系，对于集合A中的任意一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "比较排序的核心特征是通过比较元素之间的大小关系来确定元素在排序序列中的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "树的节点具有唯一的根节点且每个非根节点有且仅有一个父节点同时每个节点可以有零个或多个子节点",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "回路的核心特征是其起点和终点为同一节点且存在一条不重复经过相同节点的路径可从起点回到该起点",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "比较排序的核心特征是通过比较元素之间的大小关系来确定元素在排序序列中的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "比较排序的核心特征是通过比较元素之间的大小关系来确定元素在排序序列中的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "平衡二叉树的核心特征是每个节点的左右子树高度差的绝对值不超过1且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回路的核心性质是从回路中任意一点出发，沿回路的边遍历，最终能回到出发点且所经过的边互不重复",
    "head": "回路",
    "tail": "回路",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应，这就是映射定义的核心特征",
    "head": "集合",
    "tail": "集合",
    "head_offset": "2",
    "tail_offset": "15"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其操作主要集中在栈顶，元素按照后进先出的顺序进行入栈和出栈操作",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "38",
    "tail_offset": "41"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据从而实现高效的查找操作",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "链表是一种通过指针将若干个节点按顺序连接起来的数据结构每个节点包含数据和指向下一节点的指针",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过每次将查找区间缩小一半的方式，来快速定位目标元素的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素之间的相对次序从而将给定序列重新排列成有序序列的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "数组是具有相同数据类型的一组数据元素的集合，这些元素在内存中按顺序存储，可通过下标进行访问",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "指针的核心性质是其存储的是变量的内存地址，通过该地址可以直接访问和操作对应变量所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件从而直接给出结果而无需再次递归调用自身的初始情况或边界条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "回路的核心性质是从回路中任一顶点出发，沿回路的边遍历，最终能回到该起始顶点且经过的边不重复",
    "head": "回路",
    "tail": "回路",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点是树结构中的基本单元包含数据元素且有零个或多个子节点每个非根节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列的合适位置，通过逐步构建有序序列来完成排序的算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "父节点是树状结构中位于上一层级且与子节点存在直接关联关系能对其进行层级标识和关系界定的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "映射是一种特殊的二元关系，对于集合A中的任意一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "比较排序是一种排序算法，其特点是通过比较元素之间的大小关系来确定元素的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其中每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "根节点是树结构中没有父节点且处于树的最顶层的节点是树结构中没有父节点且处于树的最顶层的节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组都被排序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "数据类型具有各自不同的特点包括取值范围、存储方式、操作集合及语义含义等方面的特定性质和规定",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "平衡二叉树的核心特征是每个节点的左右子树高度差的绝对值不超过1且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素之间的相对次序从而将给定序列按一定顺序排列的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "穷举法的核心性质是对问题的所有可能解逐一进行尝试，直到找到满足条件的解或遍历完所有可能情况",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "父节点是在树形结构中，其直接拥有一个或多个子节点，处于比子节点更高层次且具有相对关系的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "比较排序是一种排序算法，其核心性质是通过元素之间的比较操作来确定元素的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "比较排序的核心特征是通过比较元素之间的大小关系来确定元素在排序序列中的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "回路的核心性质是从回路中任意一点出发，沿着回路的边行进，最终能回到出发点且所经过的边不重复",
    "head": "回路",
    "tail": "回路",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "递归基础的核心性质是存在直接可解的最简情况，在此情况下递归过程无需再次调用自身即可得出结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边构成的图，其边具有方向性，即从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点下方的节点，具有与父节点直接关联且处于父节点下方层次的特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用某种迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "归并排序的核心性质是将数组分成两个子数组分别排序，然后将排序好的子数组合并成一个有序的数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "存储结构的核心特征是数据元素及其关系在计算机存储器中的表示方式以及数据元素间关系的实现方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "递归基础是递归函数中满足特定条件使得函数直接返回一个确定值而不再进行递归调用的终止条件定义",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机存储器中的存储方式包括顺序存储链式存储索引存储和散列存储等",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合组成的图结构其中边是没有方向的顶点之间的连接关系",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "比较排序的核心特征是排序过程主要通过比较元素之间的大小关系来确定元素的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "映射是一种特殊的二元关系，对于集合A中的任意一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，分别为左子节点和右子节点，并且二叉树可以为空树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有序集合，具有固定的大小，其元素通过下标进行唯一标识和访问",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "对于数据结构中的稳定性，若在排序前后两个相等的元素的相对位置保持不变则该排序算法具有稳定性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "8",
    "tail_offset": "14"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置，通过逐步构建有序序列来完成排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数，它体现了树在纵向的层次数量特征",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树的遍历是按照某种规则依次访问二叉树中的每个节点使得每个节点均被访问一次且仅被访问一次",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "数组是一种有序数据集合，其中的元素具有相同的数据类型，并且可以通过下标来访问和修改这些元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点即度最大为2且二叉树的子树有左右之分次序不能颠倒",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和修改其所指向的变量的值",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "映射是一种特殊的二元关系，对于集合A中的任意一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数组是一种有序数据集合，其中的元素具有相同的数据类型，并且可以通过下标来唯一地访问每个元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数组是一种有序数据集合，其中的元素具有相同的数据类型，并且可以通过下标来访问和修改这些元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别递归排序后再将有序子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "稳定性是指在数据结构中，若两个相等的数据元素在排序前后相对位置保持不变则该数据结构具有稳定性",
    "head": "稳定性",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素之间的相对次序从而将给定元素序列排成有序序列的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过比较元素之间的大小关系来确定元素在有序序列中的位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作，通过特定规则将无序数据逐步调整为有序状态的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "数组的核心性质是具有固定大小且元素存储在连续内存位置，通过下标可以直接访问和修改数组中的元素",
    "head": "数组",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "平衡二叉树的核心特征是其每个节点的左右子树高度差的绝对值不超过1且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素之间的相对次序从而将给定序列按升序或降序排列的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过比较元素之间的大小关系来确定元素在有序序列中的位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "指针具有能直接访问内存地址、可灵活操作内存数据、能高效传递数据地址、可实现动态内存管理等特点",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的核心特征是具有一个根节点，并且除根节点外的每个节点都有且仅有一个父节点，同时树中没有回路",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "11",
    "tail_offset": "18"
  },
  {
    "sentence": "简单排序是对数据序列通过比较和交换等操作，按照特定规则将元素重新排列以达到有序状态的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质包括：若图中有n个顶点，则邻接矩阵是一个n阶方阵",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过比较元素之间的大小关系来确定元素在排序序列中的位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，其中顶点间的关系集合描述了顶点之间的连接情况",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，并且可以通过下标来访问和操作这些元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，所有其他节点都直接或间接连接到它",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，并且可以通过下标来访问和修改这些元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点路径上的边数或节点数，反映了树的纵向延伸程度及层次结构复杂程度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "非线性结构的特点的核心性质是在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到存储位置，以实现快速的数据查找、插入和删除操作",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的值大于其左子树中所有节点的值且小于其右子树中所有节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的查找的特点的核心性质是通过特定的方式在树结构中进行元素查找以确定其是否存在或获取相关信息",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "29"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，所有其他节点都直接或间接连接到它",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址处存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "递归基础是递归算法中最简单的情况，是无需再次递归调用自身就能直接得出结果的初始条件或终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉树的每个节点最多有两个子节点，其特点包括：非空二叉树的第i层上至多有2^(i-1)个节点",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "二叉树每个节点最多有两棵子树，并且二叉树的子树有左右之分，其次序不能颠倒，且二叉树可以为空树",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "在图论中回路是指一条从某个顶点出发又回到该顶点的路径且路径中除起点和终点外其余顶点不重复经过",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "24"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "数据的物理结构的核心性质包括数据元素的存储方式以及数据元素之间的逻辑关系在计算机中的表示形式",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，反映数据元素之间的关联方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "回路是在图中从某一顶点出发，沿着边连续移动，最终回到起始顶点且路径中各顶点和边都不重复的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数或节点数所体现出的树的一种结构特征度量",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树是一种树型结构，它的每个节点最多有两个子节点，分别称为左子节点和右子节点，并且可以为空",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "比较排序是一种基于元素间比较来确定元素相对次序从而将给定元素序列重新排列成有序序列的排序方法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素在排序序列中的相对位置从而对元素序列进行排序的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别进行排序再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过从一个初始估计出发寻找一系列近似解来求解问题的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "数据的逻辑结构的定义的核心特征是描述数据元素之间的逻辑关系且独立于数据的存储结构与数据的运算",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "18"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它包括数据元素的表示和关系的表示两个方面",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "归并排序的核心性质是将一个数组分成两个子数组分别排序，再将排序好的子数组合并成一个有序的数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径，在有向图中任意两个顶点之间都存在有向路径的图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点是包含数据及指向子节点的指针的基本数据结构单元用于构成树形结构以表示数据间的层次关系",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值以表示从一个顶点到另一个顶点的某种代价或度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "简单排序是对数据序列进行排序的一种基本方法，它通过比较和交换元素位置逐步将序列整理成有序状态",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过比较元素之间的大小关系来确定元素在有序序列中的位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "迭代法的特点是通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题的精确解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "数据类型的特点是其具有特定的取值范围、存储方式、操作集合以及语义含义等方面所表现出的独特性质",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "二叉搜索树的核心性质是左子树所有节点的值均小于根节点的值且右子树所有节点的值均大于根节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其特点的核心特征包括：是一个方阵，行数和列数与图的顶点数相同",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "递归基础的特点的核心特征是存在直接可解的最简情况，无需再次递归调用，能为递归过程提供终止条件",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，分别称为左子节点和右子节点，并且二叉树可以为空树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过比较元素之间的大小关系来确定元素在有序序列中的位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "简单排序是对一组数据按照特定规则依次比较元素大小并进行交换等操作以实现数据有序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，是整个树结构的入口点，通过它可以访问到树中的其他节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "队列的核心特征是先进先出，即先进入队列的元素会先被取出，新元素从队列末尾进入，从队列头部取出",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "加权图是一种图结构，其中图的每条边都被赋予一个数值作为权值，用于表示与边相关的某种度量或代价",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的核心性质是左子树所有节点的值均小于根节点的值且右子树所有节点的值均大于根节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的地址，通过它可以间接访问和操作该内存位置处的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它包括数据元素的表示和关系的表示两方面内容",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其每个节点的左右子树高度差的绝对值不超过1且左右子树均为平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "在图论中回路是指从图中某一顶点出发，沿着边经过若干顶点后又回到该起始顶点的路径且路径中边不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "37"
  },
  {
    "sentence": "父节点具有比子节点更高的层级关系且拥有子节点，是子节点的上一级节点并能对其进行管理或关联等操作",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，仅考虑数据元素之间的关联方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "满二叉树是一种二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "迭代法的核心性质是通过从一个初始估计值开始，利用某种迭代公式不断重复计算，逐步逼近问题的精确解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "加权图是一种图结构其中每条边都被赋予一个数值作为权重用于表示边的某种代价、距离、容量等相关属性",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和操作该内存地址所存储的数据",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "比较排序是一种排序算法，其核心性质是通过比较元素之间的大小关系来确定元素的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "父节点具有比子节点更高一层的层级关系且在数据结构中处于直接连接子节点并对其进行管理或关联的位置",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并将较大元素逐步交换到右侧，重复此过程直到整个数组有序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "子节点是树结构中直接连接在某个父节点之下的节点，具有直接与父节点相连且处于父节点下一层级的特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，描述了数据元素之间的关联方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "比较排序是通过比较元素之间的大小关系来确定元素在排序结果中的相对位置从而实现排序的一种排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心特征包括：是一个二维数组，行数和列数等于图中顶点的个数",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "满二叉树是一种二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "满二叉树是一棵二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "在图论中，回路是指从图中某一顶点出发，沿着边连续移动，经过若干个不同顶点后又回到起始顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "5",
    "tail_offset": "45"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储表示，包括数据元素的存储方式以及数据元素之间关系的存储方式",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "满二叉树是一种二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点具有唯一的根节点，除根节点外每个节点有且仅有一个父节点，每个节点可以有零个或多个子节点",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "满二叉树是一种二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回路的核心性质是从回路中任一顶点出发，沿回路的边可以访问到回路中的每一个顶点且最终回到起始顶点",
    "head": "回路",
    "tail": "回路",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，使得集合A中的每一个元素在集合B中都有唯一的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，仅考虑数据元素之间的关联方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别进行排序后再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别递归排序后再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，仅考虑数据元素之间的关联方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "对于集合A中的任意一个元素，在集合B中都有唯一确定的一个元素与之对应，这就是映射定义的核心特征",
    "head": "集合",
    "tail": "集合",
    "head_offset": "2",
    "tail_offset": "15"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "平衡二叉树的特点是树上任一节点的左子树和右子树的高度差不超过1且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "图的边是连接图中两个顶点的线段或弧，具有方向或无方向等特点，其集合描述了图中顶点之间的连接关系",
    "head": "图的边",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式不断重复计算以逐步逼近问题精确解的数据处理方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "队列的核心特征是先进先出即先进入队列的元素先离开，并且它有队头和队尾，元素从队尾进入从队头离开",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，仅考虑数据元素之间的抽象关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "树的查找是在给定的树结构中，依据特定的查找规则确定某个特定元素是否存在以及其所在位置的操作过程",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "19"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其每个节点的左右子树高度差的绝对值不超过1且左右子树均为平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别进行排序，再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "集合具有确定性、互异性和无序性，其中确定性指给定一个集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "栈的核心特征是后进先出即最后进入栈的元素最先被弹出，且操作主要集中在栈顶进行包括入栈和出栈操作",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "40",
    "tail_offset": "43"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机存储器中的表示方式以及它们之间的相互关联和组织形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数或节点数所体现出的树的垂直延伸程度的特性",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二叉树每个节点最多有两棵子树，并且二叉树的子树有左右之分，其次序不能颠倒，而且二叉树可以为空树",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，用于表示该边的某种代价、距离、容量等相关度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "平衡二叉树的核心特征是其每个节点的左右子树高度差的绝对值不超过1并且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并将较大元素逐步交换到右侧，重复此过程直到整个数组有序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，从初始值出发通过重复执行相同计算步骤逐步逼近问题解的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间抽象化的相互关系，它与数据的存储无关，仅考虑数据元素间的逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有前驱节点，它是整个树的入口，通过它可以遍历和访问树中的其他节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别进行排序后再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "平衡二叉树的核心特征是其左右两个子树的高度差的绝对值不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置，从而逐步完成对整个数据序列排序的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，从一个初始估计出发，通过重复计算逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "平衡二叉树的每个节点的左子树和右子树的高度差的绝对值不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过该指针可以访问和操作其所指向的内存位置的数据",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "比较排序是一种排序算法，其核心特征是通过比较元素之间的大小关系来确定元素的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "简单排序是对数据元素序列通过比较和交换等操作，将其按特定顺序（如升序或降序）排列的一种排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的查找的核心性质是若树中存在关键字值为K的结点，则该结点一定在从根结点到某个叶子结点的路径上",
    "head": "查找",
    "tail": "路径",
    "head_offset": "2",
    "tail_offset": "44"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并将较大元素逐步交换到右侧，重复此过程直到整个数组有序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "顺序表具有随机访问效率高、存储密度大、逻辑上相邻的元素物理上也相邻但插入和删除操作效率低的特点",
    "head": "访问",
    "tail": "插入",
    "head_offset": "7",
    "tail_offset": "34"
  },
  {
    "sentence": "比较排序是一种排序算法，其核心特征是通过比较元素之间的大小关系来确定元素的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合所构成的数据结构，其中边是没有方向的且连接着两个顶点",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "简单排序是对数据元素按照特定规则进行比较和交换等操作以实现从小到大或从大到小有序排列的排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "满二叉树是一种二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心特征包括用一组任意的存储单元存储数据元素，这些存储单元不一定连续",
    "head": "链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "满二叉树是一棵二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并将较大元素逐步交换到右侧，重复此过程直到整个数组有序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "平衡二叉树的核心特征是其每个节点的左右子树高度差的绝对值不超过1并且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "队列的核心特征是先进先出即元素按照进入队列的先后顺序依次从队列中取出，先进入队列的元素先被取出",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它包含数据元素的表示和关系的表示两方面内容",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "比较排序是一种排序算法，其核心特征是通过比较元素之间的大小关系来确定元素的相对顺序从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其每个结点的左右子树高度差的绝对值不超过1且左右子树均为平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并将较大元素逐步交换到右侧，重复此过程直到整个数组有序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，用于表示该边的某种代价、距离、容量等相关度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "满二叉树是一种二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，将较大元素逐步交换到右侧，重复此过程直到整个数组有序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "映射是一种特殊的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（对于有向图是有向顶点序列），且相邻顶点之间有边相连",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "满二叉树是一种二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成的数据结构，顶点表示事物，边表示事物之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "有向图是一种图结构，由顶点集合和有向边集合组成，其中每条有向边是从一个顶点指向另一个顶点的有序对",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相同的输入，排序算法产生的输出序列中相等元素的相对次序保持不变的特性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "回路是图中一条起点和终点相同的路径且其长度大于等于 1 并且路径上除起点和终点外的顶点不重复遍历",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储方式以及数据元素之间关系的存储方式",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "回路是数据结构中从一个顶点出发，沿着边经过一系列顶点后又回到起始顶点的路径且路径中至少包含一条边",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "比较排序是一种基于元素间比较操作来确定元素相对次序从而将给定元素序列重新排列成有序序列的排序算法",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过比较元素之间的大小关系来确定元素在排序序列中的相对位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "双向链表每个节点包含两个指针，一个指向前驱节点，一个指向后继节点，通过这两个指针可以双向遍历链表",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "穷举法的核心特征是对问题所有可能的情况进行逐一列举和检验，通过遍历所有可能解来找到符合条件的答案",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "递归基础是递归算法中存在的一种简单情况，在此情况下递归函数可直接返回一个确定值而无需再次调用自身",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中数据元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行特定计算步骤，从初始值出发逐步逼近问题解的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "递归基础是递归算法中当问题规模小到一定程度时可直接得出结果无需再进行递归调用的初始条件或终止情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，反映数据在组织上的一种抽象表示",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "交换排序是通过比较序列中元素，若顺序错误就把它们交换过来，直到整个序列都被正确排序的一种排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "41"
  },
  {
    "sentence": "栈的核心特征是后进先出即最后进入栈的元素最先被弹出栈，且具有限定仅在栈顶进行插入和删除操作的特性",
    "head": "出栈",
    "tail": "插入",
    "head_offset": "24",
    "tail_offset": "38"
  },
  {
    "sentence": "线性查找的核心性质是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "41"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "树的节点具有唯一的根节点且除根节点外每个节点有且仅有一个父节点同时每个节点可以有零个或多个子节点",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "穷举法的核心特征是对问题所有可能的情况进行逐一列举和检验，通过遍历所有可能解来找到符合条件的答案",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "满二叉树是一棵二叉树，其中每个节点要么有两个子节点，要么没有子节点，并且所有叶子节点都在同一层上",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左右子树高度差的绝对值不超过1且左右子树均为平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "在树形数据结构中父节点是指其下有直接子节点的节点，一个节点若有子节点则该节点为这些子节点的父节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "8",
    "tail_offset": "18"
  },
  {
    "sentence": "简单排序是对数据序列进行排序的一种方式其核心性质是通过比较和交换元素位置将无序序列转化为有序序列",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左右子树高度差的绝对值不超过1且左右子树均为平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "图是一种由顶点集合及顶点间的边集合组成的数据结构，其中顶点表示数据元素，边表示数据元素之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "7",
    "tail_offset": "15"
  },
  {
    "sentence": "在树形结构中直接有一条边连接到某个节点且该节点没有其他子节点与之相连的那个节点就是该节点的父节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "27",
    "tail_offset": "45"
  },
  {
    "sentence": "树的查找的核心性质是若树中存在关键字等于给定值的结点，则必能在从根结点开始的一条路径上找到该结点",
    "head": "查找",
    "tail": "路径",
    "head_offset": "2",
    "tail_offset": "40"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，所有其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "平衡二叉树的核心特征是其左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "递归基础是递归算法中存在的一种情况即当问题规模缩小到某一特定值时可直接得出结果无需再进行递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "递归基础是递归算法中存在的一种简单情况，在该情况下递归函数可直接返回一个确定值而无需再次调用自身",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长路径上的边数或节点数所确定的一个衡量树的结构层次深度的数值",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是由顶点集和边集组成的一种图结构，其中边集中的边是没有方向的且顶点集中的顶点通过边相互连接",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "有向图是一种图结构，由顶点集合和有向边集合组成，其中每条有向边是从一个顶点指向另一个顶点的有序对",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "递归基础具有明确的初始条件或终止条件使得递归调用能够停止且能直接给出结果不依赖于进一步的递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "平衡二叉树的核心特征是其左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "顺序表具有逻辑上相邻的元素物理存储位置也相邻、可随机访问、存储密度高、插入和删除操作效率低等特点",
    "head": "访问",
    "tail": "插入",
    "head_offset": "26",
    "tail_offset": "35"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针从而可以双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上边的数目且该高度是整棵树中所有节点高度值中的最大值",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树的核心性质是其每个节点的左右子树高度差的绝对值不超过1，并且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总而成的集体，集合中的元素具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有限序列，这些元素在内存中按顺序存储，通过下标来唯一标识每个元素",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件直接得出结果而无需再次递归调用自身从而终止递归过程的初始情况定义",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "简单排序是对一组数据按照特定规则依次比较和交换元素位置以实现从小到大或从大到小有序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "数据类型的特点是每种数据类型都有其特定的取值范围、存储方式、操作规则以及所适用的场景等方面的属性",
    "head": "数据类型",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "迭代法的核心性质是通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题的精确解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，反映数据在组织上的一种抽象关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "穷举法的核心特征是对问题所有可能的情况进行逐一列举和检验，通过遍历所有可能解来找到符合条件的答案",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "迭代法的核心性质是通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题的精确解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构其中顶点集合不能为空关系集合描述顶点之间的连接方式",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "父节点是在树形结构中，有一个或多个子节点直接连接在其下方，且自身没有直接连接在其他节点上方的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "非线性结构是一种数据元素之间存在一对多或多对多关系的数据结构即数据元素之间的关系不再是线性的关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "图的核心性质是由顶点集合以及顶点之间的边集合所构成的数据结构，顶点之间通过边来表示它们之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "非线性结构是一个数据元素的有序集，其中存在一个或多个数据元素有不止一个前驱元素或不止一个后继元素",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心特征是元素按照先进先出的原则进行排列，即先进入队列的元素先离开队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "无向图是由顶点集和边集组成的一种图结构其中边集中的边是没有方向的顶点与顶点之间通过这些无向边相连",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "数组的核心性质是具有固定大小，其元素在内存中按顺序存储，通过下标可以直接访问和修改特定位置的元素",
    "head": "数组",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "线性查找的核心性质是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "41"
  },
  {
    "sentence": "迭代法的核心性质是通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题的精确解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序的排序算法其核心性质是排序结果仅依赖于元素间的比较关系",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "回路是数据结构中从一个顶点出发，沿着边经过若干顶点后又回到该起始顶点的路径且路径中至少包含一条边",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "递归基础是递归定义中确定的最基本情况，具有当问题规模达到最小或最简形式时可直接得出结果的核心性质",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "迭代法的核心性质是通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题的精确解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "递归基础是递归算法中存在的一种情况即当问题规模减小到某一特定值时可直接得出结果无需再进行递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质包括：若图中有n个顶点，则邻接矩阵是一个n×n的方阵",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "迭代法的核心性质是通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题的精确解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是一对一的线性关系，而是存在一对多、多对一或多对多等复杂关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "归并排序是将一个序列分成两个子序列分别递归排序后，再将排序好的子序列合并成一个有序序列的排序算法",
    "head": "归并排序",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "迭代法的核心性质是通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题的精确解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "41"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种顺序排列成一个序列",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "41"
  },
  {
    "sentence": "线性查找的核心性质是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "41"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针从而实现双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数或节点数所体现出的树的垂直方向上的度量特点",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针从而可以双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，每一条有向边都有明确的方向",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "穷举法的核心特征是对问题所有可能的情况进行逐一列举和检验，通过遍历所有可能解来找到符合条件的答案",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "平衡二叉树的每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质包括：对于有n个顶点的图，邻接矩阵是一个n×n的方阵",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "回路是在图中从一个顶点出发，沿着边连续移动，最终回到起始顶点的路径且除起始顶点外路径中顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "图的顶点是图结构中用于表示数据元素的基本单元，它可以与其他顶点通过边建立连接关系从而构成图的结构",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中每个数据元素最多有一个直接前驱和一个直接后继",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，在最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "完全二叉树是除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "平衡二叉树的核心特征是其左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "映射是一种具有唯一性特点的关系，即对于集合A中的任意一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "栈是一种限定仅在表尾进行插入和删除操作的线性表，其核心性质为后进先出，即最后进入栈的元素最先被弹出",
    "head": "表尾",
    "tail": "插入",
    "head_offset": "8",
    "tail_offset": "12"
  },
  {
    "sentence": "父节点具有在树形结构中处于上一层级且与子节点存在直接关联关系从而能对其进行层级管理和引导的核心性质",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件的最简情况，在该情况下递归调用不再继续，而是直接给出一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质为只允许在一端进行插入操作，另一端进行删除操作，遵循先进先出原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归排序，再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "图的边是连接图中两个顶点的元素，它具有明确的两个端点即顶点，且在有向图中边有方向而无向图中边无方向",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "递归基础是递归算法中存在的一种终止条件，当满足该条件时递归不再继续进行，直接返回一个确定的简单结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它具有数据元素的表示和关系的表示这两个核心性质",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "递归基础是递归算法中确定的最简单情况或初始条件，在该条件下递归函数无需再次调用自身即可直接给出结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性通过特定规则从根节点开始按路径逐步查找目标元素以确定其是否存在于树中",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "22"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有限序列，这些元素在内存中按顺序存储，可通过下标来唯一标识每个元素",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "双向链表是一种线性数据结构，其中每个节点包含一个数据元素以及分别指向其前驱节点和后继节点的两个指针",
    "head": "双向链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "回路是在图中从一个顶点出发，沿着边连续移动，最终回到起始顶点的路径且除起始顶点外所经过的顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "回路是数据结构中从一个顶点出发，沿着边经过一系列顶点后又回到该起始顶点的路径且路径中至少包含一条边",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其每个结点的左右子树高度差的绝对值不超过1且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，再访问距离更远节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，若存在从顶点v到顶点w的一条路径，则称从v到w是可达的",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "双向链表是一种线性数据结构，其中每个节点包含一个数据元素以及分别指向其前驱节点和后继节点的两个指针",
    "head": "双向链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "无向图是一种图结构其中任意两个顶点之间的边没有方向即顶点对(u,v)和顶点对(v,u)表示同一条边",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆是一种优先队列数据结构，其特点是父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值",
    "head": "队列",
    "tail": "父节点",
    "head_offset": "6",
    "tail_offset": "17"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，再访问距离更远节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "树的节点的核心性质是每个节点有零个或多个子节点且有且仅有一个父节点（根节点除外，根节点没有父节点）",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接与根节点相连",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "无向图的核心特征是由顶点集合以及顶点之间的边集合组成，其中边是没有方向的，即顶点之间的连接是双向的",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "线性结构的核心性质是数据元素之间存在着一对一的线性关系，即除第一个元素外，每个元素有且仅有一个前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它具有数据元素的表示和关系的表示这两个核心性质",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别进行排序，再把排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据类型定义的核心性质包括具有特定的值集合、定义了一组对这些值的操作以及规定了这些操作所遵循的规则",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归排序后再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素顺序的排序算法其核心性质为通过比较元素大小来逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的元素在物理位置上也相邻",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的一端进行插入操作，而在另一端进行删除操作，具有先进先出的特性",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "平衡二叉树是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "双向链表每个节点包含数据、指向前一个节点的指针和指向后一个节点的指针，既可以向前遍历也可以向后遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树每个节点最多有两棵子树，并且二叉树的度最大为2，同时二叉树的左右子树是有顺序的，次序不能颠倒",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "递归基础是递归算法中递归调用结束的条件即当满足特定条件时递归函数不再进行自身调用而是返回一个确定值",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "平衡二叉树是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉树是一种树形结构，其每个节点最多有两个子节点，分别称为左子节点和右子节点，并且二叉树可以为空树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "在图论中回路是指在一个图中从某一顶点出发，沿着边连续移动，经过若干个不同顶点后又回到起始顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "47"
  },
  {
    "sentence": "子节点是树结构中直接位于某一节点下方的节点，具有与父节点存在直接层级关系且处于其下一层级的核心性质",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其每个结点的左右子树高度差的绝对值不超过1且左右子树均为一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的一端进行插入操作，而在另一端进行删除操作，具有先进先出的特性",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性查找是按顺序依次对数据集合中的每个元素进行比较判断，直至找到目标元素或遍历完整个集合的查找方法",
    "head": "查找",
    "tail": "集合",
    "head_offset": "2",
    "tail_offset": "13"
  },
  {
    "sentence": "简单排序是对数据元素按照特定规则进行比较和交换等操作以实现从小到大或从大到小有序排列的一种排序方式",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序表具有随机访问效率高、存储密度大、逻辑上相邻元素物理存储位置也相邻但插入和删除操作效率低等特点",
    "head": "访问",
    "tail": "插入",
    "head_offset": "7",
    "tail_offset": "36"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素以及指向后继节点的指针，且最后一个节点的指针为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "双向链表是一种线性数据结构，其中每个节点包含一个数据元素以及分别指向其前驱节点和后继节点的两个指针",
    "head": "双向链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "归并排序的核心性质是将一个数组分成两个子数组分别进行排序，然后将排序好的子数组合并成一个有序的数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "归并排序的核心特征是将一个序列分成两个子序列分别进行排序，然后将排序好的子序列合并成一个有序的序列",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "完全二叉树是一种除最后一层外，每一层上的节点数都达到最大值，且最后一层上只缺少右边若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "数组是一种具有固定大小的数据结构，其中元素具有相同的数据类型，并且可以通过下标来访问和修改这些元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "回路是在图中从一个顶点出发，沿着边连续移动，最终回到起始顶点且路径中顶点不重复（除起始顶点）的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其元素的插入和删除操作都在同一端进行，这一端被称为栈顶，另一端则为栈底",
    "head": "插入",
    "tail": "删除",
    "head_offset": "18",
    "tail_offset": "21"
  },
  {
    "sentence": "顺序表具有随机访问效率高、存储密度大、逻辑上相邻的数据元素物理上也相邻但插入和删除操作效率低的特点",
    "head": "访问",
    "tail": "数据元素",
    "head_offset": "7",
    "tail_offset": "25"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边构成的图，其中每条边都有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间缩小一半来查找目标值，具有查找效率高、时间复杂度为对数级的特点",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "图是一种由顶点集合及顶点间的边的集合组成的数据结构，其中顶点表示数据元素，边表示数据元素之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "7",
    "tail_offset": "16"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "归并排序的核心性质是将一个数组分成两个子数组分别进行排序，然后将排序好的子数组合并成一个有序的数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数或节点数所体现出的关于树的垂直延伸程度的特征",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作以实现排序，具有操作相对简单、适用于较小规模数据序列等特点",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "操作效率是指在数据结构中进行各种操作（如插入、删除、查找等）时所花费的时间和空间资源的综合表现情况",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "稳定性是指在数据结构中，对于相同的输入，排序算法产生的输出序列中，相等元素的相对顺序保持不变的性质",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "在图论中回路是指在一个图中从某一顶点出发，沿着边连续移动，经过若干个不同顶点后又回到起始顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "47"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点包含一个数据元素以及分别指向其前驱节点和后继节点的两个指针",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "归并排序的核心性质是将一个数组分成两个子数组分别进行排序，然后将排序好的子数组合并成一个有序的数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对顺序的排序算法其核心特征是通过比较元素大小来逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "简单排序是对数据序列通过比较和交换元素位置等基本操作，将其按特定顺序（如升序或降序）排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的一端进行插入操作，而在另一端进行删除操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "简单排序是对数据序列通过比较和交换元素位置等基本操作，将其按特定顺序（如升序或降序）排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归排序，再把排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的地址，通过它可以间接访问和操作所指向的内存位置的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "插入排序的核心性质是将未排序数据插入到已排序序列的合适位置，通过不断重复此操作，最终使整个数组有序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "在树形数据结构中父节点是直接有一个或多个子节点连接在其下方的节点且处于比子节点更高层次的结构位置上",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "8",
    "tail_offset": "20"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "稳定性的定义的核心性质是对于已排好序的输入序列，排序算法在排序过程中不会改变相同元素之间的相对顺序",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "图的边是连接图中两个顶点的线，它可以表示顶点之间的关系，并且在有向图中边具有方向而无向图中边无方向",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点的方向",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归排序后，再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "完全二叉树是一种除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点的二叉树",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "47"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的地址，通过该指针可以访问和操作其所指向的内存位置的数据",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列为止",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "41"
  },
  {
    "sentence": "二叉搜索树中任意节点的左子树中的所有节点的值均小于该节点的值且右子树中的所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "递归基础是递归算法中最简单的情况，通常是问题的最小规模或最基本形式，直接给出答案而无需进一步递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，使得从链表中的任意节点出发都可以遍历整个链表形成一个环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "队列是一种先进先出的数据结构，其核心性质为元素按照进入的先后顺序依次存储，先进入队列的元素先离开队列",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "图是一种由顶点集合以及顶点之间的边集合所构成的数据结构，其中顶点是图的基本元素，边表示顶点之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "7",
    "tail_offset": "17"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针从而可以双向遍历链表",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "交换排序是一种通过比较元素并交换不满足顺序要求的元素位置来逐步将无序序列转变为有序序列的数据排序方法",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的每一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "无向图是一种图结构，由顶点集合和边集合组成，其中边是顶点的无序对，顶点之间通过边相连且不区分边的方向",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件的初始情况，在此情况下递归函数直接返回一个已知结果而不再进行递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算机资源量，包括时间资源和空间资源，通常用时间复杂度和空间复杂度来衡量",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "36",
    "tail_offset": "42"
  },
  {
    "sentence": "数组是具有相同数据类型的一组数据元素的集合，这些元素在内存中按顺序存储，可通过下标唯一地访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是整个树的起始点，其他所有节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成的数据结构，其中顶点表示事物，边表示事物之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "稳定性是指在数据结构中，若存在两个相等的元素，在排序前后它们的相对位置保持不变则该数据结构具有稳定性",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二分查找是在有序数组中，通过不断将区间缩小一半的方式，查找目标元素是否存在并确定其位置的一种查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列为止",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "41"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "二叉树是一种树形结构，它的每个节点最多有两个子节点，分别称为左子节点和右子节点，并且二叉树可以为空树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二叉搜索树中每个节点的左子树中的所有节点的值均小于该节点的值且右子树中的所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的每一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "父节点是树结构中一个节点，有一个或多个子节点，且在从根节点到该节点的路径上，它是子节点的直接前驱节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针从而可以双向遍历链表",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成的数据结构，其中顶点表示事物，边表示事物之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的逻辑结构的核心性质包括数据元素之间的逻辑关系，以及这些关系所决定的数据组织形式和操作方式等方面",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，具有先进先出的特性",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合组成的图结构其中边是没有方向的顶点对表示顶点之间的连接关系",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二分查找是在有序数组中，通过不断将区间分成两半并比较中间元素与目标值，以确定目标值所在位置的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "对于给定数据结构的排序算法，在原数据序列中相同元素的相对位置在排序前后保持不变则该排序算法具有稳定性",
    "head": "排序",
    "tail": "排序",
    "head_offset": "9",
    "tail_offset": "31"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点，具有与父节点的特定连接关系且可能有自己的子节点等相关特性",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树是一种树型结构，它的每个节点最多有两个子节点，分别称为左子节点和右子节点，并且二叉树可以为空树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "循环链表的核心特征是其尾节点的指针不是指向空，而是指向链表的头节点，从而使得整个链表形成一个环形结构",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点的方向",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "操作效率的特点是指数据结构在执行各种操作（如插入、删除、查找等）时所表现出的时间和空间方面的性能特性",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "操作效率是指在数据结构中进行各种操作（如插入、删除、查找等）时所花费的时间、空间等资源的综合表现情况",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "简单排序是对数据序列进行排序的一种方式其核心性质是通过比较和交换元素位置将无序数据序列转换为有序序列",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是只允许在一端进行插入操作，而在另一端进行删除操作，具有先进先出的特性",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "数组的核心性质是其元素在内存中按顺序存储且具有相同的数据类型，通过下标可以方便地访问和修改其中的元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素在计算机中的存储方式以及数据元素之间的逻辑关系在计算机中的表示方式",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "无向图是由顶点集和边集组成的一种图结构，其中边集是顶点集的无序对集合，顶点之间通过边相连且边没有方向",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，是整个树结构的入口和基础，通过它可以遍历和访问树中的其他节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "在无向图中，若从顶点vi到顶点vj有路径（当然从vj到vi也一定有路径），则称vi和vj是连通的，若",
    "head": "无向图",
    "tail": "路径",
    "head_offset": "1",
    "tail_offset": "18"
  },
  {
    "sentence": "顺序表具有逻辑上相邻的元素在物理存储位置上也相邻、可随机访问、存储密度高、插入和删除操作效率低等特点",
    "head": "访问",
    "tail": "插入",
    "head_offset": "28",
    "tail_offset": "37"
  },
  {
    "sentence": "顺序表具有逻辑上相邻的元素在物理存储位置上也相邻、可随机访问、存储密度高但插入和删除操作效率低等特点",
    "head": "访问",
    "tail": "插入",
    "head_offset": "28",
    "tail_offset": "37"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是只允许在一端进行插入操作，而在另一端进行删除操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的高度的核心特征是从树的根节点到最远叶子节点之间最长简单路径上的边数或节点数所代表的垂直距离度量值",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "有向图是一种由顶点集合以及顶点间的有向边集合组成的图，其中有向边是有方向的，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "根节点是树结构中处于顶层没有父节点的唯一节点，它是树的起始点，从它开始向下延伸出树的各个分支和子节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合组成的图结构，其中边是没有方向的，即顶点之间的连接是双向的",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其特点的核心特征包括：若图中有n个顶点，则邻接矩阵是一个n×n的方阵",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点的方向",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "父节点具有在树形结构中处于上一级位置且拥有子节点的特点其核心性质为可通过它访问到其下一级的子节点集合",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定规则依次访问二叉树中的每一个节点使得每个节点被访问且仅被访问一次的操作过程",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "数组是一种有序数据元素的集合，每个元素具有相同的数据类型，可通过数组名和下标来唯一标识和访问这些元素",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，顺序依次检查线性表中的每个元素，直到找到目标元素或遍历完整个线性表为止",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列为止",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点的方向",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉树的核心性质为在二叉树的第i层上至多有2的i-1次方个节点（i≥1），深度为k的二叉树至多有2的",
    "head": "二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "在图论中，回路是指在一个图中从某一顶点出发，沿着边连续移动，经过若干个不同顶点后又回到起始顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "5",
    "tail_offset": "48"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，具有先进先出的特性",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的每一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中各节点度的最大值即为树的度树中每个节点的度都小于或等于树的度且树中至少存在一个节点其度等于树的度",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "12",
    "tail_offset": "29"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机存储空间中的存储方式包括数据元素的存储位置以及数据元素之间关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "父节点是树状结构中位于某一节点之上，拥有子节点，且对于其所有子节点而言具有层级上的直接管辖关系的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "图的边是连接图中两个顶点的元素，具有方向或无方向、有权重或无权重等特点，边的集合决定了图的结构和性质",
    "head": "图的边",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成的数据结构，其中顶点表示事物，边表示事物之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "平衡二叉树的核心性质是树上任一节点的左子树和右子树的高度差不超过1且左子树和右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "在无向图中，若从顶点vi到顶点vj有路径（当然从vj到vi也一定有路径），则称vi和vj是连通的，若",
    "head": "无向图",
    "tail": "路径",
    "head_offset": "1",
    "tail_offset": "18"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，具有先进先出的特性",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针从而可以双向遍历链表",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算机资源量，包括时间资源和空间资源，通常用时间复杂度和空间复杂度来衡量",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "36",
    "tail_offset": "42"
  },
  {
    "sentence": "双向链表每个节点包含数据、指向前驱节点的指针和指向后继节点的指针，通过这些指针可在两个方向上遍历链表",
    "head": "双向链表",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且每个节点有零个或多个子节点，节点之间存在一对多的层次关系",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "17",
    "tail_offset": "32"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树是一种递归定义的数据结构它由一个根节点和零个或多个子树构成每个子树又由根节点和其各自的子树递归组成",
    "head": "递归",
    "tail": "根节点",
    "head_offset": "4",
    "tail_offset": "17"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，具有先进先出的特性",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "简单排序是对数据序列进行排序的一种基本方法，它通过比较和交换元素的位置，将无序序列逐步转换为有序序列",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "简单排序是对数据元素序列通过比较相邻元素大小并进行交换等操作，逐步将无序序列转变为有序序列的排序方法",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，它可以表示各种实体，并且与其他顶点通过边相互连接以构成图的整体结构",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括顺序存储、链式存储、索引存储和散列存储等方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是只允许在一端进行插入操作，而在另一端进行删除操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置，通过不断重复此操作来实现整个数组有序的一种排序算法",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，其方向由一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性查找是在一个数据序列中从起始位置开始依次逐个检查元素，直至找到目标元素或遍历完整个序列的查找方法",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作以使其按特定顺序排列，具有操作相对简单、时间复杂度较高等特点",
    "head": "简单排序",
    "tail": "时间复杂度",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "递归基础是递归算法中存在的某些初始情况或条件，在这些情况下递归直接返回一个已知结果而不再进行递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，其特点是序列中顶点依次相邻且路径长度为路径上顶点数减 1",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "子节点是树结构中相对于父节点而言的节点，其核心特征包括：它直接隶属于某个父节点，是父节点分支出来的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "非线性结构是一种数据元素之间存在一对多或多对多关系的数据结构，其数据元素的逻辑关系不再是简单的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树遍历的核心性质包括先序遍历是根节点、左子树、右子树的顺序，中序遍历是左子树、根节点、右子树的顺序",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它是一个完全二叉树，并且满足父节点的值大于或小于其子节点的值（大顶堆或小顶堆）",
    "head": "完全二叉树",
    "tail": "父节点",
    "head_offset": "16",
    "tail_offset": "26"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中直接位于某一节点下方的节点，与父节点存在直接的层级关系且是父节点所连接的下一层级的节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "回路是在图中从一个顶点出发，沿边经过一些顶点后又回到该起始顶点的路径且路径中除起始顶点外其他顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径相连，在有向图中任意一对顶点间都存在有向路径相互可达的图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归定义中满足特定条件的初始情况其核心性质是具有明确的、无需进一步递归即可确定的定义值或状态",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "子节点是树结构或图结构中，直接连接在某一节点之下的节点，具有与父节点存在特定连接关系且处于其下层的特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始依次逐个与目标值进行比较，直到找到目标值或遍历完整个序列的查找方法",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "39"
  },
  {
    "sentence": "线性查找的核心性质是从数据序列的起始位置开始，依次对每个元素进行比较，直到找到目标元素或遍历完整个序列",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "44"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边构成的图，其中每条有向边都有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，它可以用来表示各种实体或对象，并且通过边与其他顶点相连以构成图的结构",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉树的核心性质是在二叉树的第i层上至多有2的i-1次方个节点，深度为k的二叉树至多有2的k次方减1个",
    "head": "二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边构成的图，其中每条有向边都有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "平衡二叉树的核心特征是树上任一结点的左子树和右子树的高度差不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边组成的图，其中每条有向边都有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边构成的图，其中每条有向边都有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点到另一个顶点的单向连接",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据类型的完整定义是对数据的取值范围、数据元素之间的逻辑关系以及在这些数据上所允许进行的操作的明确规定",
    "head": "数据类型",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点到另一个顶点的单向连接",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其每个结点的左右子树高度差的绝对值不超过1，并且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树其每一层上的节点数都达到最大值即第i层有2^(i-1",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "对于给定的某个排序算法，若存在两个相等的元素，在排序前后它们的相对位置保持不变，则该排序算法具有稳定性",
    "head": "排序",
    "tail": "排序",
    "head_offset": "7",
    "tail_offset": "24"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的数值计算方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，若按层次序对其编号后，编号为i（1≤i≤n）的结点与满二叉",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的地址，通过指针可以间接访问和操作其所指向的内存位置的数据",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其每一层上的节点数都达到最大值，即第i层有2^(i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的查找的核心特征是从根节点开始，根据节点间的父子关系，按照特定规则在树的节点中进行搜索以找到目标节点",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算资源量，通常用时间复杂度和空间复杂度来衡量算法在时间和空间上的效率表现",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "23",
    "tail_offset": "29"
  },
  {
    "sentence": "图的边是连接图中顶点的线，具有两个端点且方向可分为有向边和无向边，边可有权重，边的集合决定了图的连通性",
    "head": "图的边",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序好的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "满二叉树是深度为k且有2的k次方减1个节点的二叉树其中每一层上的节点数都达到最大值即第i层上有2的i减",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性查找是在一个数据序列中从第一个元素开始依次逐个检查，直到找到目标元素或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "37"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点包括：对于有向图，邻接矩阵中第i行第j列的元素值若为1表示从顶点i到",
    "head": "邻接矩阵",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "子节点是树结构中直接位于某一节点下方的节点，具有与父节点存在直接层次关系且处于父节点下一层级的核心性质",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "二叉树的核心性质是在二叉树的第i层上至多有2的i-1次方个节点，深度为k的二叉树至多有2的k次方减1个",
    "head": "二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数组的核心性质是具有相同数据类型的一组数据元素，在内存中按顺序存储，通过下标来唯一标识和访问其中的元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边经过若干个顶点后又回到该顶点的路径且路径中除起点和终点外顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "队列的特点是先进先出，即先进入队列的元素先出队列，新元素总是添加在队列末尾，删除操作总是在队列头部进行",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归进行排序后再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "堆是一种优先队列数据结构，它通常用数组实现，满足堆特性：对于最大堆，每个节点的值大于或等于其子节点的值",
    "head": "队列",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "17"
  },
  {
    "sentence": "连通图中任意两个顶点之间都存在路径，即从图中任意一个顶点出发，都能够通过一系列边到达图中的其他任意顶点",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置，通过不断重复此操作，逐步将整个数组变为有序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过下标来访问和修改元素，且内存中存储是连续的",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉树的核心性质是在二叉树的第i层上至多有2的i-1次方个节点，深度为k的二叉树至多有2的k次方减1个",
    "head": "二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机，仅考虑数据元素间的抽象关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "双向链表是一种链表结构，每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，从而支持双向遍历",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表每个节点包含数据、指向前驱节点的指针和指向后继节点的指针，通过前驱指针和后继指针可双向遍历链表",
    "head": "双向链表",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "平衡二叉树的核心性质是树上任一结点的左子树和右子树的高度之差不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其每个结点的左右子树高度差的绝对值不超过1，并且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "数组是一种由相同类型的数据元素组成的线性数据结构，这些元素在内存中按顺序存储且通过下标来唯一标识和访问",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其特点为：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1)",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的数值计算方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，除第k层外，其余各层的结点数都达到最大个数，且第k层的结点都",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的数值计算方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机存储空间中的存储方式包括数据元素的存储方式以及数据元素之间关系的存储方式",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "27"
  },
  {
    "sentence": "二叉树的核心性质是在二叉树的第i层上至多有2的i-1次方个节点，深度为k的二叉树至多有2的k次方减1个",
    "head": "二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边构成的图，其中每条边都有一个特定的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点到另一个顶点的单向连接",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点到另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边连续移动，最终回到起始顶点且路径中除起始顶点外其他顶点不重复的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "树的度的核心特征是树中所有结点的度的最大值，它反映了树中各结点拥有子树数量的最大情况决定了树的复杂程度",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "图的边是连接图中两个顶点的元素，具有方向（有向图的边有方向，无向图的边无方向）、权重（可有权重表示边的",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边连续移动，最终回到该顶点且路径中除起点和终点外其他顶点不重复的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "比较排序是一种排序算法，其核心特征是通过比较元素之间的大小关系来确定元素在排序序列中的位置从而实现排序",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "平衡二叉树的核心特征是树上任一结点的左子树和右子树的深度之差不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆是一种优先队列数据结构，它满足父节点的值大于或等于（最大堆）或小于或等于（最小堆）其子节点的值的特性",
    "head": "队列",
    "tail": "父节点",
    "head_offset": "6",
    "tail_offset": "16"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树的核心性质是树上任一结点的左子树和右子树的高度差不超过1并且左子树和右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机，反映数据元素之间的结构关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "稳定性的特点的核心特征是在对数据结构进行某种操作（如排序等）时，相等的元素在操作前后的相对位置保持不变",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是由顶点集和边集组成的一种图结构其中边集是顶点集的无序对集合且任意一条边连接两个顶点没有方向之分",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "图的边是连接图中两个顶点的线或弧，它表示顶点之间的某种关系，在有向图中边具有方向性而无向图中边无方向性",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边构成的图，其中每条有向边都有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树的核心性质是树上任一结点的左子树和右子树的高度之差不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件的最基本情况，在此情况下递归函数不再调用自身而是直接返回一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "比较排序是一种排序算法，它通过比较元素之间的大小关系来确定元素的相对位置，从而将无序序列转换为有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序好的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，从而可以双向遍历链表",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "图的顶点是图结构中用于表示数据元素的基本单元，它具有特定的标识且可能与其他顶点通过边相连以构成图的结构",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的值大于或小于其子节点的值（大顶堆或小顶堆）且具有完全二叉树的特性",
    "head": "父节点",
    "tail": "完全二叉树",
    "head_offset": "15",
    "tail_offset": "43"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边连续移动，最终回到起始顶点且路径中除起始顶点外其他顶点不重复的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，具有唯一标识整棵树的作用，树中其他节点都直接或间接连接到根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "简单排序是对数据序列进行排序的一种方式，其核心性质是通过比较和交换元素位置逐步将无序序列转化为有序序列",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，具有特定的取值范围、存储方式和操作规则等特点",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归进行排序后再将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树的核心特征是树上任一节点的左子树和右子树的高度差不超过1并且左子树和右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大值",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点到另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值用于表示与边相关的某种代价、距离、容量等属性",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组的核心性质是其元素在内存中按顺序存储且具有相同的数据类型，通过下标可以唯一地访问和修改数组中的元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "简单排序是对数据序列通过比较元素大小并进行交换等操作，将其按特定顺序（如升序或降序）排列的一种排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "47"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的数值计算方法",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础具有明确的终止条件，是递归算法中最简单、最基本的情况，不依赖于进一步的递归调用即可直接得出结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的存储地址，通过它可以间接访问和操作所指向的内存位置的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "树的节点是树结构中的基本数据单元包含数据元素及指向其子节点的若干分支且根节点没有父节点叶节点没有子节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树是深度为k的二叉树，除第k层外，其余各层的节点数都达到最大个数，且第k层的节点都集中在该层最",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "非线性结构是一种数据元素之间存在着一对多或多对多的联系，无法用一条连续的直线来表示其逻辑关系的数据结构",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "平衡二叉树的核心特征是树上任一结点的左子树和右子树的高度之差不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是只允许在表的一端进行插入操作，而在另一端进行删除操作，遵循先进先出原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数组的核心性质是其元素在内存中按顺序存储且具有相同的数据类型，通过下标可以直接访问和修改特定位置的元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "邻接矩阵的核心性质是若图中有一条从顶点i到顶点j的边，则邻接矩阵中第i行第j列元素值为1，否则为0，且",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "映射是一种从集合A到集合B的对应关系，对于集合A中的任意一个元素，在集合B中都有唯一的一个元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树的核心特征是树上任一结点的左子树和右子树的高度之差不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "非线性结构是一种数据元素之间存在着一对多或多对多关系的数据结构，其数据元素的逻辑关系不再是简单的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "插入排序的特点的核心性质是将未排序数据插入到已排序序列的合适位置，通过不断重复此操作，最终使整个数组有序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行某一运算过程，从初始值出发逐步逼近问题解的数值计算方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "栈是一种限定仅在表尾进行插入和删除操作的线性表，表尾称为栈顶，表头称为栈底，不含任何数据元素的栈称为空栈",
    "head": "表尾",
    "tail": "插入",
    "head_offset": "8",
    "tail_offset": "12"
  },
  {
    "sentence": "在树形数据结构中若存在节点A和节点B，当节点B直接连接于节点A且节点A为父节点时节点B就是节点A的子节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "36",
    "tail_offset": "49"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是只允许在表的一端进行插入操作，而在另一端进行删除操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是只允许在一端进行插入操作，而在另一端进行删除操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的起始位置开始，依次逐个检查每个元素，直到找到目标元素或遍历完整个序列为止",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其每一层上的节点数都达到最大值，即第i层有2^(",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "堆的核心特征是父节点的值大于或等于（大顶堆）其子节点的值，或者父节点的值小于或等于（小顶堆）其子节点的值",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "7",
    "tail_offset": "31"
  },
  {
    "sentence": "图的顶点是图结构中用于表示数据元素的基本单元，是构成图的重要组成部分且在图的各种操作和关系中具有关键作用",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算机资源量，包括时间资源和空间资源，通常分别用时间复杂度和空间复杂度来衡量",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "38",
    "tail_offset": "44"
  },
  {
    "sentence": "递归基础是递归算法中存在的一种情况，即当问题规模减小到某一特定值时，可直接得出问题的解而无需再次递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "非线性结构中至少存在一个数据元素有两个或两个以上直接前驱或直接后继即各数据元素之间的逻辑关系不再是线性的",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性通过特定的遍历或比较方式在树中定位特定元素以确定其是否存在或获取其相关信息",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数，它反映了树的层次结构特性及节点分布的纵向跨度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，它可以代表各种实体或对象，并且与其他顶点通过边相互连接从而构成图的结构",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左右子树高度差的绝对值不超过1，并且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，若按层次序编号后其所有结点均与深度为k的满二叉树中编号从1至n",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是只允许在表的一端进行插入操作，而在另一端进行删除操作，具有先进先出的特性",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值，即第i层有2^(i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其中若图中存在从顶点i到顶点j的边，则邻接矩阵中第i行第j列的元素值为1",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树",
    "head": "平衡二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "完全二叉树是这样一种二叉树，除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机，仅考虑数据元素之间的逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "映射是一种具有特定对应关系的数据结构特点，它使得集合A中的每一个元素在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是只允许在一端进行插入操作，而在另一端进行删除操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点且处于树的顶层位置并在整个树结构中具有关键地位",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "双向链表每个节点包含数据、指向前一个节点的指针和指向后一个节点的指针，节点间通过指针双向连接，可双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成的数据结构，顶点用于表示事物，边用于表示事物之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "树的节点是包含数据以及指向子节点的指针（对于有子节点的情况）或为空指针（对于叶子节点）的基本数据结构单元",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，对于树中的任一结点，若其编号为i（1≤i≤n），则其左孩子结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "顺序表具有逻辑上相邻的元素在物理存储位置上也相邻、可随机访问元素、存储密度高但插入和删除操作效率低等特点",
    "head": "访问",
    "tail": "插入",
    "head_offset": "28",
    "tail_offset": "39"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值，即第i层有2^(i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "递归基础的核心性质是存在某些初始情况或边界条件，在这些情况下递归函数可以直接给出结果而无需进一步递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "完全二叉树是深度为k的二叉树，除第k层外，其余各层的节点数都达到最大值，且第k层的节点都集中在该层最左边",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，使得从链表中的任何一个节点开始都可以遍历整个链表形成一个环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "完全二叉树是若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左右子树高度差的绝对值不超过1，并且左右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，若图为有向图则路径有方向，且在无向图中路径上边无方向而在有向",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "平衡二叉树的核心特征是树上任一结点的左子树和右子树的高度之差不超过1并且左子树和右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "根节点是树结构中的起始节点，它没有父节点且是树中其他节点的祖先节点，树中所有节点都直接或间接与根节点相连",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "平衡二叉树的核心特征是每个节点的左子树和右子树的高度差的绝对值不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，使得从链表中的任何一个节点出发都可以遍历整个链表形成一个环",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点间的关系通过边来表示，图分为有向图和无向图，有向图的边有方向，无",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的值大于或小于其子节点的值（大顶堆或小顶堆），且具有完全二叉树的特性",
    "head": "父节点",
    "tail": "完全二叉树",
    "head_offset": "15",
    "tail_offset": "44"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，若图为有向图则路径有方向，该序列中相邻顶点之间存在图的边或弧",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值，即第i层有2^(i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的节点是包含数据元素及若干指向子树的分支的基本结构且具有唯一的父节点（根节点除外）以及零个或多个子节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "满二叉树的核心特征是除最后一层无任何子节点外，每一层上的所有节点都有两个子节点，并且叶子节点都在最后一层",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的起始位置开始，依次逐个检查每个元素，直到找到目标元素或遍历完整个序列为止",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "43"
  },
  {
    "sentence": "在树形数据结构中，若存在节点A，对于节点B，若有从B到A的有向路径且B直接连接到A，那么A就是B的父节点",
    "head": "路径",
    "tail": "父节点",
    "head_offset": "31",
    "tail_offset": "49"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其核心特征为：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成的数据结构，顶点用于表示事物，边用于表示事物之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "二叉树遍历分为前序遍历、中序遍历和后序遍历，前序遍历是先访问根节点再递归访问左子树和右子树，中序遍历是先",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "有向图是一种图结构，由顶点集合和有向边集合组成，其中每条有向边是从一个顶点指向另一个顶点，具有明确的方向",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将关键字与线性表中的元素进行比较，直到找到匹配的元素或到达线性表的末尾",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "完全二叉树是若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "连通图是指在无向图中，若任意两个顶点之间都存在路径相通，则该无向图为连通图，对于有向图，若其基图为连通图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间逻辑关系的整体，它描述数据元素之间的关联方式而不考虑其在计算机中的存储表示",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层的节点数都达到最大值，即第i层有2^(i-",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "平衡二叉树的核心特征是树上任一节点的左子树和右子树的高度差不超过1，并且左子树和右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，描述了数据元素之间的关联方式和组织形式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "在树形数据结构中父节点是其下有子节点分支的节点且与子节点存在直接的层次关系即子节点是从该父节点衍生出来的",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "8",
    "tail_offset": "15"
  },
  {
    "sentence": "平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树",
    "head": "平衡二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "二叉树的每个节点最多有两棵子树，并且二叉树具有递归性，即它可以由根节点、左子树和右子树构成，左子树和右子",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，对于树中的每个结点，如果其结点编号i满足1≤i≤n，若i≤⌊n",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "穷举法通过对问题所有可能的情况逐一进行检验，从而找出符合条件的解，其核心性质是遍历所有可能情况以获取结果",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的值大于或小于其子节点的值的特性，且根节点的值是堆中的最大值或最小值",
    "head": "父节点",
    "tail": "根节点",
    "head_offset": "15",
    "tail_offset": "36"
  },
  {
    "sentence": "非线性结构中至少存在一个数据元素有两个或两个以上的前驱或后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其每一层的节点数都达到了该层所能容纳的最大值，即第i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的值大于或小于其子节点的值（大顶堆或小顶堆），且具有完全二叉树的形态",
    "head": "父节点",
    "tail": "完全二叉树",
    "head_offset": "15",
    "tail_offset": "44"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "有向图是一种由顶点集合以及顶点间的有向边集合组成的图结构，其中有向边是有方向的，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合所组成的数据结构，其中边是没有方向的，即顶点之间的连接是双向的",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "非线性结构是一种在数据元素之间存在一对多或多对多关系的数据结构，其元素的逻辑关系不再是简单的线性顺序关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "简单排序是对数据序列通过比较元素大小并逐步交换位置等方式将其按特定顺序（如升序或降序）排列的一种排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "顺序表是一种线性表，其核心性质为逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过数组下标直接访问元素",
    "head": "线性表",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "42"
  },
  {
    "sentence": "完全二叉树是深度为k的二叉树，除第k层外，其余各层的节点数都达到最大值，且第k层的节点都集中在该层最左边",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心特征是只允许在一端进行插入操作，而在另一端进行删除操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树",
    "head": "平衡二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，即度最大为2，并且二叉树具有递归结构，其左右子树也均为二叉树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构其中有向边是顶点的有序对表示从一个顶点指向另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针指向头节点，使得链表形成一个环，从而可以循环遍历链表中的所有节点",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其每一层上的节点数都达到最大值即2^(i-1)（",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "指针具有指向变量存储地址、可通过解引用访问所指对象、能灵活进行地址运算以在内存中高效定位和操作数据等特点",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "二叉树的遍历分为前序遍历中序遍历和后序遍历，前序遍历是先访问根节点再递归访问左子树和右子树，中序遍历是先",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间存在特定的逻辑关系且这些关系决定了数据的组织形式和操作方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件的初始情况其特点在于该初始情况能够直接给出问题的解而无需再次调用递归函数",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边组成的图，其中每条有向边都具有特定的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对表示从一个顶点到另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的地址，通过该指针可以间接访问和操作其所指向的内存位置的数据",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间缩小一半来查找特定元素，具有时间复杂度为对数级从而高效查找的特点",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树的特点的核心性质为：一棵深度为k且有2^k-1个结点的二叉树为满二叉树，其每一层上的结点数都达到",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "路径是图中顶点之间的边的序列，具有从起始顶点开始经一系列边可到达终止顶点的特点且路径长度为路径上边的数目",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "连通图是指在无向图中，若任意两个顶点之间都存在路径，则该无向图为连通图，在有向图中，若对于每一对顶点u和",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是深度为k的二叉树，除第k层外，其余各层的节点数都达到最大值，且第k层的节点都集中在该层最左边",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "加权图是一种图结构，其中图的每条边都被赋予一个数值作为权值，这些权值可表示诸如距离、成本、容量等某种度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "堆的核心性质是父节点的值大于或等于（大顶堆）其子节点的值，或者父节点的值小于或等于（小顶堆）其子节点的值",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "7",
    "tail_offset": "31"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机存储空间中的存储形式，包括数据元素的存储方式以及数据元素之间关系的存储方式",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "28"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机存储空间中的存储方式，包括数据元素的存储位置以及数据元素之间的关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "双向链表每个节点除了有指向下一节点的指针外还有指向前一节点的指针从而形成双向链接结构具有可双向遍历等特点",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值，即第i层有2^(i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，且顶点集不能为空，有向边集可以为空",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的节点的核心性质是每个节点有零个或多个子节点，有且仅有一个根节点，除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "归并排序是将一个无序数组不断地分成两个子数组分别递归排序，再把排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序查找是从数据序列的起始位置开始，依次逐个检查数据元素，直至找到目标元素或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，每条有向边从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的起始位置开始，依次逐个检查每个元素，直到找到目标元素或遍历完整个序列为止",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "43"
  },
  {
    "sentence": "邻接矩阵的核心性质是若图中有从顶点i到顶点j的边则邻接矩阵中第i行第j列元素值为1否则为0且主对角线元素",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "完全二叉树是深度为k的二叉树，除第k层外，其余各层的节点数都达到最大个数，第k层的节点都集中在该层最左边",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "有向图是一种由顶点集合及顶点间的有向边构成的图，其中每条有向边都具有特定的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "满二叉树的核心性质是一棵深度为k且有2^k-1个节点的二叉树，其每一层上的节点数都达到最大值，即第i层有",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "树的度是指一棵树中，最大的节点度，即节点拥有子树的数目，树中各节点度的最大值就是树的度，这是树的度的核心",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的起始位置开始，依次逐个检查每个元素，直到找到目标元素或遍历完整个序列为止",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "43"
  },
  {
    "sentence": "回路是在图中从一个顶点出发，沿着边经过若干个顶点后又回到该起始顶点的路径且路径中顶点不重复（除起始顶点）",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "子节点是树结构中直接位于某一节点下方的节点，它与父节点存在直接的层级关系，是父节点所衍生出来的下一级节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "无向图是一种图结构，其中边是没有方向的，即如果存在一条连接顶点u和顶点v的边，那么从u到v和从v到u是同",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，并重复此步骤直到整个数组都被排序好的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，对于图中的每个顶点，它都有一个链表，链表中存储了与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过一个统一的数组名和下标来唯一标识和访问这些元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "排序",
    "tail": "数据元素",
    "head_offset": "5",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径相连，在有向图中任意一对顶点之间都存在有向路径可相互到达的图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "邻接表的核心特征是用链表来表示图中顶点的邻接关系，每个顶点对应一个链表，链表中存储与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值，即第i层有2^(",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "满二叉树的核心特征是一棵深度为k且有2^k - 1个节点的二叉树，其每一层上的节点数都达到最大值，即第i层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "在树形结构中一个节点若存在直接的前驱节点且该前驱节点可引出包括此节点在内的子树则此前驱节点为此节点的父节点",
    "head": "前驱节点",
    "tail": "前驱节点",
    "head_offset": "16",
    "tail_offset": "22"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，其余节点分为若干互不相交的子树，每个子树也是一棵树且具有递归性质",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "17",
    "tail_offset": "34"
  },
  {
    "sentence": "图的边的核心特征是连接图中的两个顶点，它描述了顶点之间的关系，通过边可以在图中建立起顶点之间的路径和连通性",
    "head": "图的边",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "47"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "比较排序是一种排序算法，其核心特征是通过元素之间的比较来确定元素的相对顺序，从而将待排序序列转换为有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有如下性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值，即第i层有2^(",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，对于图中的每个顶点，它都有一个链表，链表中存储了与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "有向图是一种图结构，其中边具有方向，即从一个顶点指向另一个顶点，这是有向图区别于无向图的核心特征，在有向图",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素是图的顶点，关系集合中的元素是顶点之间的边",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "有向图的核心性质是其边具有方向性，即从一个顶点指向另一个顶点，这种方向性决定了图中顶点之间的关系和路径走向",
    "head": "有向图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "49"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有如下性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "深度为k有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时为完全",
    "head": "二叉树",
    "tail": "满二叉树",
    "head_offset": "10",
    "tail_offset": "31"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的值大于或小于其子节点的值（大顶堆或小顶堆），并且具有完全二叉树的结构",
    "head": "父节点",
    "tail": "完全二叉树",
    "head_offset": "15",
    "tail_offset": "45"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构包括一个根节点以及左子树和右子树并且左子树和右子树也都是二叉树",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的值大于或小于其子节点的值（大顶堆或小顶堆），并且具有完全二叉树的形态",
    "head": "父节点",
    "tail": "完全二叉树",
    "head_offset": "15",
    "tail_offset": "45"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有如下性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "平衡二叉树的核心特征是其每个节点的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，即度最大为2，并且二叉树具有递归的结构，其左右子树也均为二叉树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到了该层所能容纳的最大节点数",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "完全二叉树是这样一种二叉树，若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的节点的核心性质是每个节点有零个或多个子节点，且有一个特定的根节点，除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径，或者在有向图中对于每一对顶点u和v，都存在一条从u到v和从",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序表具有逻辑上相邻的元素在物理存储位置上也相邻、可以随机访问元素、存储密度高但插入和删除操作效率低等特点",
    "head": "访问",
    "tail": "插入",
    "head_offset": "29",
    "tail_offset": "40"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有从属于父节点的关系且在树的层级结构中有其特定位置",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，对于图中的每个顶点，它都有一个链表，链表中存储了与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边经过若干个顶点后又回到该顶点的路径且路径中除起点和终点外其他顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "完全二叉树是这样一种二叉树，若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "非线性结构是一种数据元素之间存在一对多或多对多关系的数据结构，其数据元素的逻辑关系不再是简单的线性顺序关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（若图是有向图则是有向顶点序列，若为无向图则可视为双向顶点序列）",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "加权图是一种图结构，其中图的每条边都被赋予一个数值作为权值，这些权值可以表示诸如距离、成本、时间等某种度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "满二叉树是深度为k且有2的k次方减1个节点的二叉树其中每一层上的节点数都达到最大值即该层节点数等于2的（该",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "完全二叉树是若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的节点的核心性质是每个节点有零个或多个子节点，且有且仅有一个根节点，除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，对于图中的每个顶点，它都有一个链表，链表中存储了与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点路径上的边数或节点数，其特点是在有根树中反映了树的层次结构和规模大小等情况",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图是指在无向图中，若任意两个顶点之间都存在路径相通，则该无向图为连通图，在有向图中，若对于每一对顶点u",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "邻接矩阵的核心性质是若图中有从顶点i到顶点j的边则邻接矩阵中第i行第j列元素为1否则为0且主对角线元素表示",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到最大值，即第i层有2^(i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成，其中有向边是顶点的有序对，其方向具有特定意义，不同于无向图中边的无方向性，",
    "head": "有向图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树的核心特征是：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，且任意两个节点间有唯一的一条路径",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边经过若干顶点后又回到该起始顶点的路径且路径中顶点不重复（除起始顶点外）",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "递归基础的核心特征是存在一种简单情况或终止条件，在此情况下递归函数直接返回一个确定的结果而不再进行递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "49"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，不断重复此操作直到整个数组都被排序好的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径，或者在有向图中对于每一对顶点u和v，都存在从u到v以及从v",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "集合是由确定的、互不相同的对象所组成的整体这些对象具有明确的确定性、互异性且组成集合的对象之间没有顺序要求",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数，它反映了树中节点层次结构的深度以及树的结构复杂程度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有如下性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树的节点的核心性质包括每个节点有零个或多个子节点、有且仅有一个根节点、除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值，即对于深度为i的层，",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "平衡二叉树或者是一棵空树，或者是具有下列性质的二叉排序树：它的左子树和右子树都是平衡二叉树，且左子树和右子",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值即第i层有2^(i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "图的顶点是图结构中的基本元素，是构成图的节点，用于表示图中的对象或实体，在有向图中顶点有入度和出度，在无向",
    "head": "图的顶点",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其每一层上的节点数都达到最大值即该层节点数为2^(",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "归并排序是将一个无序数组分成两个子数组分别递归进行排序后再将排序好的子数组合并成一个有序数组的一种排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "映射是一种具有特定对应关系的数据结构特点，对于集合A中的任意一个元素，在集合B中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "递归基础是递归算法中最简单的情况，通常是递归函数的终止条件，其核心特征是不需要再次调用自身就能直接得到结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "双向链表是一种链表结构，每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，从而可以双向遍历链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "连通图是指在无向图中，若任意两个顶点之间都存在路径相通，则该无向图为连通图，在有向图中，若对于每一对顶点u",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "穷举法是一种通过对问题所有可能情况逐一进行检验，从而找出符合条件的解的方法其特点在于遍历所有可能情况来求解",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "二叉树遍历分为前序遍历中序遍历和后序遍历，前序遍历是根左右，中序遍历是左根右，后序遍历是左右根，每种遍历都",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机存储器中的表示方式以及这种表示对数据操作和访问效率等方面的影响",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树的核心特征是一棵深度为k且有2^k - 1个节点的二叉树，其每一层上的节点数都达到最大值，即第i层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，表示从一个顶点到另一个顶点的单向连接",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，表示从一个顶点到另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半并根据目标值与中间元素的比较结果来确定目标值所在位置的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "父节点是在树形结构中，直接有一个或多个子节点连接于其下的节点，且在树的层级关系中处于比子节点更高一级的位置",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "二叉树的特点是每个节点最多有两棵子树，并且子树有左右之分，其定义涵盖了节点间的层次关系、遍历顺序等相关特性",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机存储器中的表示方式以及如何利用这种表示进行高效的存储和访问操作",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "连通图是指在无向图中，若任意两个顶点之间都存在路径，则该无向图为连通图，在有向图中，若对于每一对顶点vi和",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的节点的核心性质包括每个节点有零个或多个子节点、有且仅有一个根节点、除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "平衡二叉树的核心特征是其每个节点的左子树和右子树的高度差的绝对值不超过1并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过一个统一的数组名和下标来唯一标识和访问这些元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "在图论中，回路是指一条起始顶点与终止顶点相同的路径，且路径中除起始顶点与终止顶点可相同外，其余顶点均不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "5",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有如下性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "操作效率是指在数据结构中执行特定操作（如插入、删除、查找等）所花费的时间或资源的多少来衡量该操作的效率情况",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的第一个元素开始，依次逐个检查每个元素，直到找到目标元素或遍历完整个序列为止",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "44"
  },
  {
    "sentence": "平衡二叉树的核心性质是树上任一结点的左子树和右子树的高度之差不超过1，并且左子树和右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "加权图是一种图结构，其中图的每条边都被赋予一个数值作为权值，这些权值可以表示诸如距离、成本、容量等某种度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性查找的核心特征是从数据序列的第一个元素开始，依次逐个检查每个元素，直到找到目标元素或遍历完整个序列为止",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "44"
  },
  {
    "sentence": "完全二叉树的核心特征是：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "堆是一种特殊的完全二叉树，对于每个非叶子节点，其值都大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值",
    "head": "完全二叉树",
    "tail": "叶子节点",
    "head_offset": "7",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，其插入操作称为进栈，删除操作称为出栈，遵循后进先出的原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "完全二叉树的特点的核心性质是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个检查每个元素，直到找到目标元素或遍历完整个序列为止",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素顺序从而进行排序的算法其核心性质是通过比较元素大小来逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，表示从一个顶点到另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "无向图是一种图结构，其中边没有方向，即如果存在一条连接顶点u和顶点v的边，那么从u到v和从v到u是同一条边",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径，或者在有向图中对于每一对顶点u和v，都存在从u到v以及从v",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，表示从一个顶点到另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径，或者在有向图中对于每一对顶点u和v，都存在一条从u到v和从",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "连通图是指在无向图中，若任意两个顶点之间都存在路径相通，或者在有向图中，对于每一对顶点u和v，都存在从u到",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数，它反映了树的层次结构深度以及节点分布的最大层级跨度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过一个统一的数组名和下标来唯一标识和访问各个元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "路径是图中顶点与顶点之间的边所构成的序列，且具有有向路径与无向路径之分，有向路径的边有方向而无向路径的边无",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（对于有向图，路径是有向顶点序列，序列中相邻顶点之间存在边或弧）",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树的特点的核心性质是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，使得链表形成一个环，从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点集合不能为空，顶点间的关系集合可以为空，顶点间的关系是一种二元关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值即该层的节点数为2",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其每一层上的节点数都达到最大值，叶子节点都在最底层，且",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，表示从一个顶点到另一个顶点的单向连接",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，表示从一个顶点到另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者满足若其左子树非空则左子树上所有节点的值均小于根节点的值、若其右子树非空则右子树上",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层的节点数都达到最大值，即第i层有2^(i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值即2^(i-1)（",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "父节点是在树形结构中，其直接有一个或多个子节点与之相连，处于比子节点更高层次且具有一定层次关系和关联的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其每一层上的节点数都达到最大值即该层节点数为2^(",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树的节点的核心性质是每个节点有零个或多个子节点，且有一个特定的根节点，除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "有向图是一种图结构，由顶点集合和有向边集合组成，其中有向边是顶点的有序对，其方向是从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是顶点的有序对，表示从一个顶点到另一个顶点的单向关系",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆是一种特殊的完全二叉树，对于每个非叶子节点，其值都大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值",
    "head": "完全二叉树",
    "tail": "叶子节点",
    "head_offset": "7",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树的核心特征是：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点间的关系通过边来表示，图可以分为有向图和无向图，有向图的边有方向，",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "完全二叉树是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树遍历的定义的核心性质是先访问根节点再递归地访问左子树和右子树（前序遍历），或先递归地访问左子树再访问",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值，即第i层有2^(",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "数组是一种有序数据集合，其元素具有相同的数据类型，通过下标来唯一标识和访问，并且在内存中占用连续的存储空间",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的线性表",
    "head": "链表",
    "tail": "存储结构",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边连续移动，最终回到起始顶点的路径且路径中除起始顶点外其他顶点不重复经过",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是先进先出，即先进入队列的元素先出队列，它有队头和队尾，在队尾进行插入操作，",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "图的边是连接图中两个顶点的线其具有方向性或无方向性且在有向图中边有明确的起始顶点和终止顶点在无向图中边所连接",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两部分并依据目标值与中间元素的比较结果来确定目标值所在位置的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径，或者在有向图中对于任意两个顶点u和v，既存在从u到v的路径也",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的其他顶点信息",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "非线性结构中至少存在一个数据元素有两个或两个以上的前驱或后继且各数据元素之间的逻辑关系不能用线性序列简单描述",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是只允许在表的一端进行插入操作，而在另一端进行删除操作，具有先进先出的特性",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心性质是通过比较元素并交换不满足顺序要求的元素位置，逐步将无序序列转换为有序序列",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，可以通过下标来唯一地访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "图的边是连接图中两个顶点的线其具有方向或无方向且有权值或无权值不同类型的图边的具体特点根据图的类型如无向图边",
    "head": "图的边",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "50"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据具有快速查找平均时间复杂度接近常数的特点",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，对于树中的任一结点，若其序号i满足1≤i≤n，则其左孩子序号为2i",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有序集合，具有存储相同类型数据、元素有序排列且有固定存储位置和大小等核心性质",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数组是一种有序数据集合，其中的元素具有相同的数据类型，并且通过一个统一的数组名和下标来唯一标识和访问每个元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个元素与目标值进行比较，直到找到目标值或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "完全二叉树的核心性质是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "队列的核心特征是先进先出即元素按照进入队列的先后顺序依次从队列中取出排在前面的元素先出队排在后面的元素后出队",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "链表是一种通过指针将一组数据元素按顺序链接起来的数据结构，每个数据元素包含数据部分和指向下一个元素的指针部分",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次将每个元素与目标值进行比较，直到找到目标值或遍历完整个序列的查找方法",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "42"
  },
  {
    "sentence": "完全二叉树是深度为k的，有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "有向图是一种图结构，其边具有方向性，即从一个顶点指向另一个顶点，这是有向图区别于无向图的核心特征，通过有向边",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储表示形式，其核心性质包括数据元素的存储方式以及数据元素之间关系的表示方法",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "30"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有如下性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的元素在物理位置上也相邻的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "图的边是连接图中两个顶点的线或弧其表示顶点之间的某种关系并且在有向图中边具有方向无向图中边无方向且边可能具有",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "递归基础是递归算法中最简单情况的定义，通常是当问题规模减小到一定程度时可直接得出答案无需进一步递归调用的情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的键值大于或小于其子节点的键值（大顶堆或小顶堆），且具有完全二叉树的性质",
    "head": "父节点",
    "tail": "完全二叉树",
    "head_offset": "15",
    "tail_offset": "46"
  },
  {
    "sentence": "连通图是指在无向图中，若任意两个顶点之间都存在路径相通，或者在有向图中，对于任意两个顶点u和v，都存在从u到",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的元素在物理位置上也相邻的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "在树形结构中，根节点是没有前驱节点且唯一的起始节点，它位于树的顶部，是整棵树的核心，通过它衍生出树的其他节点",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "7",
    "tail_offset": "13"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心性质是通过比较元素并交换不满足顺序要求的元素位置来逐步将无序序列转变为有序序列",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "栈的核心特征是具有后进先出的特点，即最后进入栈的元素最先被取出，就像一个只允许在一端进行插入和删除操作的容器",
    "head": "插入",
    "tail": "删除",
    "head_offset": "44",
    "tail_offset": "47"
  },
  {
    "sentence": "图的核心性质包括顶点集合和边集合的存在，边是顶点的二元组表示顶点之间的关系，图可分为有向图和无向图，有向图的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "14"
  },
  {
    "sentence": "树的节点的核心性质是每个节点有零个或多个子节点，且有且仅有一个根节点，除根节点外的每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，可以通过下标来唯一地访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心特征是通过比较元素并交换不满足顺序要求的元素位置，逐步将无序序列转变为有序序列",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "满二叉树是深度为k且有2^k - 1个节点的二叉树，其每一层的节点数都达到最大值，叶子节点都在最底层，且每个",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "无向图是一种图结构其中任意两个顶点之间的边没有方向即若存在连接顶点u和顶点v的边则从u到v和从v到u是同一条",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "路径是由顶点和相邻顶点序偶构成的边所形成的序列，其具有有向性或无向性，有向路径顶点序列中相邻顶点的顺序与边的",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其每一层上的节点数都达到最大值，即每一个节点要么有两个子",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "堆是一种优先队列数据结构，它满足堆序性质，即父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值",
    "head": "队列",
    "tail": "父节点",
    "head_offset": "6",
    "tail_offset": "22"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问距离起始节点较近的节点，直到遍历完所有节点或找到目标节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度，即树中一个结点的子树个数的最大值决定了树的度，它反映了树中各结点拥有子树",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "14",
    "tail_offset": "26"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径，即从图中任何一个顶点出发都可以通过一系列边到达其他任何顶点",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次循环访问",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "二叉树遍历包括前序遍历中序遍历和后序遍历 前序遍历是根左右 中序遍历是左根右 后序遍历是左右根 不同遍历方式",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "线性查找是在一个给定的数据序列中从第一个元素开始依次逐个检查元素，直至找到目标元素或遍历完整个序列的查找方法",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "42"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由节点组成每个节点包含数据域和指针域指针域指向下一个节点从而形成一个节点序列",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（若图为有向图则路径有方向，从起始顶点按边的指向到终止顶点，若为无",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，可以通过下标来访问和操作每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其中每一层上的节点数都达到最大值，即对于深度为i的节点，",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "无向图是由顶点集和边集组成的一种图结构其中边集是顶点集元素的无序对集合且任意一条边连接两个顶点不存在方向区别",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "邻接矩阵是用一个二维数组来表示图中顶点之间邻接关系的矩阵，对于有n个顶点的图，其邻接矩阵是一个n×n的矩阵，",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树的核心性质是树上任一节点的左子树和右子树的高度差的绝对值不超过1且左子树和右子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构，通过构建初始堆、交换堆顶元素与末尾元素并调整堆来逐步将无序数组排序的排序算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树中各节点度的最大值就是树的度树中每个节点的度都小于或等于树的度不同类型的树其度有不同特点如二叉树度最大为2",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "12",
    "tail_offset": "29"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "完全二叉树的核心性质是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中n为表长，当n = 0时线性表为空表，且线性",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "有向图是由顶点集合及顶点间的有向边构成的一种图，其边具有方向性，从一个顶点指向另一个顶点，与无向图不同，有向",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其每一层上的节点数都达到最大值，即每一个节点要么有两个子",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "集合是由确定的、互不相同的对象所组成的整体，其中确定的对象构成集合的元素，这些元素具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "在图中，从一个顶点出发，沿着边经过一些顶点后又回到该顶点的路径（路径中顶点不重复，除起点和终点相同）称为回路",
    "head": "路径",
    "tail": "路径",
    "head_offset": "29",
    "tail_offset": "32"
  },
  {
    "sentence": "插入排序的核心性质是将未排序数据插入到已排序序列的合适位置，通过依次对数组中的元素进行操作，使得数组逐渐有序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示与该边相关的某种代价、距离、成本或其他数值度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度其核心特征为树中各结点度的数值情况决定了树的度且该度是所有结点度中的最大值",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "14",
    "tail_offset": "37"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次循环访问",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，对于一个具有n个顶点的图，其邻接矩阵是一个n×n的矩阵，若图中顶点i和顶点j之间",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "树的节点是树结构中的基本组成部分具有一个数据元素以及零个或多个指向子节点的指针用于表示树的层次关系和数据组织",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素的存储方式、数据元素之间的逻辑关系的表示方法以及数据元素的操作方式等方面",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点，其特点包括处于树的最底层、没有分支向外延伸、是数据或信息的最终存储位置等",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径，或者在有向图中对于任意两个顶点u和v，既存在从u到v的路径也",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中位于顶端没有父节点的特殊节点，它是整个树结构的起始点且具有特殊地位用于标识和组织树中其他节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "图的边是连接图中两个顶点的元素，其特点包括具有方向性（有向图的边有明确方向，无向图的边无方向）、有权重属性（",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "连通图是指在无向图中，若任意两个顶点之间都存在路径相通则该无向图为连通图，在有向图中若任意两个顶点之间都存在",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "简单排序具有比较和交换元素位置以逐步将无序序列转化为有序序列的特点其核心性质是通过多次比较和交换操作实现排序",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "52"
  },
  {
    "sentence": "迭代法的核心特征是通过不断重复执行相同的计算步骤，利用上一次迭代的结果来计算下一次迭代的值，逐步逼近问题的解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边经过若干顶点后又回到该顶点的路径且路径中顶点不重复（除起点和终点相同外）",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "集合的核心特征是具有确定性、互异性和无序性，其中确定性是指给定一个集合，任何一个对象是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间缩小一半，比较目标值与中间元素，以确定目标值是否存在及所在位置的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，可以通过下标来唯一地访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "邻接矩阵的核心性质是若图G有n个顶点，其邻接矩阵A中元素A[i][j]的值表示顶点i到顶点j是否有边相连，若",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，可以通过下标来唯一地访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，如果顺序错误就把它们交换过来，不断重复此操作直到整个数组都被排序好的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "迭代法的核心特征是通过不断重复执行相同的计算步骤，利用上一次迭代的结果来计算下一次迭代的值，逐步逼近问题的解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "无向图是一种图结构其中任意两个顶点之间的边没有方向即若存在连接顶点u和顶点v的边则从u到v和从v到u是同一条",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心性质是只允许在表的一端进行插入操作，而在另一端进行删除操作，遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k-1个节点的二叉树，其每一层上的节点数都达到最大值，即每一个节点要么有两个子",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "连通图是指在无向图中，任意两个顶点之间都存在路径相通，或者在有向图中，对于每一对顶点u和v，都存在一条从u到",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序表的核心性质是其逻辑上相邻的元素在物理存储位置上也相邻，且可以通过下标直接访问元素，时间复杂度为O(1)",
    "head": "访问",
    "tail": "时间复杂度",
    "head_offset": "39",
    "tail_offset": "44"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，它具有特定的取值范围、表示形式和相关操作规则等特点",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，对于树中的任一结点，若其序号i满足1≤i≤n，则其左孩子序号为2i",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次将每个元素与目标值进行比较，直到找到目标值或遍历完整个序列的查找方法",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "42"
  },
  {
    "sentence": "完全二叉树的核心性质是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的元素在物理位置上也相邻的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有直接受父节点关联、处于树状层级结构中较低位置等特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "队列是一种先进先出的线性数据结构，其特点是元素按照进入的顺序依次存储，在进行操作时，先进入队列的元素先被取出",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "二叉树遍历分为前序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根），前序遍历先访问根节点再递归访问左右",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "连通图是指在无向图中，任意两个顶点之间都存在路径相通，或者在有向图中，对于每一对顶点u和v，都存在一条从u到",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历分为前序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根），前序遍历先访问根节点再递归访问左右",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "无向图是一种图结构其中任意两个顶点之间的边没有方向即若顶点u和顶点v之间存在边则从u到v和从v到u是同一条边",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树的核心性质是若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其特点为：若图中有n个顶点，则矩阵为n阶方阵，矩阵元素为0或1，无向图中矩阵",
    "head": "邻接矩阵",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "数据的逻辑结构的特点是数据元素之间存在的一种逻辑关系，它独立于数据的存储方式且描述了数据元素间抽象的相互关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "11"
  },
  {
    "sentence": "邻接矩阵是表示图的一种矩阵，对于一个具有n个顶点的图，其邻接矩阵是一个n×n的矩阵，若顶点i到顶点j有边相连",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，其插入操作被称为进栈，删除操作被称为出栈，遵循后进先出的原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "连通图是指在无向图中，若任意两个顶点之间都存在路径能够相连，或者在有向图中，对于任意两个顶点u和v，既存在从u",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是一种图结构，其中任意两个顶点之间的边没有方向，即若存在一条连接顶点u和顶点v的边，则从u到v和从v到u",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的物理结构的核心性质包括数据元素在计算机中的存储方式以及数据元素之间的逻辑关系如何通过存储结构来体现等方面",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "冒泡排序比较相邻元素大小，将较大元素交换到右侧，每一轮把最大元素“冒泡”到数组末尾，重复此过程直到整个数组有序",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "数组的核心性质是具有相同数据类型的一组数据元素按顺序存储在连续的内存空间中，可以通过下标来唯一地访问其中的元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值，即对于深度为i的节点",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "图的边是连接图中两个顶点的线，它表示顶点之间的某种关系，且边具有方向或无方向之分，在有向图中边有明确的起始顶点",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "栈是一种特殊的数据结构，其核心特征为后进先出，即最后进入栈中的元素会最先被取出，且只能在栈顶进行插入和删除操作",
    "head": "插入",
    "tail": "删除",
    "head_offset": "48",
    "tail_offset": "51"
  },
  {
    "sentence": "树的节点包含数据元素以及指向子节点的指针且根节点没有前驱节点其余节点有唯一前驱节点每个节点可有零个或多个子节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "满二叉树的核心性质是每一层上的节点数都达到最大值，即如果满二叉树的深度为k，那么它的节点总数为2^k - 1，",
    "head": "满二叉树",
    "tail": "满二叉树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "二叉树遍历的定义的核心性质包括先序遍历是先访问根节点再递归访问左子树和右子树，中序遍历是先递归访问左子树再访问",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者一棵具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "抽象数据类型是一个数学模型以及定义在该模型上的一组操作，其强调数据的逻辑结构和相关操作而不依赖于具体的实现细节",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "顺序表的核心性质是其逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过下标直接访问元素，时间复杂度为O(1)",
    "head": "访问",
    "tail": "时间复杂度",
    "head_offset": "40",
    "tail_offset": "45"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层的节点数都达到最大值，即如果该二叉树的深度为h，那么它的节点总数为2^h - 1",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树遍历分为前序遍历中根节点先访问左右子树随后访问，中序遍历左子树先访问根节点再访问右子树，后序遍历左右子树",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树中各节点度的最大值即为树的度，且树中不同节点的度可能不同，度为0的节点是叶子节点，度不为0的节点为分支节点，",
    "head": "树的度",
    "tail": "叶子节点",
    "head_offset": "12",
    "tail_offset": "37"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值，即对于深度为i的节点",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "数据的逻辑结构的特点是反映数据元素之间逻辑关系且与数据的存储无关包括集合结构线性结构树形结构图状结构等不同类型",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，其中顶点集合不能为空，顶点间的关系集合描述了顶点之间的连接方式",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "循环链表的核心性质是其尾节点的指针指向头节点从而形成一个环形结构使得链表中各个节点可以依次遍历且没有明确的终点",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间抽象化的相互关系，它不考虑数据在计算机中的存储方式，仅关注数据元素之间的逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "非线性结构的核心特征是存在至少一个数据元素有不止一个前驱元素或不止一个后继元素或者元素之间的关系不满足线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素以及指向后继节点的指针，通过头节点可顺序访问链表中的各个节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针从而形成双向链接关系",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接矩阵的核心性质是其元素表示图中顶点之间是否存在边，若顶点\\(i\\)与顶点\\(j\\)之间有边相连，则邻接矩阵",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组，分别对两个子数组进行排序，然后将排序好的子数组合并成一个有序数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "无向图是一种图结构，其中边没有方向，任意两个顶点之间的边是双向的，即若存在连接顶点u和顶点v的边，则从u到v和",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "完全二叉树是深度为k的具有n个结点的二叉树，若其中每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中所有节点度的最大值就是树的度，树的度的核心特征是反映树中节点拥有子树",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "32"
  },
  {
    "sentence": "无向图是一种图结构，其中边没有方向，任意两个顶点之间的边是双向的，即若顶点u和顶点v之间存在边，则从u到v和从",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有序集合，这些元素在内存中按顺序存储，可以通过下标来访问和引用数组中的各个元素",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆排序是利用堆这种数据结构所具有的父节点大于或等于子节点（大顶堆）或父节点小于或等于子节点（小顶堆）的性质，将",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（若图为有向图则路径有方向，从起始顶点按边的方向到达终止顶点，若为无",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "循环链表是一种链表结构，其尾节点的指针域指向头节点，从而形成一个环，使得从链表中的任意节点出发都能遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树遍历的定义的核心性质包括先序遍历是先访问根节点再递归访问左子树和右子树，中序遍历是先递归访问左子树再访问",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "满二叉树的核心性质是每一层上的节点数都达到最大值，即如果满二叉树的深度为k，那么它的节点总数为2^k - 1，",
    "head": "满二叉树",
    "tail": "满二叉树",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "简单排序是对一组数据按照特定规则依次比较元素大小并进行交换或移动操作以实现从小到大或从大到小有序排列的排序方法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，其插入操作被称为进栈，删除操作被称为出栈，遵循后进先出的原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层的节点数都达到最大值，即如果该满二叉树的深度为h，则其节点总数为2^h - 1，",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "子节点是树结构中直接位于某一节点下方的节点，具有与父节点通过特定的边相连且是该父节点所关联的下一层级节点的特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的键值大于或小于其子节点的键值（大顶堆或小顶堆），并且具有完全二叉树的特性",
    "head": "父节点",
    "tail": "完全二叉树",
    "head_offset": "15",
    "tail_offset": "47"
  },
  {
    "sentence": "数据的逻辑结构的定义的核心特征是数据元素之间逻辑关系的描述，它独立于数据的存储结构，反映数据元素之间的内在联系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "16"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，可通过下标来唯一标识和访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "二叉树遍历的定义的核心性质包括先序遍历是先访问根节点再递归访问左子树和右子树，中序遍历是先递归访问左子树再访问",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "无向图是由顶点集和边集组成，其中边集是顶点集的无序对集合，顶点集中的元素称为顶点，边集中的元素是顶点的无序对，",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "树的核心性质是树中任意两个节点有且仅有一条路径相连且树无回路并且有一个特定节点（根节点）到其他节点都有唯一路径",
    "head": "路径",
    "tail": "回路",
    "head_offset": "21",
    "tail_offset": "28"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解路径，在搜索过程中不断回溯以避免无效路径，从而找到问题最优解或所有解的算法策略",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点之间通过边相连，边可以具有方向或无方向，可用于表示各种复杂的关系和结构",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件的初始情况或终止条件，在此情况下递归函数不再调用自身而是直接返回一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "连通图的核心特征是图中任意两个顶点之间都存在路径，即从图中任何一个顶点出发，都能够通过一系列边到达其他所有顶点",
    "head": "连通图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "顺序查找是从数据结构的一端开始，依次将数据元素与给定值进行比较，直到找到匹配元素或遍历完整个数据结构的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权值，这些权值可以表示诸如距离、成本、容量等具有实际意义的量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图的边是连接图中两个顶点的元素，它表示顶点之间的某种关系，并且具有方向（有向图）或无方向（无向图）的属性，通过",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环，从而可以循环遍历链表中的所有节点",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它通常满足父节点的值大于或小于其子节点的值（大顶堆或小顶堆），并且具有完全二叉树的结构",
    "head": "父节点",
    "tail": "完全二叉树",
    "head_offset": "17",
    "tail_offset": "47"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径其核心特征是存在从某个顶点出发经过若干边后又回到该顶点的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "无向图是一种图结构，其中边没有方向，任意两个顶点之间的边是双向的，即若顶点u和顶点v之间存在边，则从u到v和从",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，再逐渐访问距离更远节点的数据结构遍历算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "堆是一种特殊的完全二叉树，它满足对于每个非叶子节点，其值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值",
    "head": "完全二叉树",
    "tail": "叶子节点",
    "head_offset": "7",
    "tail_offset": "21"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，它可以用来表示各种实际对象，且在图中通过边与其他顶点相连接以构成图的拓扑结构",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针从而形成双向链接关系",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "存储结构定义的核心性质包括数据元素在计算机内存中的存储方式以及它们之间的逻辑关系如何通过存储方式得以体现等方面",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "路径的核心性质是由一系列节点按照一定顺序依次连接而成，相邻节点之间存在特定的连接关系且路径具有明确的起点和终点",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "堆排序的核心特征是将数组构建成一个堆，分为大顶堆和小顶堆，大顶堆中每个节点的值大于或等于其子节点的值，小顶堆中",
    "head": "堆排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和相关操作而不涉及具体的存储表示",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "回路是数据结构中从一个顶点出发，沿着边经过若干顶点后又回到该起始顶点的路径且路径上除起始顶点外其余顶点均不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，其中顶点集合不能为空，顶点间的关系集合描述了顶点之间的连接方式",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树遍历的核心特征包括先序遍历是先访问根节点再递归访问左子树和右子树，中序遍历是先递归访问左子树再访问根节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "连通图是指在无向图中，任意两个顶点之间都存在路径能够相连，或者在有向图中，对于任意两个顶点u和v，既存在从u到",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序查找的核心性质是从数据序列的第一个元素开始，依次逐个比较元素值与目标值，直到找到目标值或遍历完整个数据序列",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其核心特征是：若图中有n个顶点，则邻接矩阵是一个n×n的方阵，对于无向图，矩阵",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（对于有向图是有向顶点序列），该序列中顶点依次相邻且边存在（有向图中",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（对于有向图，路径是有向边的序列），序列中顶点相邻且边存在（对于有向",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "哈希表的核心性质是通过哈希函数将键映射到特定位置以实现快速数据查找插入删除操作且平均情况下时间复杂度为常数时间",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "图的边是连接图中顶点的线，具有方向性或无方向性，每条边都与两个顶点相关联，边的集合确定了图的结构和连通性等性质",
    "head": "图的边",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "邻接矩阵是表示顶点之间相邻关系的矩阵，若图中有n个顶点，则邻接矩阵是一个n×n的方阵，对于无向图，矩阵中第i行",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "归并排序的核心特征是将一个无序数组分成两个子数组分别进行排序，然后将两个已排序的子数组合并成一个最终的有序数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层的节点数都达到最大值，即第k层有2的k减1次方个节点，并且所有叶子节点都在同一层",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆排序是利用堆这种数据结构所具有的父节点大于或等于子节点（大顶堆）或父节点小于或等于子节点（小顶堆）的性质，将",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中所有节点的度的最大值称为树的度，树的度的核心特征是反映树中节点拥有子",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "33"
  },
  {
    "sentence": "循环链表的核心性质是表尾节点的指针域指向表头节点从而形成一个环使得从链表中的任意一个节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层的节点数都达到最大值，即如果该满二叉树的深度为k，则其节点总数为2^k - 1，",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "存储结构定义的核心特征是数据元素在计算机存储器中的存储方式，包括数据元素自身值的表示以及数据元素之间关系的表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "满二叉树的核心特征是一棵深度为k且有2^k-1个节点的二叉树，并且每一层上的节点数都达到最大值，即对于深度为i",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，对于有\\(n\\)个顶点的图，其邻接矩阵是一个\\(n\\times n\\)的矩阵，若图",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "简单排序是对数据序列进行排序的一种方式其核心性质是通过比较和交换元素位置逐步将数据序列从无序状态转变为有序状态",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "快速排序的核心性质是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "在图论中，回路是指从图中某一顶点出发，沿着边连续移动，经过若干顶点后又回到该起始顶点且路径中各边互不相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "5",
    "tail_offset": "43"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，且任意两个节点间有且仅有一条路径相连",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "数组是具有相同数据类型的一组数据元素的集合，这些元素在内存中按顺序存储，通过下标可以唯一地访问数组中的每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树的二叉排序树",
    "head": "平衡二叉树",
    "tail": "树的高度",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉树遍历的核心特征包括先序遍历是先访问根节点再递归访问左子树和右子树，中序遍历是先递归访问左子树再访问根节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "递归基础的核心性质是存在某些特定的简单情况或初始条件，在这些情况下递归函数可以直接给出结果而无需进一步递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "非线性结构是一种数据元素之间存在一种或多种非简单的线性关系的数据结构，即数据元素之间的关系不是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "栈的核心特征是后进先出即最后进入栈的元素最先被弹出，且栈具有特定的操作方式如入栈将元素添加到栈顶出栈从栈顶移除",
    "head": "栈",
    "tail": "入栈",
    "head_offset": "27",
    "tail_offset": "38"
  },
  {
    "sentence": "有向图是由顶点集合及顶点间的有向边构成的一种图，其边是有方向的，即从一个顶点指向另一个顶点，顶点之间的连接具有",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层的节点数都达到最大值，即第k层有2^(k-1)个节点，并且叶子节点都在最后一层，",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到相等的元素或遍历完整个线性表为止",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件的初始情况或边界条件，在该条件下递归函数不再调用自身而是直接返回一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "快速排序的核心性质是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称其核心特征为具有特定取值范围且有针对这些取值的相关操作",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或者遍历完整个线性表为止",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历的核心特征包括先序遍历是先访问根节点再递归访问左子树和右子树，中序遍历是先递归访问左子树再访问根节点",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "满二叉树是一棵深度为k且有2^k - 1个节点的二叉树，其中每一层上的节点数都达到最大值，即对于深度为i的节点",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素在计算机内存中的存储方式以及它们之间的逻辑关系如何通过物理存储来体现等方面",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间路径，在搜索过程中不断检查和排除不符合条件的路径，以找到问题的解的算法策略",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树是一种非线性的数据结构它有一个根节点且根节点可以有零个或多个子节点每个子节点又可以有零个或多个子节点以此类推",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "20"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，其余节点分为若干互不相交的子树，每个子树也是一棵树且具有递归结构特点",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "17",
    "tail_offset": "34"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，从一个初始估计值出发，通过重复执行相同的计算步骤逐步逼近问题真实解的方法",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，其前提是数组必须有序",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长路径上的边数或节点数所表示的数值，它反映了树的结构层次深度，不同树的高度因",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是一种图结构，其中边没有方向，即如果存在一条连接顶点A和顶点B的边，那么从顶点A到顶点B和从顶点B到顶点A",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点所经过的最长路径上的边数或节点数，其核心特征在于体现了树从根到叶的最长延伸距离，",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层的节点数都达到最大值，即如果二叉树的深度为k，那么该满二叉树的节点总数为2^k -",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组，对这两个子数组分别进行排序，再将排序好的子数组合并成一个有序的数组的排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，这些权重可以表示诸如距离、成本、容量等各种与边相关的信息",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将关键字与表中元素进行比较，直到找到与关键字相等的元素或遍历完整个表的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈的核心特征是后进先出即最后进入栈的元素最先被弹出栈，并且栈的操作主要集中在栈顶进行包括入栈操作将元素压入栈顶和",
    "head": "出栈",
    "tail": "入栈",
    "head_offset": "24",
    "tail_offset": "44"
  },
  {
    "sentence": "树的查找是在给定的树结构中，根据特定的条件或键值，从根节点开始，按照树的遍历规则逐步寻找满足条件的节点的操作过程",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "26"
  },
  {
    "sentence": "回路是在图中从一个顶点出发，沿着边经过若干顶点后又回到该起始顶点所形成的路径且路径中各顶点和边均不重复（在有向图",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "图的顶点是图结构中的基本元素，是组成图的节点，用于表示图中的对象或实体，在有向图或无向图中具有标识作用且与边相关",
    "head": "图的顶点",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长路径到最远叶子节点所经过的边的数目加1（若根节点为第0层则是最长路径上节点的最大",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置，通过依次对每个元素进行这样的操作，最终使整个数组有序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，将最大（或最小）元素逐步“冒泡”到数组末尾（或开头）的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "树中各节点度的最大值就是树的度，树的度反映了树中节点分支情况的最大程度，它体现了树结构的复杂程度，不同树的度各不",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "12",
    "tail_offset": "16"
  },
  {
    "sentence": "无向图是一种图结构，其中边没有方向，顶点之间的连接是对称的即若存在从顶点u到顶点v的边则必然存在从顶点v到顶点u",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，其中n≥0，当n=0时为空表，相邻元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它不仅要存储数据元素本身的值，还要存储数据元素之间的逻辑关系",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，描述了数据元素之间的相互关系以及数据的组织形式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "栈的核心特征是后进先出即最后进入栈的元素最先被弹出，且操作主要集中在栈顶进行包括入栈操作将元素压入栈顶和出栈操作",
    "head": "入栈",
    "tail": "入栈",
    "head_offset": "40",
    "tail_offset": "48"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，对于树中的每个结点，如果其序号i满足1≤i≤n，且i>1时其父结点序号",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其核心性质为对于一个具有n个顶点的图，邻接矩阵是一个n×n的矩阵，若顶点i与顶点",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左子树和右子树都是一棵平衡",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性表是一种由有限个数据元素组成的序列，其中每个元素都有唯一前驱和后继（除第一个元素无前驱，最后一个元素无后继）",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "集合是由确定的、互不相同的对象所组成的整体这些对象具有明确的定义使得对于任何一个对象都能明确判断它是否属于该集合",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "54"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，对于有\\(n\\)个顶点的图，其邻接矩阵是一个\\(n\\times n\\)的矩阵，若顶点",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件的初始情况，通常是问题规模足够小以至于可以直接得出结果而无需进一步递归调用的情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有如下性质的二叉树：若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树是一种非线性数据结构，它由n（n≥0）个有限节点组成，包含一个根节点，且每个节点有零个或多个子节点，除根节点外",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "32",
    "tail_offset": "47"
  },
  {
    "sentence": "循环链表的核心性质是表尾节点的指针域指向表头节点从而形成一个环形结构使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的查找的特点的核心特征是基于树的层次结构从根节点开始按照特定规则逐层或分支遍历节点以确定目标元素是否存在于树中",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "22"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机存储器中的表示方式以及如何利用这种表示方式来高效地进行数据处理和操作",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它包含数据元素的表示以及数据元素之间关系的表示这两个核心特征",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "在图论中，回路是指从图中某一顶点出发，沿着边连续移动，经过若干个顶点后又回到该起始顶点且路径中各边互不相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "5",
    "tail_offset": "44"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，使得整个链表形成一个环，从而可以从链表中的任意节点开始遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径可相互到达且在有向图中任意两个顶点之间都存在有向路径可相互到达的图",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（对于有向图是有向顶点序列），且相邻顶点之间存在边（对于有向图存在有向",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，从而可以双向遍历链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是从数据序列的一端开始，依次将每个数据元素与目标值进行比较，直到找到目标值或遍历完整个数据序列的查找方式",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "21"
  },
  {
    "sentence": "树的查找的特点的核心性质包括若树为空则查找失败，若树非空则将给定值与根节点值比较，若相等则查找成功，若小于根节点",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "19"
  },
  {
    "sentence": "双向链表是一种数据结构，每个节点除了包含数据域外还包含两个指针域，分别指向前驱节点和后继节点从而形成双向链接关系",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机的存储结构，反映数据元素之间的逻辑关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "图由顶点集和边集组成顶点之间通过边相连且边具有方向性或无方向性边可有权重或无权重具有邻接关系且图可分为有向图无向",
    "head": "图",
    "tail": "有向图",
    "head_offset": "47",
    "tail_offset": "51"
  },
  {
    "sentence": "堆排序的核心性质是利用堆这种数据结构，堆分为大顶堆和小顶堆，大顶堆中每个节点的值都大于或等于其子节点的值，小顶堆",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据的逻辑结构的核心性质是数据元素之间的逻辑关系，它独立于数据的存储方式，描述了数据元素之间的关联方式和组织形式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "单链表的核心性质是每个节点包含一个数据元素以及一个指向下一个节点的指针，通过指针依次连接各个节点从而形成链表结构",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的查找的核心特征是从树的根节点开始，按照特定规则沿着树的分支路径逐步比较节点的值，以确定目标元素是否存在于树中",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者满足若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值，若它的右子树不空，则右",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层的节点数都达到最大值，即如果二叉树的深度为k，那么该满二叉树的节点总数为2^k -",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，或数据元素之间的关系不是一对一的",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素在计算机存储空间中的存储方式，包括数据元素自身的表示以及数据元素之间关系的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "树中一个节点的子树个数称为该节点的度，树中所有节点的度的最大值称为树的度，树的度体现了树中节点分支情况的最大程度",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "33"
  },
  {
    "sentence": "在图论中，回路是指从图中某一顶点出发，沿着边连续移动，经过若干个顶点后又回到该起始顶点且路径中各边互不相同的路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "5",
    "tail_offset": "44"
  },
  {
    "sentence": "图的顶点是图结构中的基本元素，是组成图的各个节点，在有向图或无向图中具有标识和与其他顶点通过边相连的关系以构成图",
    "head": "图的顶点",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "完全二叉树是一种二叉树，它的叶子节点只会出现在最下层和次下层，且最下层的叶子节点集中在树的左部，若设二叉树的深度",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数组是一种有序数据集合，其中的元素具有相同的数据类型，并且可以通过一个统一的数组名和下标来唯一标识和访问每个元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "邻接矩阵的核心性质是若图中存在从顶点i到顶点j的边则邻接矩阵中对应元素为1否则为0且主对角线元素对应顶点到自身的",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点路径上经过的边数或节点数，它体现了树在垂直方向上的深度和层次结构，不同类型的树其",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素，具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "无向图是一种图结构，其中边没有方向，即如果存在一条连接顶点A和顶点B的边，那么从顶点A到顶点B和从顶点B到顶点A",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素，具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性，通过从根节点开始按照特定规则比较节点值来确定目标元素是否存在于树中以及其所在位置",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "19"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，直至找到目标节点或遍历完所有节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "循环链表的核心性质是其尾节点的指针指向头节点从而形成一个环形结构使得链表中各个节点能够依次相连形成一个封闭的循环",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的查找的特点的核心性质是通过对树中节点的比较和遍历，利用树的层次结构和节点间的关系来确定目标元素是否存在于树中",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "24"
  },
  {
    "sentence": "单链表的核心性质是每个节点包含一个数据元素以及一个指向下一个节点的指针，通过指针依次连接各个节点从而形成线性序列",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，是树中所有其他节点的祖先，具有独一无二性且在树的层次结构中处于最高层位置",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "无向图是一种图结构，由顶点集合及顶点间的边集合组成，其中边是没有方向的，即若顶点vi和vj之间存在边，则从vi到",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者满足若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值，若它的右子树不空，则右",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，不同数据类型具有不同取值范围、存储方式、操作集合等特点",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，描述了数据元素之间的关联方式以及数据的组织形式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "线性查找是在一个数据序列中从第一个元素开始，依次逐个检查每个元素，直到找到目标元素或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "42"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其核心特征是元素的插入和删除操作都在栈顶进行，新元素入栈后成为栈顶元素，而栈顶元素出",
    "head": "插入",
    "tail": "删除",
    "head_offset": "23",
    "tail_offset": "26"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点所经过的最长路径上的边数，其核心特征是反映了树从根到叶子节点的最长距离度量",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，并且可以通过下标来唯一地访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其核心性质为元素的插入和删除操作都在栈顶进行，新元素入栈后成为栈顶元素，而栈顶元素出",
    "head": "插入",
    "tail": "删除",
    "head_offset": "23",
    "tail_offset": "26"
  },
  {
    "sentence": "无向图的核心特征是由顶点集合和边集合组成，其中边是没有方向的，即如果顶点u和顶点v之间存在一条边，那么从u到v和",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉树遍历的核心性质是前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归访问左子树再访问根节点最后递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其特点是除了最后一层外，每一层上的节点数都是满的，并且最后一层上的节点都集中在该层",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点下方的节点，具有比父节点更低的层级且可能存在多个兄弟节点与之共同构成树的结构层次",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次将每个数据元素与目标值进行比较，直到找到目标值或遍历完整个序列的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "23"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层的节点数都达到最大值，即除最后一层无任何子节点外，每一层上的所有节点都有两个子节点",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据从而能在平均常数时间内进行查找插入和删除操作",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点间的关系通过边来表示，图中的边可以是有向边或无向边，并且图中顶点个数可以",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或者遍历完整个线性表为止",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础的核心特征是存在一种能使递归过程结束的条件，在该条件满足时递归不再继续调用自身而是直接返回一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "递归基础的核心特征是存在一个或多个明确的终止条件，在这些条件下递归过程不再继续调用自身而是直接返回一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "子节点是树状结构中直接连接在父节点下方的节点，具有在特定层级关系中位于父节点之后且与父节点存在明确连接关系等特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，且是树中所有其他节点的祖先，树中的所有节点都直接或间接与根节点相连",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点所经过的最长路径上的边数或节点数（不同定义方式下），其核心特征为体现树中从",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础具有明确的终止条件，是递归算法中最简单的情况，在此情况下递归函数直接返回一个确定的结果而不再进行递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其特点是除了最后一层外，每一层上的节点数都是满的，并且最后一层上的节点都集中在该层",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "堆是一种优先队列数据结构，其特点是每个节点的值大于或等于其子节点的值（最大堆）或小于或等于其子节点的值（最小堆）",
    "head": "队列",
    "tail": "堆",
    "head_offset": "6",
    "tail_offset": "37"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加至最深叶节点所经过的层数，且从根节点到该叶节点的路径上的节点数即为树的深度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件的初始情况，通常是问题规模最小或最简单时可直接得出结果而无需进一步递归调用的情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "递归基础的核心特征是存在一个或多个明确的终止条件，在这些条件下递归过程不再继续调用自身而是直接返回一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，并且可以通过下标来唯一地访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序的核心性质是利用堆这种数据结构，堆分为大顶堆和小顶堆，大顶堆中每个节点的值都大于或等于其子节点的值，小顶堆",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "循环链表的核心性质是其尾节点的指针指向头节点从而形成一个环形结构使得链表中节点可以依次遍历且无明显终点可循环访问",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "比较排序是一种排序算法，其核心特征是通过比较元素之间的大小关系来确定元素的相对顺序，从而将输入序列转换为有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "有向图是由顶点集合及顶点间的有向边构成的一种图，其中每条边都有明确的方向，从一个顶点指向另一个顶点，其核心性质是",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和相关操作的定义而不考虑其具体实现",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，并且可以通过下标来唯一地访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心性质为每个节点包含数据和指向下一个节点的指针，通过指针依次连接各个节点形成链式结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有如下性质的二叉树：若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树的查找的核心特征是从根节点开始，按照特定规则（如二叉排序树的左子树节点值小于根节点值、右子树节点值大于根节点值",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，并且任意两个节点间有且仅有一条路径相连",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树遍历分为前序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根），每种遍历按照特定顺序访问二叉树节点，前",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树的节点是树结构中的基本元素包含数据以及指向其子节点的引用且除根节点外每个节点有且仅有一个父节点根节点没有父节点",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其操作主要包括入栈将元素添加到栈顶、出栈从栈顶移除元素以及获取栈顶元素等，且栈在内存",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "21",
    "tail_offset": "32"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个单链表，链表中的节点表示与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（对于有向图是有向顶点序列），该序列中相邻顶点之间存在边（对于有向图是",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "数据类型具有特定的取值范围、存储方式以及一组与之相关的操作，不同数据类型的这些特点相互区别，共同构成了其核心性质",
    "head": "数据类型",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "集合的核心特征包括确定性、互异性和无序性，其中确定性是指对于一个给定的集合，任何一个元素是否属于这个集合是明确的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "树的节点的核心性质包括每个节点有零个或多个子节点，有且仅有一个称为根的节点，除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "递归基础的特点的核心特征是存在一个或多个明确的终止条件，当满足这些条件时递归不再继续，直接返回一个已知的简单结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者具有下列性质的二叉树：若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "双向链表是一种数据结构，其每个节点包含数据元素以及指向其前一个节点和后一个节点的指针，通过这些指针可实现双向遍历",
    "head": "双向链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "非线性结构中至少存在一个数据元素有两个或两个以上的直接前驱或直接后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "完全二叉树是深度为k的有n个结点的二叉树，对于树中的每个结点，如果其编号i满足1≤i≤n，则其左子结点编号为2i",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含指向下一个节点的指针外还包含指向前一个节点的指针，从而支持双向遍历",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次将每个元素与目标值进行比较，直到找到目标值或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "42"
  },
  {
    "sentence": "二叉树的核心性质是一棵非空二叉树的第 i 层上最多有 2 的 i-1 次方个结点，深度为 k 的二叉树最多有 2",
    "head": "二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是从一个顶点指向另一个顶点的有序对，顶点之间的边具有方向性",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，其中n≥0，当n=0时为空表，相邻元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层上的节点数都达到最大值，即除最后一层无任何子节点外，每一层上的所有节点都有两个子节点",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "有向图是一种由顶点集合以及顶点之间的有向边构成的数据结构，其中每条有向边都具有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "加权图是一种图结构，其中图的每条边都被赋予一个数值作为权值，这些权值可表示诸如距离、成本、容量等与边相关的某种度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中一个节点的子树数目称为该节点的度，树中所有节点度的最大值就是树的度，其核心特征是反映树中节点分支情况以及整棵树",
    "head": "子树",
    "tail": "树的度",
    "head_offset": "7",
    "tail_offset": "32"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，顶点间的关系集合描述了顶点之间的连接方式",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "归并排序的核心特征是将一个数组分成两个子数组，分别对这两个子数组进行排序，然后将排序好的子数组合并成一个有序的数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中存储图的顶点信息，边表中存储与每个顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数或节点数，它反映了树的层次结构深度，不同类型的树其高度因节点",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者满足若其左子树不空，则左子树上所有结点的值均小于它的根结点的值、若其右子树不空，则右子树上",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（对于有向图是有向顶点序列，对于无向图是无向顶点序列）且相邻顶点之间存在",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "树的高度的核心特征是从树的根节点到最远叶子节点之间最长简单路径上的边数或节点数所代表的数值，它反映了树在垂直方向上",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "路径是图中两个顶点之间的顶点序列（若为有向图则是有向边序列），包含起点终点且满足从起点按顺序经中间顶点可到达终点，",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "路径是由顶点和相邻顶点序偶构成的边所形成的序列，具有连通性、有序性、唯一性（若图中存在从顶点A到顶点B的路径，则该",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "52"
  },
  {
    "sentence": "邻接矩阵是表示图中顶点间相邻关系的矩阵，其元素值反映顶点间是否有边相连及边的相关信息，方阵行数与列数等于图的顶点数",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "52"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点路径上的边数或节点数所表示的垂直距离，它体现了树的纵向层次深度，反映了树结构在垂直",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征为数据元素之间存在一对一的线性关系，即除了第一个元素外，每个元素有且仅有一个前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点，具有与父节点通过特定关系相连且在树的层级结构中有其特定位置和作用等特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数体现的，根节点深度为0，每向下一层深度加1，且不同节点到根",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算机资源量，包括时间资源和空间资源，衡量算法效率主要通过时间复杂度和空间复杂度来体现",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "43",
    "tail_offset": "49"
  },
  {
    "sentence": "二叉树遍历的核心性质包括前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归访问左子树再访问根节点最后递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其核心特征是元素的插入和删除操作都在同一端进行，即栈顶，新元素总是被添加到栈顶，而删除",
    "head": "插入",
    "tail": "删除",
    "head_offset": "23",
    "tail_offset": "26"
  },
  {
    "sentence": "二叉树遍历是按照某种特定顺序访问二叉树中每个节点一次且仅一次的操作，包括前序遍历（根左右）、中序遍历（左根右）、后",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树的节点的核心性质是每个节点有零个或多个子节点，且有一个被称为根的特殊节点，除根节点外每个节点有且仅有一个父节点，",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "子节点是树结构或图结构中与父节点相对应的节点，其特点的核心特征包括：子节点是父节点的直接后继节点，在树结构中处于比",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树的遍历是指按照某种特定顺序访问二叉树中的每个节点一次且仅一次的操作，包括前序遍历（根节点、左子树、右子树）、",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其除了最后一层外，每一层上的节点数都是满的，并且最后一层上的节点都集中在最左边的若干",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树遍历是按照特定规则对二叉树中节点进行访问，先序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归访问左",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元包含数据以及指向子节点的指针且除根节点外每个节点有且仅有一个父节点根节点没有父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二叉树遍历是按照特定规则对二叉树中节点进行访问，先序遍历是根节点优先访问，中序遍历是根节点在左子树和右子树之间访问",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，是整个树的入口点，它与其他节点通过边相连并处于树的最顶层位置，是树状结构中",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "完全二叉树的核心特征是其叶子节点只能出现在最下层和次下层，并且最下层的叶子节点集中在树的左部，若设二叉树的深度为h",
    "head": "完全二叉树",
    "tail": "叶子节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问所指向的变量，从而实现对内存中数据的灵活操作和管理",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合组成的图结构，其中边是没有方向的，即若顶点v和顶点w之间存在边，则从v到",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找的核心性质是从数据序列的第一个元素开始，依次将每个元素与目标元素进行比较，直到找到目标元素或遍历完整个序列",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "50"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点间的关系通过边来表示，图中顶点的位置和边的形状不影响图的逻辑结构，图可分为",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "加权图是一种图结构，其中图的每条边都被赋予一个数值作为权值，这些权值可表示诸如距离、成本、容量等与边相关的某种度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图的顶点是图这种数据结构中组成图的基本元素之一，是图中用于表示某个对象或实体的节点，在有向图或无向图中具有标识作用",
    "head": "图的顶点",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "双向链表是一种链表结构，其每个节点除了包含数据域外，还包含两个指针分别指向前一个节点和后一个节点，从而支持双向遍历",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，若存在从顶点v到顶点w的一条路径，则称v和w是连通的，且路径长度是路径",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "加权图是一种图结构，其中图的每条边都被赋予一个数值作为权重，这些权重可以表示诸如距离、成本、容量等具有实际意义的量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点具有一个数据元素，有零个或多个子节点，且有且仅有一个被称为根的节点，除根节点外的每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "父节点是树状结构中位于上一层级的节点，其特点的核心特征包括拥有子节点且处于比子节点更高的层级位置，对其下一层级的子",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "非线性结构的核心特征是其各数据元素之间的逻辑关系不是一对一的线性关系，存在一对多、多对一或多对多等非简单线性的关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "链表是一种通过指针将一组节点连接起来的数据结构，每个节点包含数据和指向下一个节点的指针，最后一个节点的指针指向空值",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "在树形结构中一个节点存在其他节点以其为直接前驱那么该节点就是这些节点的父节点即父节点有子节点且子节点以其为直接前驱",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "35",
    "tail_offset": "39"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（对于有向图是有向顶点序列，对于无向图是无向顶点序列）且相邻顶点之间存在",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它是一个近似完全二叉树的结构且满足堆序性，即对于每个非叶子节点，其值大于或等于（大顶堆）或",
    "head": "完全二叉树",
    "tail": "叶子节点",
    "head_offset": "18",
    "tail_offset": "39"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的值进行比较，直到找到该值或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树的度的核心特征是树中所有结点的度的最大值，它决定了树的分支情况以及结构复杂程度，反映了树中各结点所拥有子树数量的",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "52"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，其中n≥0，当n=0时为空表，且线性表中相邻数据元素之间存在着序",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "循环链表的核心性质是最后一个节点的指针域指向头节点从而形成一个环形结构使得链表中的节点可以依次遍历且没有明确的终点",
    "head": "循环链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "归并排序的核心特征是采用分治策略，将待排序数组不断分成两个子数组分别递归排序，最后把有序子数组合并成一个有序的数组",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树是一种非线性数据结构，它有一个根节点，且根节点有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "21"
  },
  {
    "sentence": "树中各节点度的最大值即为树的度，它反映了树中节点分支情况的最大程度，体现了树结构的复杂程度，不同树的度各不相同，且",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "12",
    "tail_offset": "48"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质为：若图中有n个顶点，则邻接矩阵是一个n×n的矩阵，矩阵中元素的值表示",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "在树形结构中，一个节点若存在直接后继节点且这些后继节点通过某种特定关系与之相连，那么该节点就是这些后继节点的父节点",
    "head": "后继节点",
    "tail": "后继节点",
    "head_offset": "16",
    "tail_offset": "23"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，这些权重可用于表示诸如距离、成本、容量等各种与边相关的度量",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "父节点是树状结构中其下存在子节点的节点，具有比子节点更高的层级关系，在数据结构中起着承上启下连接子节点集合的作用且",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有限序列，具有顺序存储、元素类型一致、有固定大小以及通过下标唯一标识元素等核心性质",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机存储器中的表示方式以及如何通过这种表示实现对数据的高效存储、访问和操作",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接矩阵是表示图的一种矩阵，其中矩阵元素的值表示图中顶点之间是否存在边以及边的相关信息（如权值等），对于无向图其邻",
    "head": "邻接矩阵",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "52"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数，其核心性质包括非空树的高度大于等于0，并且对于任意一棵非空树",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，顶点间的关系集合描述了顶点之间的连接方式",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "线性表的核心性质是具有唯一的表头元素、唯一的表尾元素且除表头和表尾元素外每个元素有且仅有一个直接前驱和一个直接后继",
    "head": "线性表",
    "tail": "表头",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数，它反映了树的层次结构和深度，决定了树中节点之间的最长距离，",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历是按照特定规则访问二叉树中所有节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归访问左子",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中存储图的顶点信息，边表中存储与每个顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中每条有向边是一个有序对，由两个顶点构成，表示从一个顶点到另一个顶点",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其特点包括：叶子节点只能出现在最下层和次下层，且最下层的叶子节点集中在树的左部，若设",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，其中n≥0，当n = 0时为空表，每个元素在序列中都有唯一的前驱",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数或节点数，它反映了树的层次结构和深度，不同类型的树其高度特点",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数，且树中所有节点的高度是其后代节点的最大高度加1，根节点高度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其操作主要包括入栈将元素添加到栈顶、出栈从栈顶移除元素以及获取栈顶元素等，并且栈在内存",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "21",
    "tail_offset": "32"
  },
  {
    "sentence": "完全二叉树是一种特殊的二叉树，其特点是除最后一层外，每一层上的节点数均达到最大值，且最后一层上的节点都集中在该层最",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "选择排序每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机内存中的表示方式以及如何通过这种表示来高效地进行数据的存储、访问和修改",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，若存在从顶点vi到顶点vj的一条路径，则称vi是vj的前驱，vj是vi",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "二叉搜索树的特点是对于树中的每个节点，其左子树中的所有节点值均小于该节点值，右子树中的所有节点值均大于该节点值，且",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或遍历完整个线性表的查找方法",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长简单路径上的边数或节点数所表示的数值，体现了树在垂直方向上的深度和层次结构特征",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树中从根节点到最远叶子节点的最长简单路径上的边数就是树的高度树中不同节点到根节点的距离可能不同但树的高度是固定值且",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是只允许在表的一端进行插入操作（队尾），而在另一端进行删除操作（队头），遵循先进先出",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点下方的节点，具有相对于父节点的特定位置关系且可能存在多个子节点共同构成树的分支结构",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度，其核心特征在于它反映了树中各结点所拥有子树数目的最大情况决定着树的复杂程度且与",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "14",
    "tail_offset": "37"
  },
  {
    "sentence": "图的核心性质是由顶点集合及顶点间的边的集合所构成，顶点之间通过边相连，能直观地表示事物之间的关系，包括有向图和无向",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "19"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点有零个或多个子节点，每个子节点又可以有零个或多个子节点，且除根节点",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "选择排序每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或遍历完整个线性表的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "有向图是由顶点集合及顶点间的有向边构成的一种图，其边是有方向的，从一个顶点指向另一个顶点，顶点之间的关系具有方向性",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "选择排序每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "子节点的核心性质是其在树形结构中直接隶属于某个父节点且具有与父节点及其他兄弟节点特定的关联关系从而构成树形层次结构",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "树的节点的核心性质是每个节点有零个或多个子节点，且有一个被称为根的特殊节点，除根节点外的每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "比较排序是基于元素间比较操作来确定元素间相对次序从而实现排序的排序方法其核心性质是排序结果仅依赖于元素间的比较关系",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "有向图是由顶点集和有向边集组成的一种图结构，其中有向边是从一个顶点指向另一个顶点的有序对，顶点之间的连接具有方向性",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的深度是从根节点开始，沿最长路径到最远叶节点所经过的节点数，其核心特征为反映了树中节点层次的最大数量以及从根到叶",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，将较大（或较小）元素逐步交换到右侧（或左侧），重复此过程直至整个数组有序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "树的节点有一个根节点，根节点没有前驱节点，除根节点外每个节点有且仅有一个前驱节点，每个节点可以有零个或多个后继节点",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，其核心特征包括以链表形式存储图中每个顶点的邻接顶点，对于有n个顶点和e条边的图，",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "在图论中回路是指在一个图中从某一顶点出发，沿着边连续移动，最终回到该顶点且路径中除起点和终点外其他顶点不重复经过的",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "37"
  },
  {
    "sentence": "树的节点具有唯一的根节点，每个非根节点有且仅有一个父节点，除根节点外的其他节点可以有零个或多个子节点，并且从根节点",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构，通过构建初始堆、不断将堆顶元素与末尾元素交换并调整堆来实现对一组数据进行排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树遍历是按照某种特定顺序访问二叉树中每个节点一次且仅一次，先序遍历是先访问根节点再递归访问左子树和右子树，中序",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或到达线性表末尾的查找方法",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过下标可对元素进行唯一标识和访问，且在内存中存储位置连续",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素的相对顺序从而进行排序的算法，其核心特征是通过比较元素大小来逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "根节点是树结构中没有父节点的唯一节点，它处于树的最顶端，是树整体结构的起始点，所有其他节点都直接或间接连接于根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数组是一种有序数据集合，其中所有元素具有相同的数据类型，并且可以通过一个统一的数组名和下标来唯一标识和访问每个元素",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配元素或遍历完整个线性表的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是利用堆这种数据结构所具有的父节点大于或等于子节点（大顶堆）或父节点小于或等于子节点（小顶堆）的性质进行排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "在树形结构中，若存在一个节点A，有另一个节点B直接连接到A且B到根节点的路径长度比A到根节点的路径长度多1，则节点",
    "head": "根节点",
    "tail": "路径",
    "head_offset": "32",
    "tail_offset": "36"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其操作主要包括入栈将元素放入栈顶、出栈从栈顶取出元素、查看栈顶元素且栈顶指针随元素进出",
    "head": "入栈",
    "tail": "入栈",
    "head_offset": "21",
    "tail_offset": "27"
  },
  {
    "sentence": "选择排序每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或遍历完整个线性表的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中直接被某一节点所连接的下一层节点，它与父节点存在明确的连接关系，一个父节点可以有零个或多个子节点，",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，通常用来表示某个具体的实体或对象，在图中通过边与其他顶点相连接以构成图的结构关系",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列（对于有向图是有向顶点序列），其边或弧的序列依次连接这些顶点且满足一定的",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "树中各节点度的最大值就是树的度树的度反映了树中节点分支情况的最大程度不同类型的树其度具有不同特点且度的大小影响树的",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "12",
    "tail_offset": "15"
  },
  {
    "sentence": "子节点是树结构或图结构中直接与某一节点相连且处于该节点下方层次的节点，具有与父节点特定的关联关系并处于特定层级位置",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "图的边是连接图中两个顶点的线段或弧，具有方向性或无方向性，且边的集合定义了图的结构，其数量和连接关系决定了图的连通",
    "head": "图的边",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，其插入操作称为进栈或入栈，删除操作称为出栈或退栈，遵循后进先出的",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，用于表示图中的节点，具有标识图中各个对象的作用且可以与其他顶点通过边建立关联关系",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其操作主要包括入栈将元素添加到栈顶、出栈从栈顶移除元素以及获取栈顶元素等，并且栈在内存",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "21",
    "tail_offset": "32"
  },
  {
    "sentence": "邻接表中顶点表的每个节点包含顶点信息和指向边表的头指针，边表的每个节点包含邻接顶点信息和指向下一条边的指针，它可以",
    "head": "邻接表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "二叉树遍历是按照一定规则对二叉树的节点进行访问，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归访问左",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其核心性质为元素的插入和删除操作都在栈顶进行，新元素入栈后成为栈顶元素，栈顶元素始终是",
    "head": "插入",
    "tail": "删除",
    "head_offset": "23",
    "tail_offset": "26"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长路径上的边数或节点数所决定的数值，它反映了树的层次结构深度，不同类型的树高度",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其操作主要包括入栈将元素添加到栈顶、出栈从栈顶移除元素以及获取栈顶元素，且栈具有特定的",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "21",
    "tail_offset": "32"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中的所有节点值均小于该节点值，右子树中的所有节点值均大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次逐个将数据元素与给定值进行比较，直到找到匹配元素或遍历完整个序列的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "23"
  },
  {
    "sentence": "双向链表每个节点包含两个指针分别指向前一个节点和后一个节点从而实现双向遍历并且可以方便地在链表中进行插入删除等操作",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源的多少，包括时间复杂度和空间复杂度来衡量算法在时间和空间上的运行效率情况",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "27",
    "tail_offset": "33"
  },
  {
    "sentence": "循环链表的核心特征是其尾节点的指针域指向头节点，使得链表形成一个环形结构，从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "穷举法是对问题所有可能的情况进行逐一列举和检验，以找出符合条件的解，其核心性质是通过全面遍历所有可能情况来求解问题",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "操作效率是指在数据结构中进行特定操作（如插入、删除、查找等）时所花费的时间或资源的多少来衡量的该操作执行的快慢程度",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有限序列，具有顺序存储、元素类型一致、有固定长度以及通过下标唯一标识元素等核心性质",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "图的核心性质包括顶点集合和边集合的定义，顶点之间通过边相连，边可以有方向或无方向，图可以分为有向图和无向图，并且图",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "14"
  },
  {
    "sentence": "树的节点具有这样的核心性质：每个节点有零个或多个子节点，且有且仅有一个根节点，除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，若图为有向图路径具有方向性，若为无向图路径无方向性且路径上顶点不重复，",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，使得链表形成一个环形结构，从而可以从链表中的任意节点开始遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点具有这样的核心性质：每个节点有零个或多个子节点，有且仅有一个根节点，除根节点外的每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "简单排序是对数据序列进行排序的方法，其核心性质包括比较元素大小并根据比较结果交换元素位置以逐步将序列调整为有序状态",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数据的逻辑结构的核心性质是数据元素之间的逻辑关系，它独立于数据的存储方式，并且决定了数据在计算机中的组织和处理方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "回溯法是一种通过逐步构建问题的解，并在发现当前部分解无法导致可行完整解时进行回溯以重新选择路径来求解问题的算法策略",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中存储图的顶点信息，边表中存储与每个顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "选择排序每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "操作效率是指在数据结构的各种操作中，衡量完成特定操作所花费时间或资源的多少以及与其他相关操作效率对比情况的一种指标",
    "head": "操作效率",
    "tail": "操作效率",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，且与数据的运算无关，仅关注数据元素之间的关联方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "穷举法是对问题所有可能的情况进行逐一列举和检验，以找出满足条件的解，其核心性质是通过全面遍历所有可能情况来求解问题",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其每个结点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "堆排序是利用堆这种数据结构所具有的父节点大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的性质，将待排序数组构建",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是利用堆这种数据结构所设计的一种排序算法，它将待排序数组构建成一个堆，通过不断取出堆顶元素并调整堆来实现排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质为对于一个具有n个顶点的图，邻接矩阵是一个n×n的方阵，矩阵中元素的值",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "树的核心特征是具有一个根节点，且根节点有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，形成层次分明",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "11",
    "tail_offset": "16"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，是整个树结构的顶端节点，它处于树的最上层，是树中所有其他节点的祖先，从根节点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点间通过边相连，边可以具有方向形成有向图，也可以无方向形成无向图，图可用于表示",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和操作的语义，而不依赖于具体的实现细节",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的左子树中的所有节点的值都小于该节点的值，且右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树是一种非线性数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "20"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，权重值用于表示边的某种属性或代价，图中的顶点通过带权重的边相互连接",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质为对于有向图或无向图，矩阵中的元素表示对应顶点之间是否存在边，若存在则为",
    "head": "邻接矩阵",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "树中从根节点到最远叶子节点的最长路径上的节点数就是树的深度树中每个节点的深度是其到根节点路径上的节点数总和根节点深度",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点所经过的最长路径上的边数或节点数（取决于具体定义方式），其核心特征为体现从根到",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉树每个节点最多有两棵子树，并且子树有左右之分，其次序不能颠倒，它可以为空树，空树没有任何节点，非空二叉树由根节点",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序的核心性质是堆中每个节点的值都大于或等于其子节点的值（大顶堆）或小于或等于其子节点的值（小顶堆），并且堆是一种",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "54"
  },
  {
    "sentence": "邻接矩阵是用来表示图的一种矩阵，其中行和列对应图的顶点，矩阵元素的值表示对应顶点之间是否有边相连，若有边相连则值为1",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间缩小一半来快速定位目标元素的查找算法其特点是查找效率高平均时间复杂度为对数级",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的高度是从根节点开始，到最远叶子节点经过的最长简单路径上的边数，其核心特征为是从根节点到叶子节点最长路径的边数衡量",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "加权图的核心性质是图中每条边都被赋予一个权重值，该权重值用于表示边的某种属性或代价等，不同边的权重值可不同，基于这些",
    "head": "加权图",
    "tail": "边的权重",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "子节点是树结构或图结构中直接连接到某个父节点的节点，其特点的核心特征包括：在层次结构中处于父节点的下一层级，与父节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "邻接矩阵是用一个二维数组来表示图中顶点之间邻接关系的矩阵，其中矩阵元素的值表示对应顶点之间是否有边相连及边的相关信息",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有唯一的表头元素、唯一的表尾元素，且除表头和表尾元素外每个元素有且",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找的核心性质是从数据序列的第一个元素开始，依次逐个与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可依次访问链表中的各个节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "回溯法基础的特点是在包含问题的所有解的解空间树中，按照深度优先搜索策略，从根节点出发搜索解空间树，当探索到某一节点时",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质包括对于有向图，矩阵中元素若表示从顶点i到顶点j有边，则对应位置为1否则",
    "head": "邻接矩阵",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列组成的有限序列，这些元素存储在连续的内存单元中，可通过下标来唯一标识每个元素",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长简单路径上的节点数，它反映了树在垂直方向上的层次结构特征，体现了树中节点",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理存储位置上也相邻的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "父节点是在树形结构中，有其他节点直接连接在其下方并以其为直接前驱的节点，这些连接在其下方的节点即为该父节点的子节点，",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "50"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或者遍历完整个线性表的查找方法",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素的相对顺序从而实现排序的排序算法其核心特征是通过比较元素大小来逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "父节点是在树形结构中直接有子节点与之相连且处于较高层次或位置能对其下一层子节点起到统领、关联或作为其源头等作用的节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "在图论中回路是指在图中从一个顶点出发，沿着边经过一系列顶点后又回到该起始顶点且路径中各边互不相同的路径（若允许边重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "4",
    "tail_offset": "39"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "递归基础的核心特征是存在一个或多个明确的终止条件，当满足这些条件时递归过程不再继续调用自身而是直接返回一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的边数，体现了树在垂直方向上的层次数量，反映了树的结构复杂程度，不同",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的节点具有一个父节点（根节点无父节点），可以有零个或多个子节点，每个节点通过边与父节点和子节点相连，且节点之间具有",
    "head": "树的节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树遍历是按照某种特定顺序访问二叉树中每个节点一次且仅一次，包括先序遍历（先访问根节点，再递归访问左子树和右子树）",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中的所有节点值都小于该节点值，其右子树中的所有节点值都大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "归并排序是一种分治算法，其特点是将数组分成两个子数组，分别对两个子数组进行排序，然后将排序好的子数组合并成一个有序的",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "完全二叉树是这样一种二叉树，除最后一层外，每一层上的节点数均达到最大值，并且最后一层上要么是全有节点，要么是从左至右",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，其核心性质是按照层次依次访问节点，先访问距离起始节点较近的节点，直到遍历完所有可达节点",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "子节点是树结构中相对于父节点而言，直接连接在父节点之下的节点，具有与父节点存在直接层级关联且处于较低层级这一核心特征",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的左子树中的所有节点的值均小于该节点的值，且右子树中的所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的节点有一个根节点，除根节点外每个节点有且仅有一个父节点，节点可以有零个或多个子节点，并且节点是构成树型结构的基本",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "递归基础的核心特征是存在一个或多个明确的终止条件，当满足这些条件时递归过程不再继续调用自身而是直接返回一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其核心性质为元素的插入和删除操作都在栈顶进行，新元素总是被放置在栈顶，而最先进入栈的元素",
    "head": "插入",
    "tail": "删除",
    "head_offset": "23",
    "tail_offset": "26"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数，它反映了树在纵向方向上的层次数量和结构复杂程度",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，即左子节点和右子节点，并且存在唯一的根节点，二叉树可以为空树，若不为空树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法基础的特点是在包含问题的所有解的解空间树中，按照深度优先搜索策略，从根节点出发搜索解空间树，当探索到某一节点时",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质为若图中有n个顶点，则邻接矩阵是一个n×n的方阵，矩阵中元素的值表示对应",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "根节点是树结构中没有父节点的唯一节点，处于树的最顶端位置，是树的起始点，它在层次结构中具有特殊地位，是整个树结构数据",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "图的边是连接图中两个顶点的线表示顶点之间的关系其具有方向或无方向对于有向图边是有方向的从一个顶点指向另一个顶点对于无",
    "head": "图的边",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，所有其他节点都直接或间接连接到根节点，它在树的层次结构中",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数，它反映了树的层次结构深度以及节点分布的广度，体现了树中节点在",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数，它反映了树在垂直方向上的层次数量，体现了树结构",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数其核心性质为树中任意节点的深度是从根节点到该节点的路径长度且",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数，它反映了树的层次结构和节点分布情况，体现了树在垂直方向上的",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "存储结构的核心特征是数据元素及其关系在计算机存储器中的表示方式以及如何通过这种表示来实现对数据的高效存储、访问和管理",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历且能循环访问",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树的核心性质是除最后一层无任何子节点外，每一层上的所有结点都有两个子结点，并且最后一层的叶子节点是从左到右依次",
    "head": "满二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "父节点是在树形结构中直接拥有子节点的节点，它处于比子节点更高一层的层级关系中，对其下的子节点具有一定的关联和支配作用",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "有向图的核心特征是其边具有方向性，即从一个顶点指向另一个顶点，顶点之间的连接是单向的，不同于无向图中边没有方向的情况",
    "head": "有向图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理存储位置上也相邻的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，仅考虑数据元素之间的抽象关系而不涉及具体的存储方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，用于在图的各种算法和应用中衡量边的",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任何一个节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "在树形结构中，若存在一个节点A，有另一个节点B通过特定的关系（如父子关系的连接规则）与A相连，且B到根节点的路径长度",
    "head": "根节点",
    "tail": "路径",
    "head_offset": "50",
    "tail_offset": "54"
  },
  {
    "sentence": "路径是在图结构或树结构等数据结构中从一个顶点到另一个顶点的顶点序列（对于图）或从根节点到某个节点的节点序列（对于树）",
    "head": "路径",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置，通过依次对每个元素进行这样的操作，逐步将整个数组变为有序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "归并排序是一种分治算法，其核心性质是将一个数组分成两个子数组，分别对这两个子数组进行排序，然后将排序好的子数组合并成",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，根节点深度为0，到最远叶子节点所经过的层次数，它反映了树中节点的最大层次距离",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加直至叶节点所经过的最大层数，其核心特征在于体现了树中节点从根到叶的最长路径上所",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点之间通过边相连，边可以具有方向形成有向图，也可以无方向形成无向图，图中顶点的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其操作主要包括入栈将元素添加到栈顶、出栈从栈顶移除元素以及获取栈顶元素等，具有数据存储和",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "21",
    "tail_offset": "32"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的目标值进行比较，直到找到目标值或遍历完整个数据序列为止",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，它位于树的顶部，是整个树结构的入口点，通过它可以访问和遍历树的其他节点，是树",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的左子树中的所有节点的值都小于该节点的值，且右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或到达线性表的另一端的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法基础的特点是在包含问题的所有解的解空间树中，按照深度优先搜索策略，从根节点出发搜索解空间树，当探索到某一节点时",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，具有有向图和无向图中路径的不同方向性特点且在不同图结构中有其特定的表示和",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的左子树中的所有节点的值均小于该节点的值，且右子树中的所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次将每个数据元素与目标值进行比较，直到找到目标值或遍历完整个数据序列的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉搜索树中，每个节点的左子树中的所有节点的值均小于该节点的值，右子树中的所有节点的值均大于该节点的值，且左、右子树",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值用于表示边的某种属性或成本等，不同边的权重值可不同，且权重",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合组成的图结构，其中边是没有方向的，即顶点对(u, v)和顶点对(v, u)",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "有向图是一种由顶点集合以及顶点之间的有向边集合组成的图结构，其中每条有向边都具有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，仅考虑数据元素之间的抽象关系而不涉及具体的存储方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是只允许在一端进行插入操作（队尾），而在另一端进行删除操作（队头），遵循先进先出的原则",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的有限序列，这些元素存储在连续的内存空间中，可通过下标来唯一标识每个元素",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的值进行比较，直到找到该值或遍历完整个序列的一种查找算法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它是一个完全二叉树，并且满足父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值",
    "head": "完全二叉树",
    "tail": "父节点",
    "head_offset": "16",
    "tail_offset": "26"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到则返回该元素的位置，若遍历完整个表仍未找到则返回",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质包括若图中有n个顶点则邻接矩阵是n阶方阵，矩阵元素表示顶点间是否有边相连",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，仅考虑数据元素之间的抽象关系而不涉及具体的存储方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作，通过多次逐步调整使数据有序，具有操作相对简单直观、时间复杂度一般较高等特点",
    "head": "简单排序",
    "tail": "时间复杂度",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，用于在图的各种操作和算法中体现边的",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点的核心性质包括：对于有向图，矩阵中元素若对应边存在则为1否则为0，行列分别对应顶点",
    "head": "邻接矩阵",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "有向图是一种由顶点集合以及顶点之间的有向边集合组成的图结构，其中每条有向边都具有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "满二叉树是一种二叉树，其每一层的节点数都达到了最大值，即除叶子节点外每个节点都有两个子节点，叶子节点都在同一层，并且",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数，其特点包括不同类型树的高度有差异且与树的结构和节点分布等相关",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "无向图是一种由顶点集合及顶点间的边集合组成的图结构，其中边是没有方向的，顶点之间通过边相互连接且每条边都可以双向遍历",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的高度是从根节点到最远叶节点的最长路径上的节点数，体现了树在垂直方向上的延伸程度，不同类型的树其高度特点不同，完全",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且每个节点有零个或多个子节点，子节点之间形成层次关系，具有递归性和分支结构",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "17",
    "tail_offset": "32"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的查找是指在给定的树结构中，根据特定的条件或目标值，通过特定的遍历算法在树的节点中进行搜索以确定该值是否存在以及其",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "32"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值用于表示边的某种属性或成本等，不同的边其权重值可以不同且图",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次逐个将数据元素与目标值进行比较，直到找到目标值或遍历完整个数据序列的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "23"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数决定的，反映了树的层次结构以及从根到叶节点所经过的最大层数，",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理存储位置上也相邻的数据结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下到最远叶子节点所经过的最长路径上的节点数，反映了树在垂直方向上的层次数量，体现了树结构",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中直接被父节点包含且与其他同级子节点共同构成树的层次关系、具有特定的父-子关联并在树的遍历等操作中依据",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "递归基础具有明确的终止条件，是递归算法中最简单、最基本的情况，在此情况下递归直接返回一个确定的结果而不再继续调用自身",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到则返回该元素的位置，若遍历完整个表仍未找到则返回",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树是一种非线性数据结构，它有一个根节点，且根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "21"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "无向图的核心特征是由顶点集合以及顶点之间的边集合组成，且边是没有方向的，即顶点之间的连接关系是对称的，从顶点A到顶点",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "父节点是树结构中除根节点外有且仅有一个直接前驱节点的节点，它可以有零个或多个子节点，通过它可以访问到其直接后继节点即",
    "head": "父节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，关系集合中的元素是顶点对表示顶点之间的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据以实现快速的数据访问平均情况下时间复杂度接近常数",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接矩阵是用一个二维数组来表示图中顶点之间相邻关系的矩阵，若图中有n个顶点，则邻接矩阵是一个n×n的矩阵，矩阵中元素",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边连续移动，经过若干个顶点后又回到起始顶点的路径且路径中除起始顶点外其他顶点不重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "双向链表是一种线性数据结构，每个节点除了包含数据域外还包含两个指针，分别指向前一个节点和后一个节点，从而实现双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，使得链表形成一个环，从链表中的任意节点出发都可以遍历到链表中的其他节点",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，通过下标来访问和修改元素，并且数组的大小在创建后通常是固定的",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，若存在这样的序列，其中顶点之间通过边相连，该序列即为这两个顶点之间的路径",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "56"
  },
  {
    "sentence": "穷举法通过对问题所有可能的情况进行逐一列举和检验，从而找出符合条件的解，其核心性质是对所有可能情况进行全面遍历以求解",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "53"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，对于图中的每个顶点，都有一个链表与之对应，链表中的节点表示与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "树中各节点度的最大值就是树的度，它反映了树中节点分支情况的一个关键特性，树的度决定了树的结构复杂程度以及在相关算法和",
    "head": "树的度",
    "tail": "树的度",
    "head_offset": "12",
    "tail_offset": "36"
  },
  {
    "sentence": "操作效率是指在数据结构中进行特定操作（如插入、删除、查找等）时所花费的时间或资源与该操作的规模（如数据量大小等）之间",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "抽象数据类型具有数据抽象和行为抽象，数据抽象指用数据类型描述数据对象集，行为抽象指用一组操作描述数据对象上的抽象运算",
    "head": "抽象数据类型",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "无向图是一个二元组，其中一个元素是由顶点组成的非空有限集合，另一个元素是由顶点的无序对构成的边集合，且边集合中的元素",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的左子树中的所有节点的值均小于该节点的值，且右子树中的所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，它具有与父节点特定的关联关系，在数据组织和操作中扮演着相应角色",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的值进行比较，直到找到该值或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "邻接矩阵是用一个二维数组来表示图中顶点之间邻接关系的矩阵，其中矩阵元素的值表示对应顶点之间是否有边相连及边的相关信息",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "父节点是树结构中直接位于某一节点之上的节点，它具有指向子节点的连接关系，是子节点的直接前驱，在树的层次结构中处于比子",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "有向图是一种由顶点集合以及顶点间的有向边集合组成的数据结构，其中每条有向边都具有明确的方向，从一个顶点指向另一个顶点",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且位于树顶端的起始节点，它是整个树结构中层次最高的节点，其他节点都直接或间接连接在它之下",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻的顶点及其相关信息",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法基础的定义的核心性质是在问题的解空间树中，按深度优先策略从根节点出发搜索解空间树，搜索至解空间树的任一节点时，",
    "head": "回溯法",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "数据的物理结构的特点的核心性质包括数据元素在计算机存储空间中的存储方式以及数据元素之间的逻辑关系在计算机中的表示形式",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "递归基础是递归算法中最简单的情况，通常是问题的最小规模或最基本形式，它直接返回一个已知的结果而不进行进一步的递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "回溯法基础的特点是在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点出发搜索解空间树，当探索到某一节点",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间减半来查找特定元素，具有效率较高、平均时间复杂度为对数级但要求数组有序的特点",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，并且与数据的运算无关，只关注数据元素之间的关联方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "邻接表的核心特征是用链表来表示图中顶点的邻接关系，对于图中的每个顶点，都有一个链表与之对应，链表中存储了与该顶点相邻",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二叉树遍历是按照某种特定顺序访问二叉树中每个节点一次且仅一次的操作方式，分为前序遍历（根左右）、中序遍历（左根右）、",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树遍历的核心特征是通过特定顺序访问二叉树中的每个节点，先序遍历是先访问根节点再递归访问左子树和右子树，中序遍历是",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树的查找是在树结构中按照特定规则寻找特定元素，其核心性质包括若树为空则查找失败，若树非空则将根节点与待查找元素比较，",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "35"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数，它反映了树的层次结构深度及节点分布范围等特点，体现了树在垂直",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "平衡二叉树是一种二叉排序树，其中每个节点的左子树和右子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任何一个节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "有向图的核心特征是其边具有方向性，即从一个顶点指向另一个顶点，这种方向性决定了图中顶点之间的关系是单向的，与无向图边",
    "head": "有向图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "54"
  },
  {
    "sentence": "无向图是一种图结构，由顶点集合和边集合组成，其中边是没有方向的，即边所连接的两个顶点之间的关系是对称的，不存在从一个",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回溯法基础的特点是按深度优先策略，从根节点出发搜索解空间树，在搜索至某一节点时先判断该节点是否包含问题的解，若不包含",
    "head": "回溯法",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，所有其他节点都直接或间接连接到根节点，在树的遍历等操作中",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到则返回该元素的位置，若遍历完整个表仍未找到则返回",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回溯法基础的特点是在包含问题的所有解的解空间树中，按照深度优先搜索策略，从根节点出发搜索解空间树，当探索到某一节点时",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "广度优先搜索是一种从起始节点开始，按照层次依次访问节点，先访问距离起始节点近的节点，直至遍历完所有可达节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树遍历的特点是按照特定规则访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归访问",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中每个顶点建立一个单链表，链表中节点包含与该顶点相邻的顶点信息，从而直观地表示图的边关系，且",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与给定关键字进行比较，直到找到匹配元素或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心性质为每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "在树形数据结构中若存在节点A，节点B直接连接到节点A且节点A可通过某种遍历方式找到节点B，那么节点A就是节点B的父节点",
    "head": "遍历",
    "tail": "父节点",
    "head_offset": "35",
    "tail_offset": "56"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点即左子节点和右子节点并且一棵二叉树要么为空要么由一个根节点及其左子树和右子树",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二分查找的核心特征是在一个有序数组中，通过不断将数组分成两部分并判断目标值所在的部分，从而逐步缩小查找范围以找到目标值",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数据类型的特点是其具有特定的取值范围、存储方式、操作集合以及语义解释等，这些特性共同决定了数据在程序中的表示和使用方式",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始节点开始，先访问其所有邻接节点，再依次访问这些邻接节点的未访问过的邻接节点，按层次",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树是一种非线性数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推形成",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "20"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与给定的关键字进行比较，直到找到匹配的元素或遍历完整个序列的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "根节点是树结构中的起始节点，它没有父节点，是整个树的入口和基础，所有其他节点都直接或间接连接到根节点，它在树的层次结构",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "无向图是一种图结构，由顶点集合以及顶点之间的边集合组成，其中边是没有方向的，即如果顶点u和顶点v之间存在一条边，那么从",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，到最远叶子节点所经过的层数，其核心特征是体现了树中从根到最远叶子节点的最长路径",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加至最远叶节点所经过的层数，其核心特征在于它体现了树中节点层次的最大数量，反映了树",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "22"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点间的关系通过边来表示，边可以具有权值，且图中的顶点个数可以为零个或",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其核心特征为若图中有n个顶点，则邻接矩阵是一个n×n的方阵，矩阵中元素的值表示对应顶点",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组，分别对这两个子数组进行排序，然后将排序好的子数组合并成一个有序的数组的一种排序算法",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "归并排序是一种分治算法，它将一个数组分成两个子数组，对每个子数组分别进行排序，然后将排序好的子数组合并成一个最终的有序",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，不同边的权重值可不同，其核心特征在于",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有且仅有一个根节点，且每个节点有零个或多个子节点，并且任意两个节点之间有且仅有一条路径相连",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "20",
    "tail_offset": "35"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，不同边的权重值可以不同，用于描述图中",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数，它反映了树在垂直方向上的层次结构和节点分布情况，不同类型的树",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而对序列进行排序的排序方法其核心性质是通过元素间的比较操作逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，它在树中处于最高层次，是树的入口点，通过它可以遍历整个树结构，并且它对于确定树",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树是一种非线性的数据结构，它由n（n≥0）个有限节点组成，包含一个根节点，其余节点分为m（m≥0）个互不相交的有限集合",
    "head": "根节点",
    "tail": "集合",
    "head_offset": "33",
    "tail_offset": "57"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源的量度它反映了算法在不同规模输入下的运行性能包括时间复杂度和空间复杂度等方面",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "45",
    "tail_offset": "51"
  },
  {
    "sentence": "树是一种非线性数据结构，它有一个根节点，每个节点可以有零个或多个子节点，并且除根节点外每个节点都有且仅有一个父节点，树",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "16",
    "tail_offset": "32"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值的方法，其核心特征是通过重复执行特定的计算步骤，从初始值出发逐步逼近问题的解，每次",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "根节点是树结构中的起始节点，其核心特征为没有父节点且是整个树结构的入口点，从根节点开始可以遍历整个树，它在树的层次结构",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二叉树是每个节点最多有两个子树的树结构，其核心性质包括每个节点至多有两棵子树，并且二叉树的子树有左右之分，次序不能颠倒",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "归并排序是一种分治算法，它将一个数组分成两个子数组，对每个子数组分别进行排序，然后将排序好的子数组合并成一个最终的有序",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始顶点开始，先访问其所有邻接顶点，再依次访问这些邻接顶点的未被访问过的邻接顶点，按照",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心特征为：父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值，并且堆通常采用",
    "head": "父节点",
    "tail": "堆",
    "head_offset": "19",
    "tail_offset": "54"
  },
  {
    "sentence": "链表的核心特征是通过指针将一系列节点连接起来，每个节点包含数据和指向下一个节点的指针，从而形成一个逻辑上连续的数据结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "栈是一种后进先出的数据结构，其核心性质为元素的插入和删除操作都在栈顶进行，新元素总是被添加到栈顶位置，而删除操作也总是",
    "head": "插入",
    "tail": "删除",
    "head_offset": "23",
    "tail_offset": "26"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点，具有唯一的父节点，且其自身可以有零个或多个子节点，同时每个子节点都处于特定",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "完全二叉树是这样一种二叉树，除最后一层外，每一层上的节点数均达到最大值，且最后一层上只缺少右边的若干节点，若设二叉树的",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "父节点具有在树形结构中处于上一层级且与子节点存在特定关联关系的特点，它是子节点的直接前驱，对其下一层级的子节点起到组织",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "回溯法基础的核心性质是在问题的解空间树中，按照深度优先策略从根节点出发搜索解空间，当搜索到某一节点时，先判断该节点是否",
    "head": "回溯法",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "邻接表的核心特征是对于图中的每个顶点，用一个单链表来存储其所有邻接顶点，通过这种方式可以直观地反映出图中顶点之间的邻接",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，它具有依赖于父节点的层级关系并可能有自己的子节点从而形成树形结构",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，除根节点外的每个节点都有且仅有一个父节点，并且",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树遍历是按照某种特定顺序访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归访问左",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它将待排序数组构建成一个堆，将堆顶元素与堆的最后一个元素交换，然后将",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树的特点是每个节点最多有两个子节点，并且它可以为空树，或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "回溯法基础的特点是在包含问题的所有解的解空间树中，按照深度优先搜索策略，从根节点出发搜索解空间树，搜索至解空间树的任一",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示这条边的某种代价、成本、距离或其他相关度量，可用于在图的",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，通过下标来访问和修改元素，数组的长度固定，在内存中存储是连续的",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其特点为用二维数组来存储图中顶点之间的邻接关系，矩阵元素的值反映了对应顶点间是否有边相连及",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问图或树中节点，先访问起始节点，再依次访问其邻接节点，直至遍历完所有可达节点的一种搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据的逻辑结构的特点是数据元素之间存在的一种抽象的、与数据存储无关的逻辑关系，它描述了数据元素之间的相互关系和组织方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "11"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外还包含两个指针，分别指向前一个节点和后一个节点，从而支持双向遍历",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，每个节点有零个或多个子节点，且除根节点外每个节点有且仅有一个父节点，树中没有",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "17",
    "tail_offset": "31"
  },
  {
    "sentence": "二叉搜索树的特点是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，右子树中所有节点的值均大于该节点的值，且",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推形成",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "20"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径，或者在有向图中对于任意两个顶点都存在一条有向路径使得从一个顶点可到达另",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中每个数据元素在序列中都有唯一的前驱（除第一个元素外）和",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序的特点的核心性质包括：堆是一种完全二叉树，大顶堆中父节点的值大于或等于其子节点的值，小顶堆中父节点的值小于或等于",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是只允许在表的一端进行插入操作（称为队尾），而在另一端进行删除操作（称为队头），遵循先进",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它具有决定数据元素存储方式、影响数据操作效率及数据访问便利性等特点",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表的特点的核心特征是对于图中的每个顶点，用一个单链表来存储其所有邻接顶点，顶点表中存储顶点信息以及指向对应邻接表的",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，若图中有n个顶点，其邻接矩阵是一个n×n的矩阵，矩阵中元素的值表示对应顶点之间是否存在",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中每个元素在序列中都有唯一的前驱（除第一个元素外）和唯一",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将给定值与表中元素进行比较，若找到相同值则查找成功，若遍历完整个表仍未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它将待排序数据构建成一个堆，将堆顶元素与堆的最后一个元素交换，然后再",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树遍历的核心特征是按照特定顺序访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心性质为父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值，并且堆是一棵完全",
    "head": "父节点",
    "tail": "堆",
    "head_offset": "18",
    "tail_offset": "53"
  },
  {
    "sentence": "父节点是树结构中比子节点层级更高且能直接或间接关联并包含子节点的节点，其具有比子节点更大的深度，处于树的较高层次，拥有",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始节点开始，按照层次依次访问节点，先访问距离起始节点近的节点，直至遍历完所有可达节点",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值用于表示边的某种属性或代价，不同边的权重值可以不同，边的权重",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历的核心特征是通过特定规则访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构，通过将待排序数组构建成最大堆或最小堆，然后不断取出堆顶元素并调整堆结构来实现排序的算法",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数体现出的树的一个关键属性其反映了树在垂直方向上的层次数量及结构",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接与根节点相连，根节点处于树结构的",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树的查找的特点的核心性质是若存在从根节点到某节点的路径则该路径上节点值的顺序与查找顺序相关且查找过程会依据树的结构特点",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "17"
  },
  {
    "sentence": "数据的逻辑结构的定义的核心性质包括数据元素之间的逻辑关系，且这些关系独立于数据的存储方式，反映数据的组织形式和相互关联",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的节点数，它反映了树的层次结构和节点分布情况，不同树的深度不同，同一棵",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接矩阵是用一个二维数组来表示图中顶点之间的邻接关系，矩阵中元素的值表示对应顶点之间是否有边相连及边的相关信息（如权值",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "满二叉树是一种二叉树，其特点的核心特征是除最后一层无任何子节点外，每一层上的所有节点都有两个子节点，并且最后一层的节点",
    "head": "满二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构的核心性质包括数据元素在计算机中的存储方式以及数据元素之间的逻辑关系如何通过计算机内存中的存储单元来体现",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "有向图是一种图结构，其边具有方向性，即从一个顶点指向另一个顶点，顶点之间的连接关系是单向的，不同于无向图中边的无方向性",
    "head": "有向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有唯一的父节点，是父节点所关联的下一级节点集合中的元素，在树的",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "堆是一种优先队列，它是一棵完全二叉树，每个节点的值都大于或等于其子节点的值（大顶堆）或小于或等于其子节点的值（小顶堆）",
    "head": "队列",
    "tail": "完全二叉树",
    "head_offset": "6",
    "tail_offset": "13"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树遍历的核心特征是按照特定顺序访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于下一层级的节点，具有从属于特定父节点、在树状层级关系中有明确位置且其自身可能又有",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点具有一个父节点（根节点无父节点）以及零个或多个子节点，且除根节点外每个节点有且仅有一个直接前驱，每个节点可以有",
    "head": "树的节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，其中顶点集合中的元素称为顶点，顶点间的关系集合描述了顶点之间的连接关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "堆排序的核心性质是将数组构建成一个堆，堆中每个节点的值都大于或等于其子节点的值（大顶堆）或小于或等于其子节点的值（小顶",
    "head": "堆排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点，处于树的末端位置，其度为0，在数据处理和遍历等操作中具有特殊意义，是树结构中的重要",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "根节点是树结构中的起始节点，它没有父节点，是整个树结构的顶端，所有其他节点都直接或间接连接到根节点，它在树的层次关系中",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "栈是一种限定仅在一端进行插入和删除操作的线性表，其核心特征是后进先出，即最后进入栈的元素最先被取出，而最先进入栈的元素",
    "head": "插入",
    "tail": "删除",
    "head_offset": "12",
    "tail_offset": "15"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成，顶点代表事物，边表示事物之间的关系，图中的边可以是有向的也可以是无",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中各个节点可以依次遍历且能循环访问",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "归并排序是一种分治算法，其核心性质是将一个数组分成两个子数组，分别对两个子数组进行排序，然后将排序好的子数组合并成一个",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "父节点是树状结构中位于某一节点之上，具有更高层级关系，能直接衍生出该节点且可能拥有多个子节点，在层级关系中起到承上启下",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过下标来访问和修改元素，且在内存中存储紧凑具有连续的存储地址",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆排序的核心特征是将数组构建成一个堆，其中大顶堆的每个父节点的值都大于或等于其子节点的值，小顶堆的每个父节点的值都小于",
    "head": "堆排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值用于表示边的某种属性或代价，不同边的权重值可以不同，它可用于",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长路径上的节点数，它反映了树的层次结构深度，不同类型的树高度各异，完全二叉树高度与",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中每个元素在线性表中都有唯一的前驱（除第一个元素）和唯一",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源，通常用时间复杂度和空间复杂度来衡量其在时间和空间上随输入规模增长的变化情况",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "25",
    "tail_offset": "31"
  },
  {
    "sentence": "数据的逻辑结构的定义的核心性质包括数据元素之间的逻辑关系以及数据元素的相对位置，并且这些关系和位置独立于数据的存储结构",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且根节点可以有零个或多个子节点，除根节点外的其他节点有且仅有一个父节点，并且",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "22"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，不同数据类型具有各自独特的取值范围、存储方式和操作集合等特点",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长路径上的节点数且树中不同节点到根节点路径长度可能不同从而导致树有不同深度值",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，不同边的权重值可以不同，图中顶点之间",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，是整个树结构的入口点，所有其他节点都直接或间接连接到根节点，它在树的层次结构中",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "归并排序是将一个有n个记录的无序文件分成两个子文件，每个子文件包含n/2个记录，分别对这两个子文件进行排序，然后将排序",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树的核心特征是具有一个根节点，并且除根节点外的每个节点都有且仅有一个父节点，同时树是一种分层结构，它可以包含零个或多个",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "11",
    "tail_offset": "18"
  },
  {
    "sentence": "邻接矩阵是用于表示图中顶点之间相邻关系的矩阵，若图中有n个顶点，则其邻接矩阵是一个n×n的矩阵，矩阵中元素的值表示对应",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点，所有从根节点出发的",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，并且根节点可以有零个或多个子节点，除根节点外的每个节点都有且仅有一个父节点，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "23"
  },
  {
    "sentence": "数据类型的特点是其具有特定的取值范围、存储方式、操作集合以及语义规则等，这些特性共同决定了数据在程序中的表示和使用方式",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "树的查找是在给定的树结构中，依据特定的查找规则，从根节点开始，通过对节点的比较等操作，确定是否存在特定值的节点，若存在",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "19"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "堆是一种优先队列数据结构，它通常用数组实现，父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值且满足完全",
    "head": "队列",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "17"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，不同边的权重值可以不同，通过权重值来",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻的线性表存储结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "指针具有指向内存地址、可通过该地址访问和修改对应内存单元数据、能灵活实现数据传递与共享、可用于动态内存分配与释放等特点",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树的核心特征是它是一种非线性的数据结构，有且仅有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "26",
    "tail_offset": "30"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点即左子节点和右子节点且二叉树具有递归结构一个非空二叉树要么由根节点以及其左子",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它通常满足父节点键值大于或小于子节点键值的特定顺序关系，可分为最大堆（父节点键值大于子节点键值",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "17",
    "tail_offset": "27"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组，对这两个子数组分别进行排序，然后将排序好的子数组合并成一个有序的数组，其核心特征是",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "有向图中边具有方向性，顶点之间的连接是单向的，从一个顶点到另一个顶点存在特定的方向指向，其边的集合由有序对组成，体现了",
    "head": "有向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "47"
  },
  {
    "sentence": "二叉树遍历的核心特征是按照特定顺序访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "根节点是树结构中的起始节点，它没有父节点，是整个树结构的顶端，所有其他节点都直接或间接连接到根节点，根节点是树的入口点",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心性质为父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值，并且堆是一棵完全",
    "head": "父节点",
    "tail": "堆",
    "head_offset": "18",
    "tail_offset": "53"
  },
  {
    "sentence": "在一个无向图中，如果任意两个顶点之间都存在一条路径，那么这个无向图就是连通图，其核心特征是图中任意两点都能通过路径相连",
    "head": "无向图",
    "tail": "路径",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者满足对于任意一个节点，其左子树中的所有节点值均小于该节点值，右子树中的所有节点值均大于该节点值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外还包含两个指针域，分别指向前驱节点和后继节点从而形成双向链接关系",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，从起始顶点开始，先访问其所有邻接顶点，再依次访问这些邻接顶点的未被访问过的邻接顶点，按照",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者满足若其左子树不空，则左子树上所有节点的值均小于根节点的值，若其右子树不空，则右子树上所有节点",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的值进行比较，直到找到匹配元素或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "存储结构的特点是指数据元素及其关系在计算机存储器中的表示方式所具有的特性，包括数据元素的表示以及关系的表示等方面的特征",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "循环链表是一种链表，其最后一个节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配元素或遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历是按照某种规则依次访问二叉树中的每个节点且仅访问一次，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或遍历完整个线性表为止的查找方法",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中满足特定条件的一种初始情况或终止条件，在该条件下递归过程不再继续调用自身而是直接返回一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据元素以及指向后继节点的指针，最后一个节点的指针为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "图的边是连接图中两个顶点的元素，具有表示顶点之间关系的性质，且不同图的边在数量、连接方式等方面存在差异，边可以有方向或",
    "head": "图的边",
    "tail": "图的边",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "归并排序是一种分治算法，其核心性质是将一个数组分成两个子数组，分别对两个子数组进行排序，然后将排序好的子数组合并成一个",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到相同元素则返回其位置，若遍历完整个表都未找到则返回",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历的核心特征是按照特定顺序访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉树是一种树形结构，其每个节点最多有两个子节点，分别称为左子节点和右子节点，并且二叉树可以为空树，若不为空树则有一个",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将给定值与表中元素进行比较，若找到相同值则查找成功，若遍历完整个表都未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，且序列中相邻顶点之间存在边，其长度为路径上的边数，具有连通性、方向性等特点",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半，比较目标值与中间元素，以确定目标值在数组中的位置或判断其不存在的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且根节点可以有零个或多个子节点，除根节点外每个节点有且仅有一个父节点，并且从",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "22"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "父节点是在树形结构中，直接有子节点连接且处于上一层级的节点，其核心性质为每个子节点都与唯一的父节点相连并通过父节点建立",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "堆是一种优先队列数据结构，它是一棵完全二叉树，对于每个非叶子节点，其值都大于或等于（最大堆）或小于或等于（最小堆）其子",
    "head": "队列",
    "tail": "完全二叉树",
    "head_offset": "6",
    "tail_offset": "17"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是整个树结构的起始点，所有其他节点都直接或间接连接到根节点，在树的遍历等",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "二叉树遍历的核心特征是按照特定顺序访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "队列的核心特征是先进先出即元素按照进入队列的先后顺序依次从队列中取出最先进入队列的元素先被取出后进入队列的元素后被取出",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置以实现快速的数据存储和检索，具有平均时间复杂度接近常数时间的特点",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值用于表示与边相关的某种代价、距离、容量等属性，反映了边的某种",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其特点的核心性质为父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值，并且堆具有",
    "head": "父节点",
    "tail": "堆",
    "head_offset": "21",
    "tail_offset": "56"
  },
  {
    "sentence": "树的核心特征是它是一种非线性的数据结构，有且仅有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "26",
    "tail_offset": "30"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻的线性表存储结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，不同边的权重值可以不同，用于描述图中",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "回溯法基础的定义的核心性质是在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点出发搜索解空间树，当探索到",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点的最长简单路径上的边数，其核心特征为反映树中节点层次的最大深度体现从根到叶节点最长路径",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外还包含两个指针域，分别指向前驱节点和后继节点从而实现双向顺序访问",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "归并排序是一种分治算法，将数组分成两个子数组分别递归排序，再将排序好的子数组合并成一个有序的数组，其时间复杂度为O(n",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "完全二叉树是指除最后一层外，每一层上的节点数均达到最大值，在最后一层上只缺少右边的若干节点的二叉树，其节点个数n与深度",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，用于表示边的某种属性或代价等，不同边的权重值可以不同且边的权重影响图",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历的核心性质是按照某种特定顺序访问二叉树中的每个节点且仅访问一次，该顺序包括先序遍历（根节点、左子树、右子树）",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心性质为每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "二叉树遍历的核心性质是按照某种特定顺序访问二叉树中的每个节点且仅访问一次，该顺序包括先序遍历（根节点、左子树、右子树）",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树的高度是从根节点开始，沿着最长路径到最远叶子节点所经过的节点数（若根节点高度定义为0则从根节点到最远叶子节点所经过的",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点是树结构中的基本组成部分，具有一个数据元素以及零个或多个指向子节点的指针，每个节点是其所在子树的根，且除根节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中每个数据元素在非空表中都有且仅有一个直接前驱和一个直接",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "父节点是在树形结构中，直接有一条边连接到它的节点之上的节点，且该父节点具有比其直接连接的子节点更高的层级关系和相对位置",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "二叉树的每个节点最多有两个子节点，分别称为左子节点和右子节点，并且它可以为空树，根节点是二叉树中唯一没有父节点的节点，",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示这条边的某种属性或代价，不同边的权重值可以不同，它通过边",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的定义的核心特征是它是一种非线性的数据结构，有且仅有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "29",
    "tail_offset": "33"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它的特点的核心性质包括对于图中的每个顶点，都有一个链表来存储与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "父节点是树结构中位于某个节点之上，具有比该节点更高层次关系，能直接或间接连接到其下子节点，且在树的层次结构中处于上一层",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是先进先出，即先进入队列的元素先出队列，新元素总是添加在队列的末尾，而删除操作总是在队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数组是一种有序数据集合其核心性质为具有相同数据类型的元素按顺序存储在连续内存空间中且每个元素可通过数组名和下标唯一访问",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其核心特征为：是一个二维数组，行数和列数等于图中顶点数，矩阵中元素的值表示对应顶点间是否有",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，通过这些指针可实现双向遍历",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树遍历的核心特征是通过特定规则访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列仍未找到",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树的查找是基于树的特定结构，从根节点开始，按照一定规则（如比较节点值等）在树中搜索特定目标元素，其特点包括查找路径因树",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "15"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且根节点有零个或多个子节点，除根节点外的其他节点有且仅有一个父节点，并且任意",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "22"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数，它反映了树在纵向方向上的层次数量和结构复杂程度，",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "子节点的核心特征是它与父节点存在特定的关联关系，处于父节点之下，是树状结构等数据结构中从属于父节点的节点，具有与父节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有限序列，具有顺序存储、元素类型相同、有固定的长度且元素通过下标进行唯一标识等核心性质",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻的线性表存储结构",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "根节点是树结构中的起始节点，它没有父节点，是整个树结构的入口和基础，所有其他节点都直接或间接连接到根节点，它在树的层次",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者满足对于每个节点，其左子树所有节点的值都小于该节点值且右子树所有节点的值都大于该节点值的二叉树",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间减半来快速定位目标元素的查找算法，具有查找效率高、平均时间复杂度为对数级等特点",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径其核心特征是从图中的某一顶点出发沿着边遍历若干顶点后又回到该起始顶点",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "无向图是一种图结构，由顶点集合和边集合组成，其中边是没有方向的，任意一条边都可在两个顶点之间无差别地双向连接这两个顶点",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "广度优先搜索是一种在图或树等数据结构中按照层次依次访问节点，先访问距离起始节点较近的节点，直至遍历完所有节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "树的查找的核心特征是从根节点开始，依据节点间的层次关系和子树结构，通过比较节点值来确定目标元素是否存在于树中，若存在则",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "子节点的核心特征是其与父节点存在特定的关联关系，在树形结构等数据结构中，子节点是由父节点衍生出来的，继承了父节点的部分",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点的最长简单路径上的边数，它反映了树的层次结构和节点的深度分布，不同节点深度不同，根节点",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有唯一的头元素和尾元素，除头元素外每个元素有且仅有一个直接前驱，除尾",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "根节点是树结构中的起始节点，它没有父节点，是整个树结构的顶端，所有其他节点都直接或间接连接到根节点，它在树的层次结构中",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心性质包括：父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值，并且堆是一棵",
    "head": "父节点",
    "tail": "堆",
    "head_offset": "20",
    "tail_offset": "55"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，不同边的权重值可以不同，用于描述图中",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点的核心性质包括每个节点有零个或多个子节点，有且仅有一个称为根的节点，除根节点外每个节点有且仅有一个父节点，并且",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树的查找的特点的核心性质是若树中存在关键字值等于给定值的结点，则一定可以在从根结点出发的某条路径上找到该结点，且不同的",
    "head": "查找",
    "tail": "路径",
    "head_offset": "2",
    "tail_offset": "46"
  },
  {
    "sentence": "堆排序的核心性质是堆中每个节点的值都大于或等于其子节点的值（大顶堆）或小于或等于其子节点的值（小顶堆），并且完全二叉树",
    "head": "堆排序",
    "tail": "完全二叉树",
    "head_offset": "0",
    "tail_offset": "54"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心性质为父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值，并且堆通常用数组",
    "head": "父节点",
    "tail": "堆",
    "head_offset": "18",
    "tail_offset": "53"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点，是整个树结构的入口点，所有其他节点都直接或间接连接到根节点，它在树的层次结构中",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "二叉树遍历的核心特征是按照特定顺序访问二叉树中的每个节点，前序遍历先访问根节点再递归访问左子树和右子树，中序遍历先递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者满足对于任意一个节点，其左子树所有节点的值均小于该节点值，右子树所有节点的值均大于该节点值，且",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性，通过特定规则在树中定位目标元素，其查找效率受树的类型（如二叉查找树等）、节点分布等因素",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "33"
  },
  {
    "sentence": "树的查找是在树结构中按照特定规则寻找特定元素，其核心性质包括若树非空则从根节点开始，通过比较节点值与目标值决定继续在左",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "队列的核心特征是先进先出，即先进入队列的元素会先被取出，后进入队列的元素后被取出，如同排队等待服务一样，新加入的元素排在",
    "head": "队列",
    "tail": "队列",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心性质包括：父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值，并且堆具有完全",
    "head": "父节点",
    "tail": "堆",
    "head_offset": "20",
    "tail_offset": "55"
  },
  {
    "sentence": "子节点是树结构中与某一节点直接相连且处于该节点下方层次的节点，其与父节点存在直接的层级关联关系，是树状结构中特定层级位置",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "子节点的核心性质是其与父节点存在特定关联且在树状结构等相关数据结构中有明确的位置和作用关系，是构成整体结构的重要组成部分",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值的求解方法，其核心特征是通过重复执行相同的计算步骤，利用前一次迭代得到的结果来计算下",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "存储结构的核心性质是它不仅要存储数据元素，还要存储数据元素之间的关系，以便于高效地进行数据的访问、插入、删除、修改等操作",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接矩阵是一种用于表示图的矩阵，其中行和列分别对应图的顶点，矩阵元素表示对应顶点之间是否存在边，若存在则为1，不存在则为",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "树是一种非线性的数据结构，它具有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "18",
    "tail_offset": "22"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到相等元素则查找成功，若遍历完整个表都未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，右子树中所有节点的值均大于该节点的值，",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的查找的核心特征是从树的根节点开始，依据特定的比较规则沿着树的分支进行搜索，以确定目标元素是否存在于树中，若存在则返回",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "13"
  },
  {
    "sentence": "堆排序是一种选择排序，它将数据组织成堆结构，通过不断调整堆顶元素与其他元素的关系，将最大或最小元素逐步移到堆的末尾，从而",
    "head": "堆排序",
    "tail": "选择排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半来确定目标值位置，每次比较中间元素与目标值，若相等则找到，若目标值小则在左半",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点，先访问起始节点的邻接节点，再依次访问这些邻接节点的邻接节点等，直至遍历完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "递归基础的核心特征是存在一种最简单的情况，在此情况下递归调用不再继续，而是直接返回一个确定的结果，该结果能够终止递归过程",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有从属于父节点、丰富树的层次结构以及在树的遍历等操作中按特定顺序",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值的方法，其核心特征是通过重复执行相同的计算步骤，利用前一次迭代得到的结果来计算下一次",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接矩阵是一种表示图的方式，其特点为用一个二维数组来存储图中顶点之间的邻接关系，矩阵中元素的值表示对应顶点间是否有边相连",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "树的查找是基于树的层次结构，从根节点开始，根据节点间的父子关系，按特定规则逐步比较目标值与节点值，以确定目标值是否存在于",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "15"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或者遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，且任意两个节点之间有且仅有一条路径，不存在回路",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心特征是元素按照先进先出的原则进行排列，即先进入队列的元素先出队列，后进入队列的元素后出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，除根节点外每个节点有且仅有一个父节点，树中没有",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "二叉树遍历是按照某种规则依次访问二叉树中的每个节点，其核心性质包括先序遍历先访问根节点再递归访问左子树和右子树，中序遍历",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列，其核心特征是逐个元素进行比较查找",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "二叉树遍历是按照特定规则对二叉树中节点进行访问从而得到不同节点序列的操作，前序遍历先访问根节点再递归访问左子树和右子树，",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它将待排序数组构建成一个堆，将堆顶元素与堆的最后一个元素交换，然后调整",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，树中的其他节点都直接或间接连接到根节点，根节点是树的起始点和层次结构的基础",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，其右子树中所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "有向图的核心特征是其边具有方向性，即从一个顶点指向另一个顶点，这种方向性决定了图中顶点之间的关系是单向的，不同于无向图边",
    "head": "有向图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "56"
  },
  {
    "sentence": "算法效率的特点是指算法执行时间随问题规模增长的变化趋势以及占用资源如内存等方面的特性包括时间复杂度和空间复杂度等综合表现",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "44",
    "tail_offset": "50"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其中矩阵的行和列分别对应图的顶点，矩阵元素的值表示对应顶点之间是否存在边（对于无向图，若",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，并且每个节点可以有零个或多个子节点，除根节点外每个节点有且仅有一个父节点，树中",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "17",
    "tail_offset": "35"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括顺序存储结构、链式存储结构、索引存储结构和散列存储结构等不同形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，并且任意两个节点之间有且仅有一条路径，没有回路",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "邻接矩阵是用一个二维数组来表示图中顶点之间的邻接关系，矩阵中元素的值表示对应顶点之间是否存在边或弧以及边或弧的相关信息，",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "集合是具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素，集合中的元素具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "广度优先搜索是一种图或树的遍历算法，它按照层次依次访问节点，先访问起始节点，再依次访问其邻接节点，然后是这些邻接节点的邻",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "根节点是树结构中的起始节点，它没有父节点，是整个树结构的入口点，所有其他节点都直接或间接连接到根节点，它处于树的顶层位置",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它先将数组构建成一个最大堆或最小堆，然后依次取出堆顶元素并调整堆，从而",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表构成，顶点表中每个顶点对应一个链表，链表中节点存放与该顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "父节点是树状结构中位于某一节点之上，直接与该节点相连，具有指向其所有子节点的连接关系，且处于比子节点更高层级位置，能够对",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "递归基础具有明确的终止条件，是递归过程能够结束的关键，其核心性质是为递归提供了一个不需要再次递归调用的初始状态或边界情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点间的关系通过边来表示，任意一条边都连接图中的两个顶点，且顶点的个数可以是有限个也",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，将最大元素逐步“冒泡”到数组末尾，重复此过程直到整个数组有序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "子节点的核心特征是其与父节点存在特定的关联关系，在树形结构等数据结构中，子节点是直接连接在父节点之下的节点，具有从属于父",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，它可以为空树，若不为空树则包括一个根节点以及两棵互不相交的、分别称为左子树和",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "父节点是指在树形结构中，直接位于某个节点之上的节点，其核心性质包括拥有子节点且在树的层级关系中处于比子节点更高一级的位置",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到相等元素则查找成功，若遍历完整个表仍未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回路的核心性质是从回路中任一顶点出发，沿回路的边遍历，最终能回到起始顶点，且回路中各边不重复，同时回路的长度大于等于 3",
    "head": "回路",
    "tail": "回路",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间缩小一半来查找特定元素，具有查找效率较高、每次比较能排除一半元素等特点的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回路的核心特征是从图中某一顶点出发，沿着边依次访问若干顶点后又回到该起始顶点，所经过的路径中除起始顶点可重复外其余顶点均",
    "head": "回路",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，其核心特征包括：将待排序数据构建成最大堆或最小堆，利用堆顶元素是堆中最大或最小元素",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "在树这种数据结构中，从根节点开始，依据树的结构特性和节点之间的关系，通过特定的规则（如比较节点的值等），沿着树的分支进行",
    "head": "树",
    "tail": "根节点",
    "head_offset": "1",
    "tail_offset": "11"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价等，通过这些权重值可用于衡量图中节点之间",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素间相对次序从而对元素序列进行排序的排序方法其核心性质是排序结果仅取决于元素间的比较关系",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组，分别对两个子数组进行排序，然后将排序好的子数组合并成一个有序的数组，其核心特征是通过",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示与这条边相关的某种代价、成本、距离或其他度量，不同边的权重",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点间的关系通过边来表示，边可以具有权值等属性，其特点包括有不同类型如无",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点间的关系通过边来表示，边可以具有权值等属性且顶点与边的连接情况多样能",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值的解决问题的方法，其核心特征是通过重复执行相同的计算步骤，利用前一次迭代得到的结果来",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "19",
    "tail_offset": "23"
  },
  {
    "sentence": "树的查找的核心特征是从根节点开始，按照特定规则（如比较节点值等）逐步遍历树的节点，以确定目标元素是否存在于树中，不同类型",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点，其特点包括处于树的最底层没有分支延伸，度为0，在数据处理和遍历等操作中具有特殊意义如",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，右子树中所有节点的值均大于该节点的值，",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数，它反映了树在垂直方向上的层次数量和结构复杂度，不同",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，不同边的权重值可以不同，通过这些权重值",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的核心性质是左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值，且左右子树也分别为二叉搜索",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉搜索树是一棵二叉树，对于其中每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "迭代法的核心特征是基于已有的初始值，按照固定的迭代公式不断重复计算，每次计算的结果作为下一次计算的输入，逐步逼近问题的解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "选择排序是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到相同元素则查找成功，若遍历完整个表都未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，其核心特征为后进先出，即最后进入栈的元素最先被取出，而最先进入栈的元素",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "归并排序是将一个有n个记录的无序文件分成两个子文件，分别对这两个子文件进行排序，然后将排序好的子文件合并成一个有序的文件",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "树的节点的核心特征包括有一个根节点，除根节点外每个节点有且仅有一个父节点，每个节点可以有零个或多个子节点，节点按层次关系",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到相等元素则查找成功，若遍历完整个表仍未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑关系上相邻的元素在物理位置上也相邻，通过数组来存储元素，并且其存储单元是连续的，可随机访问表",
    "head": "线性表",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "34"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合所构成的数据结构，其中边是没有方向的，即若顶点v和顶点w之间存在一条边，则从v",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，其右子树中所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "平衡二叉树或者是一棵空树，或者是具有下列性质的二叉排序树：它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是",
    "head": "平衡二叉树",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "二叉搜索树中每个节点的左子树中的所有节点的值都小于该节点的值且右子树中的所有节点的值都大于该节点的值，同时其左右子树也均",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问节点，先访问完当前层所有节点后再进入下一层，以队列作为辅助数据结构来实现逐层遍历的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "树的高度是从根节点到最远叶子节点之间的最长路径上的节点数决定的其核心特征在于体现了树在垂直方向上的层次深度反映了树结构在",
    "head": "树的高度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据元素以及指向后继节点的指针，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，其右子树中所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别进行排序，再把排序好的子数组合并成一个有序的数组，其核心特征是通过递归地对数组进行",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，处于树的最顶层位置，是树中所有其他节点的起始点，树中的其他节点都直接或间接",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心性质为父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值，并且堆具有完全二叉",
    "head": "父节点",
    "tail": "堆",
    "head_offset": "18",
    "tail_offset": "53"
  },
  {
    "sentence": "平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树：它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵",
    "head": "平衡二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "父节点的核心性质是在树形结构中，每个节点有且仅有一个直接前驱节点被称为父节点，它是该节点在树中的上一级节点，与子节点存在",
    "head": "父节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "有向图的核心特征是其边具有方向性，即从一个顶点指向另一个顶点，这种方向性决定了图中顶点之间的关系是单向的，不同于无向图中",
    "head": "有向图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "56"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点之间通过边相连，边可以具有方向或无方向，且图中顶点的数量和边的数量没有固定的数学",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有唯一的表头元素，除表头元素外每个元素有唯一前驱，有唯一的表尾元素，除",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树是一种每个节点最多有两个子树的树形结构，它或者为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数据的逻辑结构的特点是数据元素之间存在的一种逻辑关系，这种关系独立于数据的存储方式，仅关注数据元素间的相互关系及组织形式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树遍历是按照特定规则对二叉树中节点进行访问从而得到节点序列的操作方式，前序遍历先访问根节点再递归访问左子树和右子树，",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "子节点的核心性质是其与父节点存在特定关联关系且具有相对父节点的特定位置和属性特征在树状结构等数据结构中有明确的定义和作用",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的查找的核心特征是从根节点开始，根据节点间的父子关系，按照特定规则在树的节点中进行搜索以找到目标节点，不同类型的树（如",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示与这条边相关的某种代价、成本、距离或其他度量，加权图的核心",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，其右子树中所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中每个顶点对应一个链表，链表中存储与该顶点相邻接的顶点信息",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "邻接矩阵的核心特征是用一个二维数组来表示图中顶点之间的邻接关系，数组中元素的值表示对应顶点之间是否存在边或弧，若存在则为",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "邻接表的核心性质是对于图中的每个顶点，通过链表形式存储其所有邻接顶点，能直观反映图中顶点之间的邻接关系且便于对图进行各种",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它将待排序数据构建成一个堆，将堆顶元素与堆末尾元素交换，然后将剩余元素",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点特点包括有一个根节点，每个节点有零个或多个子节点，除根节点外每个节点有且仅有一个父节点，且节点间通过父子关系构成",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推形成",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树的深度的核心特征是从根节点到最远叶子节点所经过的最长路径上的节点数，它反映了树在纵向方向上的层次数量和结构复杂度，不同",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列为止，其核心特征是逐个元素顺序查找",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "二叉树的核心特征包括每个节点最多有两棵子树，分别称为左子树和右子树，并且节点的子树有左右之分不能随意颠倒，同时二叉树可以",
    "head": "二叉树",
    "tail": "子树",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "连通图是指在无向图中任意两个顶点之间都存在路径能够相连或者在有向图中对于任意两个顶点从一个顶点到另一个顶点都存在有向路径",
    "head": "连通图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉树遍历是按照某种特定顺序访问二叉树中每个节点一次且仅一次，其核心特征包括前序遍历先访问根节点再递归访问左子树和右子树",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到相等元素则查找成功，若遍历完整个表仍未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "父节点是树状结构中位于上一级的节点，它具有比子节点更高的层级关系，能够直接或间接连接多个子节点，是子节点数据关系的源头和",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组，对这两个子数组分别进行排序，然后将排序好的子数组合并成一个有序的数组，其核心特征在于",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序的特点的核心性质是将数组构建成一个堆，堆中每个节点的值大于或等于其子节点的值（大顶堆）或小于或等于其子节点的值（小",
    "head": "堆排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的左子树中的所有节点的值均小于该节点的值，右子树中的所有节点的值均大于该节点的值，且左",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的左子树中的所有节点的值均小于该节点的值，右子树中的所有节点的值均大于该节点的值，且左",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到相等元素则查找成功，若遍历完整个表都未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，其核心性质是将待排序数据构建成一个最大堆或最小堆，利用堆顶元素是堆中最大或最小",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括顺序存储结构、链式存储结构、索引存储结构和散列存储结构等不同形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "栈是一种特殊的数据结构，其核心特征是后进先出，即最后进入栈的元素最先被取出，就像一个只允许在一端进行插入和删除操作的容器",
    "head": "插入",
    "tail": "删除",
    "head_offset": "50",
    "tail_offset": "53"
  },
  {
    "sentence": "树的查找是指在给定的树结构中，根据特定的条件或关键字，从根节点开始，按照树的结构特性，通过比较、遍历等方式寻找满足条件的",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值用于表示与边相关的某种数量或属性，不同边的权重值可以不同，以此",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或者遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "引用是为对象起的一个别名，对引用的操作实际上就是对其所引用对象的操作，引用必须在定义时初始化且初始化后不能再引用其他对象",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "43",
    "tail_offset": "47"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中每个顶点对应一个链表，链表中存储与该顶点相邻接的顶点信息",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "堆排序是一种选择排序，它利用堆这种数据结构的特性，将待排序序列构建成最大堆或最小堆，每次取出堆顶元素并调整堆，从而实现对",
    "head": "堆排序",
    "tail": "选择排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，且任意两个节点间有唯一的一条路径，树中没有回路",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括顺序存储结构、链式存储结构、索引存储结构和散列存储结构等不同形式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，而右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "子节点的核心特征是它是某个父节点下的分支节点，与父节点存在特定的层级关系且在该层级结构中具有相应的位置和关联，继承了来自",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中每个数据元素在序列中都有唯一的前驱（第一个元素无前驱）和",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止的查找方法",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "在树形结构中，对于某一节点而言，直接位于其上方且与该节点有直接连接关系的节点就是该节点的父节点，父节点具有比子节点更高的",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "44",
    "tail_offset": "48"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可以依次访问到链表中的各个节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，其核心特征是将待排序序列构建成一个最大堆或最小堆，利用堆顶元素是堆中最大或",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的查找的核心特征是基于树的结构特性，通过特定的路径或规则在树中定位目标元素，以确定元素是否存在于树中以及获取其相关信息",
    "head": "查找",
    "tail": "路径",
    "head_offset": "2",
    "tail_offset": "24"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，不同边的权重值可以不同，通过这些权重值",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问离起始节点距离为 0 的节点，再依次访问距离为 1、2 等的节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，顺序扫描线性表，依次将扫描到的元素与给定值进行比较，若相等则查找成功，若扫描完整个线性表都",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到相等元素则查找成功，若遍历完整个表都未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置以实现快速的数据插入删除和查找操作具有平均时间复杂度为O(1)的特点",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接与根节点相连，所有从根节点出发可以",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，并且根节点可以有零个或多个子节点，其余每个节点有且仅有一个父节点，除根节点外的",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "23"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换操作以实现排序，其核心性质包括比较相邻元素大小并按规则交换，重复此过程直到整个序列有序",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合所组成的数据结构，其中边是没有方向的，即顶点对(u, v)和(v, u)表示同",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，顶点间的关系集合中的元素表示顶点之间的连接关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树的遍历是指按照某种规则依次访问二叉树中的每一个节点且仅访问一次的操作，分为前序遍历（先访问根节点，再递归访问左子树",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中每个顶点对应一个单链表，单链表中的节点表示与该顶点相邻接",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是先进先出，即先进入队列的元素先出队列，新元素总是添加在队列末尾，而删除操作总是在队列头部",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "交换排序是指通过比较和交换元素位置，将无序序列逐步调整为有序序列的排序方法其核心特征在于比较元素大小后交换位置以实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "线性表是具有相同数据类型的n(n≥0)个数据元素的有限序列，有唯一的表头元素、表尾元素，除表头元素外每个元素有且仅有一个",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素在计算机中的存储方式以及数据元素之间的逻辑关系如何在存储中体现包括存储位置和存储顺序等",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过下标来唯一标识和访问各个元素，并且在内存中占用连续的存储空间",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列且序列中相邻顶点之间存在边，它具有连接两个顶点的特定路线的性质，并且在有向图中",
    "head": "路径",
    "tail": "有向图",
    "head_offset": "0",
    "tail_offset": "56"
  },
  {
    "sentence": "父节点的核心性质是在树形结构中，对于某一节点而言，直接位于其上方的那个节点就是它的父节点，该父节点具有指向它以及其所有子",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且位于父节点下方的节点，具有唯一的父节点，其自身可能存在多个子节点，在树的层次结构中处于",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，其右子树中所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的节点的核心特征是每个节点有一个数据元素，并且除根节点外每个节点有且仅有一个前驱节点，每个节点可以有零个或多个后继节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的节点是树结构中的基本单元，包含数据以及指向子节点的指针（对于有子节点的情况），且除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，顺序扫描线性表，依次将扫描到的元素与给定值进行比较，若相等则查找成功，若扫描完整个线性表都",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表的特点的核心特征是对于图中的每个顶点，用一个单链表来存储其所有邻接顶点，通过这种方式可以方便地表示图的结构，并且在",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "子节点是树结构中相对于父节点而言直接连接在其下方的节点，具有比父节点更低的层级关系且可能有零个或多个兄弟节点，在树的遍历",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，并且可以通过数组名和下标来唯一地访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合所构成的数据结构，其中边是没有方向的，即顶点对(u, v)和(v, u)表示同",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "加权图的核心特征是图中的边被赋予了权重值，这些权重值用于表示边所连接的两个顶点之间的某种度量或代价，不同的加权图其权重所",
    "head": "加权图",
    "tail": "加权图",
    "head_offset": "0",
    "tail_offset": "53"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组，分别对两个子数组进行排序，然后将排序好的子数组合并成一个有序的数组，其核心性质是通过",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将给定值与表中元素进行比较，若找到相等元素则查找成功，若遍历完整个表仍未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心特征是数据元素按照先进先出的原则进行排列，即先进入队列的元素先出队列，后进入队列的元素后出",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "父节点是树状结构中位于上层的节点，具有指向子节点的链接，它是子节点的直接前驱，在层次关系中处于较高位置，其存在对于构建和",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的左子树中的所有节点的值均小于该节点的值，右子树中的所有节点的值均大于该节点的值，且左",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "在树形数据结构中，对于某一节点而言，若存在另一节点，使得从根节点到该另一节点的路径上经过此节点且该另一节点与它有直接连接",
    "head": "根节点",
    "tail": "路径",
    "head_offset": "29",
    "tail_offset": "39"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点，先访问距离起始节点较近的节点，直至遍历完所有节点或找到目标节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "归并排序是一种分治算法，将数组分成两个子数组分别递归排序，再将排序好的子数组合并成一个有序数组，具有稳定、时间复杂度为O",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "图是由顶点集合以及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，顶点间的关系集合中的元素表示顶点之间的边或弧",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "15"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点，先访问距离起始节点较近的节点，直至遍历完所有节点或找到目标节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径，其核心性质包括能回到起始顶点，在有向图中回路的方向可循环，回路中顶点",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或者遍历完整个线性表为止的查找方法",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "加权图的核心性质是图中的每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，不同边的权重值可以不同，基于这些权重值",
    "head": "加权图",
    "tail": "边的权重",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有唯一的父节点，是父节点所包含的下一级节点集合中的元素，其数量和",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其核心特征为有唯一的表头元素、唯一的表尾元素，除表头元素外每个元素有且仅有",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的核心特征是具有一个根节点，根节点没有前驱，且除根节点外的每个节点有且仅有一个前驱，同时每个节点可以有零个或多个后继，",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "11",
    "tail_offset": "15"
  },
  {
    "sentence": "邻接矩阵是用于表示图中顶点之间相邻关系的矩阵，其中矩阵元素的值表示对应顶点间是否有边相连及边的相关属性（若为无权图则为0",
    "head": "邻接矩阵",
    "tail": "无权图",
    "head_offset": "0",
    "tail_offset": "54"
  },
  {
    "sentence": "二叉树的遍历是指按照某种特定顺序访问二叉树中的每个节点一次且仅一次的操作过程，常见的遍历方式有前序遍历（根节点、左子树、",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "树的节点是树结构中的基本单元，包含数据以及指向子节点的指针（对于有子节点的情况），根节点是树中没有父节点的特殊节点，其余",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉树的遍历是指按照某种特定顺序访问二叉树中的每一个节点且每个节点仅被访问一次的操作，包括前序遍历、中序遍历、后序遍历和",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "堆排序的核心性质是利用堆这种数据结构，将待排序序列构建成一个最大堆或最小堆，根节点的值是堆中最大或最小的，然后通过不断将",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树的遍历是指按照某种特定顺序访问二叉树中的每个节点且仅访问一次的操作，可分为前序遍历（先访问根节点，再递归访问左子树",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "堆排序的核心特征是将待排序数据构建成一个堆，即满足堆的性质（最大堆中父节点的值大于或等于其子节点的值，最小堆中父节点的值",
    "head": "堆排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其核心特征是以矩阵形式描述图中顶点之间的邻接关系，矩阵的行和列分别对应图的顶点，矩阵元素",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "父节点是树结构中直接与子节点相连且在层级关系上处于子节点之上一层的节点，具有指向子节点的链接，在树的遍历等操作中起到关键",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中每个数据元素在线性表中都有唯一的前驱（第一个元素除外）和",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，除根节点外每个节点有且仅有一个父节点，树中没有",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径，其核心性质包括能回到起始顶点，可由多个顶点和边按一定顺序组成，在有向",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "无向图是一种由顶点集合以及顶点之间的边集合所构成的数据结构，其中边是没有方向的，即若存在一条边连接顶点u和顶点v，则从u",
    "head": "无向图",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "图的边是连接图中两个顶点的元素，其核心特征包括具有方向性或无方向性，有相应的权重来表示连接的某种属性，边的集合定义了图的",
    "head": "图的边",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "53"
  },
  {
    "sentence": "图的顶点是图结构中的基本元素，具有标识图中各个节点的作用，通过边与其他顶点相连接，共同构成图的拓扑结构，其数量和性质对图",
    "head": "图的顶点",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "59"
  },
  {
    "sentence": "邻接表的核心特征是对于图中的每个顶点，用一个单链表来存储其所有邻接顶点，通过这种方式可以方便地表示图的结构，并且在进行图",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "稳定性是指在数据结构中，若两个相等的数据元素在原始序列中的相对先后顺序在经过某种操作后仍然保持不变则该数据结构具有稳定性",
    "head": "稳定性",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，该序列中的顶点依次有边相连，且路径长度是路径中边的数目，路径可以是简单路径（",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示这条边的某种代价、长度、容量等属性，不同边的权重值可以不同",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的值大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值，并且具有完全二叉树的形态",
    "head": "父节点",
    "tail": "完全二叉树",
    "head_offset": "15",
    "tail_offset": "52"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组，对两个子数组分别进行排序，然后将排序好的子数组合并成一个有序的数组，其核心性质是通过",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的节点具有一个根节点，除根节点外每个节点有且仅有一个父节点，每个节点可以有零个或多个子节点，并且从根节点到每个节点存在",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中每个数据元素在序列中都有唯一的前驱（第一个元素无前驱）和",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示与这条边相关的某种代价、成本、距离或其他度量，加权图的核心",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "加权图的核心性质是图中的每条边都被赋予一个权重值，该权重值用于表示边的某种属性或代价等，不同边的权重值可以不同，通过这些",
    "head": "加权图",
    "tail": "边的权重",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示与这条边相关的某种代价、距离、成本或其他度量，图中顶点之间",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的逻辑结构的核心性质是数据元素之间的逻辑关系，它独立于数据的存储方式，描述了数据元素之间的关联方式以及数据的组织形式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "归并排序是将一个有n个记录的无序文件分成两个子文件，分别对这两个子文件进行排序，然后将排序好的子文件合并成一个有序的文件",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问其所指向的变量，从而实现对该变量的操作和数据传递等功能",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "子节点是树结构中相对于父节点而言的节点，其特点的核心特征包括：子节点是父节点的直接后继节点，一个父节点可以有零个或多个子",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，除根节点外，每个子节点有且仅有一个父节点，并且",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "在树形结构中，根节点是没有前驱节点且位于树的顶端，作为树的起始点，是整个树形结构的基础和核心，所有其他节点都直接或间接与",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "7",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将给定值与表中元素逐个比较，若找到相等元素则查找成功，若遍历完整个表仍未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它包含一个根节点，且根节点有零个或多个子节点，每个子节点又可以有零个或多个子节点，以此类推形成",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "18",
    "tail_offset": "23"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示这条边的某种属性或代价，图中的顶点通过带权重的边相互连接，",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值权重，用于表示与边相关的某种度量，如距离、成本、容量等，这些权重影响着图中",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二分查找是在有序数组中，通过将数组中间元素与目标值比较，若相等则找到，若目标值小于中间元素则在左半部分继续查找，若目标值",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是一对一的，而是存在一对多、多对一或多对多等关系，其前驱和后继个数不固定且无法用简单",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表中顶点表的每个节点包含顶点信息和指向该顶点第一条边的指针，边表节点包含邻接顶点信息和指向下一条边的指针其特点是对于",
    "head": "邻接表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且唯一存在的起始节点，它位于树的顶端，是整个树的核心起始点，所有其他节点都直接或间接连接于根",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有唯一的表头元素和表尾元素，除表头元素外每个元素有唯一前驱，除表尾元素",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完同一层所有节点后再进入下一层进行访问",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，右子树中所有节点的值都大于该节点的值，",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "加权图的核心性质是图中每条边都被赋予一个权重值，用于表示边的某种属性或代价等，不同边的权重值可能不同，通过这些权重值可以",
    "head": "加权图",
    "tail": "边的权重",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中所有节点的值都小于该节点的值，其右子树中所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，顺序扫描线性表，依次将扫描到的元素与给定值进行比较，若相等则查找成功，若扫描完整个线性表都",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，顶点间的关系集合中的元素表示顶点之间的连接关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "线性表是一种数据元素的有限序列，其特点包括有唯一的头元素和尾元素，除头元素外每个元素有唯一前驱，除尾元素外每个元素有唯一",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，直到找到匹配元素或遍历完整个表，若找到则返回该元素的位置，",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据元素以及指向后继节点的指针，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "归并排序是一种分治算法，将数组分成两个子数组分别递归排序，再将排序好的子数组合并成一个有序的数组其特点是稳定、时间复杂度",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，它具有特定的取值范围、表示形式、存储方式和对其值所能进行的操作",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，其右子树中所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中每个元素在序列中都有唯一的前驱和后继（第一个元素无前驱，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中所有节点的值均小于该节点的值，其右子树中所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "根节点是树结构中的起始节点，其核心特征为在树结构中没有前驱节点，是整个树的入口点，所有其他节点都直接或间接与根节点相连并",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心特征是元素按照先进先出的原则进行排列，即先进入队列的元素先出队列，后进入队列的元素后出队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "邻接矩阵是用一个二维数组来表示图中顶点之间的邻接关系，矩阵中元素的值表示对应顶点之间是否存在边或弧以及边或弧的相关信息，",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将表中元素与给定值进行比较，若找到相等元素则查找成功，若遍历完整个表都未找到则查找失败",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，处于树的顶层位置，是树中所有其他节点的起始点，树中的其他节点都直接或间接与",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树的节点包含数据元素以及指向其子节点的若干指针，除根节点外每个节点有且仅有一个父节点，根节点没有父节点，叶节点没有子节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的特点是左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且左右子树也分别为二叉搜索树",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它通过构建最大堆或最小堆，将堆顶元素与堆末尾元素交换，然后调整堆结构，重复此",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "归并排序是一种将一个无序数组分成两个子数组分别进行排序再将排序好的子数组合并成一个有序数组的稳定的分治算法其时间复杂度为O",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "插入排序的核心性质是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，直到整个数组都被排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "顺序查找的核心性质是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算机资源量，一般用时间复杂度和空间复杂度来衡量算法执行时间和占用空间随问题规模增长的变化情况",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "24",
    "tail_offset": "30"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表构成，顶点表中每个顶点对应一个链表，链表中的节点表示与该顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "线性表的核心性质是具有相同数据类型的n个数据元素的有限序列，有唯一的头元素和尾元素，除头元素外每个元素有且仅有一个直接前驱",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它利用堆的特性将数据序列构建成最大堆或最小堆，然后通过不断取出堆顶元素并调整堆来实现",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "冒泡排序的核心特征是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "子节点是树结构或图结构中直接连接到某个父节点的下一级节点，具有与父节点直接关联、在层级关系中处于父节点之下的位置关系等特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是先进先出，即先进入队列的元素先出队列，新元素总是添加在队列末尾，删除操作总是在队列头部进行",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它通过构建最大堆或最小堆，将堆顶元素与末尾元素交换，然后调整堆以重复此过程，",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，这些权重反映了边的某种属性或代价等，图中顶点之间通过带权重的边相连",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回溯法基础的定义的核心特征是在问题的解空间树中，按照深度优先策略从根节点出发搜索解，当发现当前节点不满足求解条件时就回溯到",
    "head": "回溯法",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将数组构建成最大堆或最小堆，然后依次取出堆顶元素并调整堆结构，从而实现对数组的排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑结构中数据元素之间是一对一的线性关系，其物理存储结构是将数据元素依次存储在一片连续的存储单元中",
    "head": "线性表",
    "tail": "逻辑结构",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "回路是指在图中从一个顶点出发，沿着边经过一系列顶点后又回到起始顶点的路径且路径中除起始顶点外其他顶点不重复，同时具有从某一",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "深度优先搜索是一种在搜索过程中沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径的搜索策略",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "选择排序是一种简单直观的排序算法，其核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "父节点是树结构中直接位于某个节点之上的节点，具有比该节点更高的层级，且该节点通过特定的连接关系与父节点相连，父节点可以有零",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点，其特点的核心特征包括在树的最底层，没有分支延伸出去，是数据存储或操作的最终位置，代表树",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机存储器中的表示方式以及如何利用这种表示来高效地进行数据的存储、访问和修改等操作",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆排序是一种利用堆这种数据结构所设计的一种排序算法，它将待排序序列构造成一个最大堆，依次将堆顶元素与堆的最后一个元素交换，",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，数据元素之间存在一对一的线性关系，有唯一的表头元素和表尾元素，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "邻接矩阵是表示顶点之间相邻关系的矩阵，若图中有n个顶点，则邻接矩阵是一个n×n的矩阵，矩阵中元素的值表示对应顶点之间是否有",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点等，直至遍历",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "完全二叉树是这样一种二叉树，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最底层节点都集中在该层最左边的若干",
    "head": "完全二叉树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接矩阵是一种表示图的方式，其中用一个二维数组来存储顶点之间的连接关系，若顶点之间有边相连则对应位置的值为1（或其他表示有",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它通过将数组构建成一个最大堆或最小堆，然后依次取出堆顶元素并调整堆结构，",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将线性表中的元素与要查找的关键字进行比较，若找到则返回该元素的位置，若遍历完整个线性表都",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有从属于父节点、数量可因父节点而异、与父节点通过特定关系关联等特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点间的关系通过边来表示，边可以具有权重等属性，图中的顶点可以是各种类型的对象，边可以",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "选择排序是一种排序算法，其核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树中所有结点的度的最大值就是树的度其核心特征是反映树中各结点分支情况的最大值体现了树的复杂程度取决于树中拥有最多子树的结点",
    "head": "树的度",
    "tail": "子树",
    "head_offset": "14",
    "tail_offset": "56"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表构成，顶点表中每个顶点对应一个链表，链表中的节点表示与该顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑关系上相邻的元素在物理位置上也相邻，通过数组来存储元素，可随机访问元素且在进行插入和删除操作时",
    "head": "线性表",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "34"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，其中n≥0，当n=0时为空表，并且线性表中的数据元素之间存在一对一的线性",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回路的核心特征是存在一条路径能够从回路中的某一顶点出发，沿着边遍历，最终回到该起始顶点，且路径中经过的顶点和边均不重复（除",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，按照层次依次访问节点，先访问起始节点，再访问其邻接节点，然后是邻接节点的邻接节点等，直到遍历",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的查找的核心特征是基于树的层次结构，从根节点开始，按照特定规则依次比较节点值，以确定目标元素是否存在于树中，若存在则返回",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "循环链表的核心性质是表尾节点的指针域指向表头节点从而形成一个环形结构使得从表中任一节点出发均可通过遍历操作到达表中其他节点",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树的遍历是指按照某种规则依次访问二叉树中的每一个节点且仅访问一次，常见的遍历方式有前序遍历（先访问根节点，再递归访问左",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "二叉树的每个节点最多有两个子节点，分别称为左子节点和右子节点，并且二叉树可以为空树，其节点之间存在严格的层次关系，根节点是",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它通过构建最大堆或最小堆，不断将堆顶元素与堆末尾元素交换并调整堆结构来实现对",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的查找的核心特征是基于树的层次结构，从根节点开始，按照特定规则（如比较节点值等）逐层向下搜索，以确定目标元素是否存在于树",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "无向图是一种图结构，其中边没有方向，顶点之间的连接是双向的，任意两个顶点之间若存在边则可从其中一个顶点到达另一个顶点且反之",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中存储与该顶点相邻接的其他顶点信息，从而以链表形式直观地表示图中",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "选择排序的核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素在计算机存储空间中的存储方式，包括数据元素自身值的存储表示以及数据元素之间关系的存储表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接表的核心性质是通过为图中每个顶点建立一个单链表，链表中每个节点包含与该顶点相邻的顶点信息，从而简洁高效地表示图的结构及",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "堆排序的特点的核心性质是利用堆这种数据结构，将待排序数组构建成最大堆或最小堆，然后通过不断取出堆顶元素并调整堆来实现排序，",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它先将待排序序列构建成最大堆或最小堆，然后依次取出堆顶元素并调整堆，直到整个",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它通过构建最大堆或最小堆，将堆顶元素与末尾元素交换，然后调整剩余元素形成新堆，重复此",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示方式，它具有能体现数据元素间逻辑关系、规定数据的存储方式及相关操作等特点",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的顶点，从而直观地反映图中各",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "选择排序的核心性质是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "父节点是在树形结构中，其直接有子节点与之相连，且对于子节点来说该节点处于上一级的节点，它在层级关系中具有高于其子节点的位置",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个与要查找的关键字进行比较，直到找到匹配的元素或者遍历完整个数据序列",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "邻接矩阵是表示顶点之间相邻关系的矩阵，若图中有n个顶点，则邻接矩阵是一个n×n的矩阵，矩阵中元素的值表示对应顶点之间是否有",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的有限序列，这些元素存储在连续的内存空间中，通过数组名和下标来唯一标识每个元素",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "在树形结构中，对于某一节点而言，直接位于其上方且与该节点通过特定关系相连的节点就是该节点的父节点，父节点拥有比子节点更高的",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "45",
    "tail_offset": "49"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，依次对每一对相邻元素进行此操作，直到整个数组都被排序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "50"
  },
  {
    "sentence": "树的查找是在给定的树结构中，按照特定规则从根节点开始，通过比较节点值等方式确定是否存在特定目标元素以及其所在位置的操作过程",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "21"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中存储与该顶点相邻接的其他顶点，从而以一种链表形式直观地表示图中",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "二叉搜索树是一种二叉树，其每个节点的左子树中的所有节点的值均小于该节点的值，右子树中的所有节点的值均大于该节点的值，且左右",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉搜索树的特点是左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且左右子树也分别为二叉搜索树",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "加权图的核心性质是图中每条边都被赋予一个数值权重，这些权重用于表示边的某种属性或代价等，不同边的权重值可以不同，并且权重在",
    "head": "加权图",
    "tail": "边的权重",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "选择排序是一种排序算法，其核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表是一种链表数据结构，每个节点除了包含数据域外还包含两个指针，一个指向前驱节点，另一个指向后继节点，从而支持双向遍历",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的核心特征是具有一个根节点，根节点没有前驱，且除根节点外，其余每个节点有且仅有一个前驱，同时每个节点可以有零个或多个后继",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "11",
    "tail_offset": "15"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，是树的起始点，树中的其他节点都直接或间接连接到根节点，通过根节点可以遍历整个",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且每个节点有零个或多个子节点，除根节点外每个节点有且仅有一个父节点，并且具有层次",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "17",
    "tail_offset": "32"
  },
  {
    "sentence": "父节点的核心性质是在树形结构中，每个节点有且仅有一个直接前驱节点被称为父节点，它与子节点存在特定的关联关系，子节点依赖于父",
    "head": "父节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "根节点是树结构中没有前驱节点且唯一的起始节点，它处于树的顶层位置，是整个树状结构的入口和基础，所有其他节点都直接或间接连接",
    "head": "根节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问离起始节点距离为 0 的节点，再依次访问距离为 1、2 等的节点，直到访问完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树中从根节点到最远叶子节点的最长简单路径上的节点数就是树的深度树的深度具有每层节点数随着深度增加而变化以及从根节点到叶节点",
    "head": "根节点",
    "tail": "叶子节点",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "图的核心性质包括顶点集合、边集合以及顶点与边之间的关联关系等，其中顶点集合是图中所有顶点的集合，边集合是连接顶点的边的集合",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "14"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回路的核心性质是从回路中任一顶点出发，沿回路的边遍历，最终能回到起始顶点且所经过的边不重复，并且回路中各顶点之间存在特定的",
    "head": "回路",
    "tail": "回路",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "无向图是一种图结构，由顶点集合以及顶点之间的边集合组成，其中边是没有方向的，即连接两个顶点的边没有特定的起始顶点和终止顶点",
    "head": "无向图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序的核心特征是将数组构建成一个堆，利用堆的特性，每次取出堆顶元素并重新调整堆，使得剩余元素依然保持堆的结构，最终实现对",
    "head": "堆排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元，包含数据以及指向子节点的指针，根节点是树的起始节点没有父节点，除根节点外每个节点有且仅有",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "映射是一种特殊的二元关系，它在两个集合之间建立联系，使得对于一个集合中的每个元素，在另一个集合中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元，包含数据项以及指向其子节点的指针（对于非叶子节点），并且具有唯一标识以确定其在树中的位置",
    "head": "树的节点",
    "tail": "数据项",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "二分查找是在有序数组中，通过不断将数组中间元素与目标值比较，若相等则找到目标，若中间元素大于目标值则在左半部分继续查找，若",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "广度优先搜索是一种图或树的遍历算法，按照层次依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点等",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "非线性结构中各数据元素之间的逻辑关系不再是线性的，存在一对多或多对多的关系，不像线性结构那样数据元素之间是一对一的顺序关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "父节点是树结构中直接与一个或多个子节点相连且处于子节点之上层次的节点，具有能唯一标识其下子节点集合的作用并且在树的层级关系",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它先将数组构建成一个堆，将堆顶元素与末尾元素交换，然后将剩余元素重新调整",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它的特点包括对于图中的每个顶点，都有一个链表来存储与该顶点相邻接的其他顶点，顶点与链表中",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，其中顶点集合不能为空，顶点间的关系可以是有向的或无向的，且顶点间的关系通过",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，是图中表示各种实体或对象的节点，具有标识自身的属性且与图中的边存在关联关系以构成图的拓扑",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "树的节点有一个根节点，除根节点外每个节点有且仅有一个父节点，每个节点可以有零个或多个子节点，节点之间通过边相连形成层次结构",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "广度优先搜索是一种图或树的遍历算法，按照层次依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点等",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树遍历是按照某种特定顺序访问二叉树中的每个节点，核心特征包括先序遍历为先访问根节点再递归访问左子树和右子树，中序遍历为",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除第一个元素外每个元素有且",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序数据构建成一个堆，利用堆的特性不断取出堆顶元素并调整堆结构，从而实现数据的",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回路是数据结构中从一个顶点出发，沿某条路径搜索后又回到该顶点的路径，其核心特征包括存在至少一条边，且起点和终点为同一顶点，",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "树是一种非线性数据结构，它有一个根节点，其余节点被分为若干互不相交的子树，每个子树也是一棵树，且具有一对多的关系，即一个父",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "16",
    "tail_offset": "34"
  },
  {
    "sentence": "抽象数据类型具有数据对象、数据对象上的关系集合以及定义在这些关系集合上的基本操作集合，且其定义与具体实现分离只关注逻辑特性",
    "head": "抽象数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "选择排序是一种排序算法，其核心性质是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表构成，顶点表中每个顶点对应一个链表，链表中的节点表示与该顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中每个顶点对应一个链表，链表中的节点表示与该顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "堆是一种优先队列数据结构，它是一棵完全二叉树，每个节点的值都大于或等于其子节点的值（大顶堆）或小于或等于其子节点的值（小顶",
    "head": "队列",
    "tail": "完全二叉树",
    "head_offset": "6",
    "tail_offset": "17"
  },
  {
    "sentence": "邻接表的特点的核心特征是对于图中的每个顶点，用一个单链表来存储其所有邻接顶点，通过这种方式可以高效地表示图的结构并方便进行",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它先将待排序数据构建成最大堆或最小堆，然后依次取出堆顶元素并调整堆结构，直到",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "双向链表是一种数据结构，其每个节点除了包含数据域外还包含两个指针域，分别指向前驱节点和后继节点，通过这些节点的链接构成链表",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点等，直至遍历",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树的每个节点最多有两个子节点，分别称为左子节点和右子节点，并且二叉树可以为空树，其递归定义为一棵二叉树要么为空，要么由",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将关键字与线性表中的元素进行比较，直到找到与关键字相等的元素或到达线性表的末尾的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的查找的核心特征是基于树的结构特性，从根节点开始，按照特定的规则（如比较节点值等）逐步遍历节点，以确定目标元素是否存在于",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中每个顶点对应一个链表，链表中每个节点表示与该顶点相邻的顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "子节点是树结构中与某个特定节点直接相连且处于其下一层级的节点，具有唯一父节点，并且在所属树结构中按特定层次关系排列，通过父",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "邻接表中顶点表的每个结点包含顶点信息和指向第一条边的指针，边表的每个结点包含邻接顶点信息和指向下一条边的指针，通过这种方式",
    "head": "邻接表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "线性表的核心特征是具有唯一的表头元素且除表头元素外每个元素有唯一前驱，具有唯一的表尾元素且除表尾元素外每个元素有唯一后继，",
    "head": "线性表",
    "tail": "表头",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它将待排序数组构建成一个最大堆或最小堆，然后依次取出堆顶元素并调整堆结构",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中每个节点表示与该顶点相邻接的顶点，从而以链表形式直观地展示图中",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "回溯法基础的定义的核心特征是在包含问题所有解的解空间树中，按照深度优先搜索的策略，从根节点出发搜索解空间树，当发现当前节点",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中的节点表示与该顶点相邻接的其他顶点，以此来存储图的边信息，方便",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "选择排序是一种简单直观的排序算法，它在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性，通过特定的遍历方式从根节点开始，沿着分支路径逐步比较节点关键字来确定目标元素是否存在于树中",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "21"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它利用堆的特性将数据序列构建成最大堆或最小堆，然后通过不断取出堆顶元素并调整堆来实现",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆排序是利用堆这种数据结构所设计的一种排序算法，它将数组构建成一个最大堆或最小堆，通过不断取出堆顶元素并调整堆来实现对数组",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中直接连接到父节点下方的节点，具有比父节点更低的层级，其数量根据父节点的分支情况而定，且每个子节点可能有自己",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接矩阵是表示顶点之间相邻关系的矩阵，若图中有n个顶点，则邻接矩阵是一个n×n的矩阵，矩阵中元素的值表示对应顶点之间是否有",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成，顶点用于表示事物，边用于表示事物之间的关系，且边是顶点的无序对或有序对",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "加权图的核心性质是图中每条边都被赋予一个权重值，这些权重值用于表示边的某种属性或代价，在进行相关算法操作如最短路径计算等时",
    "head": "加权图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "55"
  },
  {
    "sentence": "子节点是树结构或图结构中，直接与某一节点相连且处于该节点下方层次的节点，具有与父节点存在直接连接关系且位置低于父节点的特点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "根节点是树结构中的起始节点，没有父节点且具有唯一标识，在树的层次结构中处于最高层位置，其他节点均直接或间接连接于该节点，它",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其特点是数据元素之间存在一对一的线性关系，有唯一的头元素和尾元素，除头元素外",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "有向图的核心特征是其边具有方向性，即从一个顶点指向另一个顶点，顶点之间的连接关系不是对称的，存在从特定起点到终点的有向路径",
    "head": "有向图",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "59"
  },
  {
    "sentence": "子节点是树结构中，直接连接在某个节点之下的节点，它与父节点存在直接的层次关系，父节点通过特定的连接方式引出子节点，子节点是",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的值进行比较，直到找到匹配元素或遍历完整个序列仍未找到的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，通过重复执行某一计算过程逐步逼近目标解的方法，具有计算过程简单、易于编程实现、能逐步",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "根节点是树结构中的起始节点，它没有父节点，是整个树的入口点，所有其他节点都直接或间接连接到根节点，从根节点出发可以遍历整个",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中每个数据元素在序列中都有唯一的前驱（第一个元素除外）和唯一",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "选择排序的核心性质是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值的方法通过重复执行某一计算过程从一个初始估计值出发逐步逼近所求的目标值在每次迭代中利用",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树的查找是指在给定的树结构中，从根节点开始，按照特定的规则遍历节点，以确定是否存在特定关键字或满足特定条件的节点的操作过程",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "16"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，其核心性质是利用堆的特性将待排序数据构建成一个最大堆或最小堆，每次从堆顶取出最大",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑结构上相邻的元素在物理存储位置上也相邻，通过数组来实现数据的存储，其元素存储紧凑，可随机访问，",
    "head": "线性表",
    "tail": "逻辑结构",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中每个节点表示与该顶点相邻的顶点，从而以链表形式存储图中顶点的邻",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "堆排序的核心特征是将待排序的数据构建成一个堆，即满足堆的性质（最大堆中父节点的值大于或等于其子节点的值，最小堆中父节点的值",
    "head": "堆排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点等，直至遍历",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "归并排序的核心特征是采用分治策略将数组不断分成较小子数组分别排序，再把已排序的子数组合并成最终有序数组，具有稳定排序、时间",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值可以表示边的某种属性或代价，其核心性质在于边具有权重这一特性影响",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示边的某种属性或代价，加权图的核心特征在于边具有权重，这些权重",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中存储与该顶点相邻接的其他顶点，从而以一种链式存储结构来表示图的",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "父节点是在树形结构中位于某个节点之上，能够直接衍生出该节点的节点，具有衍生出子节点的特性，在树的层级关系中处于较高层级，对",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "路径是图中从一个顶点到另一个顶点的顶点序列，其特点包括顶点序列中相邻顶点之间存在边，路径长度是路径上的边的数目，简单路径是",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "稳定性是指在数据结构的操作过程中，数据元素的相对位置保持不变，或者在特定条件下，数据结构的性质不会因某些操作而被破坏的性质",
    "head": "稳定性",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表构成，顶点表中每个顶点对应一个链表，链表中的节点表示与该顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "树的查找的核心特征是基于树的结构特性，从根节点开始，按照特定规则（如比较节点值等）逐步遍历节点，以确定目标元素是否存在于树",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点间的关系通过边来表示，顶点集不能为空而边集可以为空，图中的边可以是有向",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点即左子节点和右子节点并且二叉树是一种树形结构它的根节点没有父节点而其余每个节点都",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除第一个元素外每个元素有且",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它将待排序的数据构造成一个最大堆或最小堆，每次从堆顶取出最大或最小元素，",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，且子节点又可以有自己的子节点，以此类推形成层次关系",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，其核心特征是先将待排序数据构建成一个最大堆或最小堆，然后每次从堆顶取出最大或最小",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "邻接矩阵是表示顶点之间相邻关系的矩阵，若图中有n个顶点，则邻接矩阵是一个n×n的矩阵，矩阵中元素的值表示对应顶点之间是否有",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "顺序查找的核心性质是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "归并排序是将一个序列分成两个子序列分别进行排序，再把已排序的子序列合并成一个最终的有序序列的排序算法，其核心特征是分治策略",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，且数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "冒泡排序的核心特征是通过多次比较和交换相邻元素，将最大（或最小）的元素逐步“冒泡”到数组的末尾（或开头），每一趟比较都会将",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底，其操作遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "引用是给对象起一个别名，对引用的操作实际上就是对其绑定对象的操作，引用必须在定义时初始化且一旦初始化便不能再绑定到其他对象",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "41",
    "tail_offset": "47"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它将待排序数据构建成一个堆，利用堆的特性不断取出堆顶元素并调整堆，从而实现对",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "选择排序是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树的遍历的核心特征是按照某种特定顺序访问二叉树中的每个节点且仅访问一次，该顺序规定了先访问根节点、左子树节点还是右子树",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换操作以逐步将元素按特定顺序排列，通常具有操作较为直观、实现相对简单但时间复杂度较高等特点",
    "head": "简单排序",
    "tail": "时间复杂度",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "树的节点的核心特征是具有一个数据元素以及零个或多个指向子节点的指针，其中根节点没有父节点，除根节点外每个节点有且仅有一个父",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "操作效率是指在数据结构中执行特定操作（如插入、删除、查找等）所花费的时间或资源与操作规模（如数据元素数量）之间的关系体现出",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "二叉树的遍历是按照某种规则依次访问二叉树中的每个节点使得每个节点被访问且仅被访问一次，其分为前序遍历（根左右）、中序遍历（",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "队列是一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，遵循先进先出（",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其核心特征包括是一个二维数组，行数和列数与图中顶点数相同，矩阵元素值表示对应顶点之间是否有",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "堆排序的特点的核心性质是利用堆这种数据结构，将待排序数组构建成最大堆或最小堆，通过不断取出堆顶元素并调整堆来实现排序，具有",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "有向图的核心特征是其边具有方向性，即从一个顶点指向另一个顶点，这种方向性决定了图中顶点之间的关系不是对称的，不同于无向图中",
    "head": "有向图",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "57"
  },
  {
    "sentence": "简单排序是对数据元素按照特定规则进行比较和交换等操作以实现有序排列，其核心性质包括比较相邻元素大小并根据比较结果调整顺序等",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中直接连接到父节点之下的节点，具有与父节点直接关联、处于父节点分支末端、拥有自身数据或信息且在树的层次结构中",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑结构中数据元素之间是一对一的线性关系，其物理存储结构是将数据元素依次存储在一片连续的存储单元中",
    "head": "线性表",
    "tail": "逻辑结构",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "队列是一种特殊的线性表，其特点是先进先出，即先进入队列的元素先出队列，新元素始终添加在队列末尾，删除操作始终在队列头部进行",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "比较排序是基于元素间的比较来确定元素之间的相对次序从而实现排序的算法，其核心特征在于通过不断比较元素大小来逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "选择排序是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二分查找是在有序数组中，通过不断将数组中间元素与目标值比较，若相等则查找成功，若目标值小于中间元素则在左半部分继续查找，若",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "选择排序是一种简单直观的排序算法，它在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是利用堆这种数据结构所设计的一种排序算法，它将数组构建成一个最大堆或最小堆，通过不断取出堆顶元素并调整堆结构来实现对",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其特点的核心特征包括有且仅有一个开始元素和一个终端元素，除开始",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底，其操作遵循后进先出原则",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "队列是一种先进先出的数据结构，其核心性质是元素按照进入的顺序依次从队尾进入，从队头取出，队尾用于添加元素，队头用于删除元素",
    "head": "队列",
    "tail": "队头",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "邻接矩阵是用于表示图的数据结构，其中矩阵的行和列对应图的顶点，矩阵元素表示对应顶点之间是否存在边，若存在则为1，不存在则为",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "路径的核心特征是连接两个或多个点，并且具有一定的长度和方向，它可以是实际的物理路线，也可以是抽象的概念上的路线，用于描述从",
    "head": "路径",
    "tail": "路线",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "二叉树的特点是每个节点最多有两个子节点，并且可以为空，同时具有递归结构，其根节点是二叉树的起始点，每个节点的子树也都是二叉",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "子节点是树结构中与某一节点直接相连且处于该节点下方层次的节点，它具有相对于父节点的特定位置关系并继承了父节点的部分关系属性",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中每个节点表示与该顶点相邻接的顶点，从而以链表形式直观地存储图的",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底，数据的进出遵循后进先出",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "选择排序是一种排序算法，其核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "选择排序是一种排序算法，它的核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "选择排序是一种排序算法，其核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "子节点的核心特征是它是某个节点的直接后继节点，处于该节点的下一层级，与该节点存在明确的父子关系，并且继承了父节点的部分属性",
    "head": "子节点",
    "tail": "后继节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "选择排序的核心性质是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点的搜索算法，从起始节点开始，先访问其所有邻接节点，再依次访问这些邻接节点的邻",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，其数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "图的顶点是图的基本组成元素之一且图由顶点集合以及顶点之间的边集合构成顶点是边的连接点顶点具有唯一标识顶点之间通过边相互关联",
    "head": "图的顶点",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它将待排序数组构建成一个堆，将堆顶元素与末尾元素交换，然后将剩余元素重新",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序的核心性质是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，直到整个数组都被排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "顺序查找的核心性质是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，其中n≥0，且每个数据元素在线性表中都有唯一的前驱和后继（第一个元素无前",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，该权重值表示这条边的某种代价、成本、距离或其他相关度量，图中顶点之间通过",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问的节点的邻接节点会比后访问节点的邻接节点更早被访问，且会遍历完一层所有节点后",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "归并排序是将一个序列分成两个子序列，对这两个子序列分别进行排序，然后将排序好的子序列合并成一个有序的序列，其核心特征是通过",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "二叉搜索树的特点是左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且左右子树也分别为二叉搜索树",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "线性表的特点的核心特征是数据元素之间存在一对一的线性关系，有唯一的头元素和尾元素，除头元素外每个元素有唯一前驱，除尾元素外",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它利用堆的特性将无序数组构建成最大堆或最小堆，通过不断取出堆顶元素并调整堆结构来实现",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "选择排序是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每个节点一次且仅一次，其核心特征包括先序遍历是先访问根节点，再递归访问左子树和",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，除根节点外每个节点被唯一的一条路径连接到根节点，",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "父节点是在树形结构中直接有子节点与之相连且位于子节点之上层次的节点，它具有比子节点更高的层级地位并对其下子节点存在关联关系",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与给定的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，一个指向后继节点，从而使得链表可以双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "树的深度是从根节点开始自顶向下逐层累加，到最远叶子节点所经过的层数，其核心特征为以根节点为起始，沿着最长路径到达叶子节点所",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有自己的子节点，以此类推，具有层次",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "树的节点的核心特征是具有一个数据元素以及零个或多个指向子节点的指针，其中根节点没有父节点，除根节点外每个节点有且仅有一个父",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，其中n≥0，当n=0时为空表，并且线性表中的数据元素之间存在一对一的线性",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，它可以用来表示实际问题中的对象或实体，并且在图中通过边与其他顶点相连接以构成图的结构关系",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序的数据构建成一个最大堆或最小堆，通过不断取出堆顶元素并调整堆结构来实现排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "选择排序的核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "子节点的核心特征是它与父节点存在特定关联关系，是由父节点衍生出来的节点，在层次结构中处于父节点之下，继承了父节点的部分属性",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "邻接矩阵的核心特征是用矩阵形式表示图中顶点之间的邻接关系，矩阵元素的值表示对应顶点之间是否有边相连，对于无向图矩阵是对称的",
    "head": "邻接矩阵",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "52"
  },
  {
    "sentence": "邻接矩阵是表示顶点之间相邻关系的矩阵，若图中有n个顶点，则其邻接矩阵是一个n×n的矩阵，矩阵中元素的值表示对应顶点之间是否",
    "head": "邻接矩阵",
    "tail": "邻接矩阵",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "父节点是树结构中直接位于某一节点之上的节点，具有唯一的子节点指向关系，它在层次结构中处于较高层次，是子节点的直接前驱，并且",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，数据元素之间存在一对一的线性关系，有唯一的表头元素和表尾元素，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的节点的核心特征是具有一个数据元素以及零个或多个指向子节点的指针这些子节点也各自具有类似结构从而形成一种层次化的结构关系",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树的节点的核心特征是具有一个数据元素以及零个或多个指向子节点的指针，并且除根节点外每个节点有且仅有一个父节点，根节点没有父",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过该指针可以间接访问其所指向的变量，从而实现对不同内存位置数据的操作和管理",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许操作的一端称为栈顶，不允许操作的一端称为栈底，按照后进先出的原则存储",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "树的节点的核心特征包括有一个根节点，除根节点外其余节点有且仅有一个父节点，每个节点可以有零个或多个子节点，并且节点之间具有",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "递归基础是递归定义中满足初始条件的部分其核心性质是具有明确的、无需进一步递归即可确定的初始值或基本情况为递归过程提供起始点",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径，具有能回到起始节点、包含多个节点和边的有序序列、在连通图中可用于判断图",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与要查找的关键字进行比较，若找到则返回该元素的位置，若遍历完整个线性表都",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它通过构建最大堆或最小堆，将堆顶元素与末尾元素交换，然后对剩余元素重新调整堆，重复此",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "图的顶点是图结构中用于表示数据元素的节点，它可以与其他顶点通过边相连，用于构成图的结构并在图的各种操作和算法中作为基本处理",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其特点的核心特征为：矩阵元素表示顶点之间是否存在边，对于无向图矩阵对称，对于有向图则不一定",
    "head": "邻接矩阵",
    "tail": "无向图",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "选择排序的核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数据的物理结构的核心性质是数据元素在计算机中的存储方式以及它们之间的逻辑关系如何通过计算机内存或存储设备中的物理位置来体现",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树是一种树形结构，其每个节点最多有两个子节点，分别称为左子节点和右子节点，并且具有递归性质，即其本身以及左右子树也都是",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "堆排序是指利用堆这种数据结构所设计的一种排序算法，它将待排序数组构建成一个堆，通过不断取出堆顶元素并调整堆结构，从而实现对",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，其核心性质为：堆是一个完全二叉树，且每个节点的值都大于或等于其子节点的值（大顶堆",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每个节点，且每个节点仅被访问一次，该顺序包括先访问根节点、再递归访问左子树和右",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "树的查找是在给定的树结构中，依据特定规则从根节点开始，通过比较节点的键值等信息，逐步确定是否存在目标元素，若存在则返回包含",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "21"
  },
  {
    "sentence": "堆排序的特点的核心性质是利用堆这种数据结构，将待排序序列构建成一个最大堆或最小堆，根节点的值最大或最小，然后依次将根节点与",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树的遍历是指按照某种特定顺序访问二叉树中的每一个节点且每个节点仅被访问一次的操作，其遍历方式主要有前序遍历（根节点、左",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其核心特征是以矩阵形式展示图中顶点间的相邻关系，矩阵的行和列分别对应图的顶点，矩阵元素的值",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "50"
  },
  {
    "sentence": "树的节点有一个根节点，除根节点外每个节点有且仅有一个父节点，每个节点可以有零个或多个子节点，节点按层次关系组织形成树形结构",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，一个指向后继节点，从而使得链表可以双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据具有快速查找插入和删除操作平均时间复杂度接近常数的特点",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中每个顶点对应一个链表，链表中的节点表示与该顶点相邻接的顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除第一个元素外每个元素有且",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，它先将数组构建成最大堆或最小堆，然后依次取出堆顶元素并调整堆，从而实现对数组元素",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的查找是在给定的树结构中，通过特定的方法从根节点开始沿着节点间的连接关系寻找满足特定条件（如特定关键字值等）的目标节点的",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "22"
  },
  {
    "sentence": "深度优先搜索是一种在搜索过程中沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径的搜索算法",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可依次访问链表中的各个节点，且除尾",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心特征是数据元素按照先进先出的原则进行排列，即先进入队列的元素先离开队列，新元素总是添加在队列的",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的查找特点是基于树这种数据结构，从根节点开始，按照特定规则（如二叉排序树的比较规则等）逐步遍历节点，以确定是否存在目标元素",
    "head": "查找",
    "tail": "树",
    "head_offset": "2",
    "tail_offset": "9"
  },
  {
    "sentence": "根节点是树结构中的起始节点，其核心特征为没有父节点，是树中所有其他节点的直接或间接祖先，树从根节点开始逐步衍生出其他节点从而",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且每个节点有零个或多个子节点，除根节点外每个节点有且仅有一个父节点，并且不存在回路",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "17",
    "tail_offset": "32"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将线性表中的元素与要查找的关键字进行比较，若找到相等的元素则查找成功，若遍历完整个线性表都",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，其特点包括具有特定的数据值范围、有相应的存储形式、定义了针对该类型",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据的逻辑结构的核心性质是数据元素之间的逻辑关系，它独立于数据的存储方式，描述了数据元素之间的抽象关系而非具体的物理存储细节",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "操作效率的特点是指在数据结构中执行各种操作（如插入、删除、查找等）时所表现出的时间和空间方面的特性包括操作的时间复杂度和空间",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "堆排序的核心特征是将数组构建成一个堆，其中大顶堆每个节点的值都大于或等于其子节点的值，小顶堆每个节点的值都小于或等于其子节点",
    "head": "堆排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "堆排序的特点的核心性质是利用堆这种数据结构，将待排序序列构建成一个最大堆或最小堆，然后不断取出堆顶元素并调整堆结构，从而实现",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心特征是通过不断比较序列中的元素，并在满足特定条件时交换元素的位置，从而逐步将序列调整为有序状态",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的核心特征是有且仅有一个根节点，其余节点被分为若干互不相交的有限集合，每个集合又是一棵树且称为该根节点的子树，并且树中没有",
    "head": "根节点",
    "tail": "集合",
    "head_offset": "13",
    "tail_offset": "33"
  },
  {
    "sentence": "堆排序是一种利用堆这种数据结构所设计的排序算法，它将待排序的数据构建成一个最大堆或最小堆，每次从堆顶取出最大或最小元素，依次",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它的特点的核心性质包括对于图中的每个顶点都有一个链表，链表中存储了与该顶点相邻接的其他顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "子节点是树结构或图结构等数据结构中，直接与某个特定节点相连且处于其下一层级的节点，具有与父节点存在特定连接关系并共同构成相应",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "数据的物理结构的核心性质包括数据元素在计算机中的存储方式以及数据元素之间的逻辑关系如何通过计算机内存中的存储单元来体现等方面",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "树的查找是在给定的树结构中，从根节点开始，按照特定规则沿着树的分支进行搜索，以确定是否存在特定数据元素的操作过程其核心特征是",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中的所有节点的值都小于该节点的值，而右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二叉搜索树的核心性质是左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且左右子树也都是二叉搜索树",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "双向链表每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，这使得它可以双向遍历，在插入和删除节点时更灵活高效，且",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其核心特征是通过构建有序序列，对于未排序数据，在已排序序列中从后",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "子节点是树结构或图结构中，与某个特定节点直接相连且处于该节点下方层级的节点，其具有与父节点存在明确连接关系并在结构层次上低于",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有且仅有一个根节点，并且每个节点最多有一个父节点，同时除根节点外每个节点都有且仅有一条从父节点到",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "20",
    "tail_offset": "35"
  },
  {
    "sentence": "堆排序的核心特征是将数组构建成一个堆，其中大顶堆每个节点的值都大于或等于其子节点的值，小顶堆每个节点的值都小于或等于其子节点",
    "head": "堆排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程将最大元素逐步“冒泡”到数组末尾，对数组进行升序或降序排序的算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "操作效率的特点是指在数据结构中各种操作（如插入、删除、查找等）所花费的时间以及占用的空间等方面表现出的特性，包括时间复杂度和",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有自己的子节点，以此类推形成层次结构",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉搜索树的核心性质为左子树上所有节点的值均小于根节点的值且右子树上所有节点的值均大于根节点的值，其左右子树也分别为二叉搜索",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它利用堆的特性将数据序列构建成一个堆，然后通过不断交换堆顶元素与末尾元素并调整堆来实现",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "父节点的核心性质是在树形结构中，一个节点存在直接的前驱节点，该前驱节点即为其父节点，且一个节点只能有一个父节点（根节点除外，",
    "head": "父节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个与要查找的目标元素进行比较，直到找到目标元素或遍历完整个数据序列为止",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "树的深度是从根节点到最远叶子节点所经过的最长简单路径上的节点数决定的其具有从根节点开始逐层向下延伸且每层节点到根节点距离不同",
    "head": "树的深度",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中的所有节点的值都小于该节点的值，其右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑关系上相邻的元素在物理位置上也相邻，通过数组来存储元素，具有随机访问特性，可按元素序号快速访问，",
    "head": "线性表",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "34"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其核心性质是通过构建有序序列，对于未排序数据，在已排序序列中从后",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回溯法基础的特点是通过深度优先搜索策略，在问题的解空间树中按深度优先方式从根节点出发搜索解，当发现当前节点不满足求解条件时就",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与被查找元素进行比较，若相等则查找成功，若遍历完整个线性表都未找到相等元素",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "算法效率是指算法执行所需的时间和空间资源的量度它反映了算法在解决特定问题时的优劣程度体现为算法的时间复杂度和空间复杂度等指标",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "48",
    "tail_offset": "54"
  },
  {
    "sentence": "树的节点的核心特征是具有一个数据元素以及零个或多个指向子节点的指针这些子节点同样是树的节点并且每个节点在树的结构中具有特定的",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "堆排序的核心特征是将数组构建成一个堆，其中大顶堆每个节点的值都大于或等于其子节点的值，小顶堆每个节点的值都小于或等于其子节点",
    "head": "堆排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，从初始值出发通过有限步骤逐步逼近问题解的方法，其特点包括计算过程相对简单、易于编程实现",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "归并排序是将一个序列分成两个子序列分别进行排序，再把排序好的子序列合并成一个有序序列，其核心特征是通过分治策略将问题不断分解",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树的节点具有有且仅有一个根节点、每个非根节点有且仅有一个父节点、每个节点可以有零个或多个子节点以及节点之间具有层次关系等特点",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是简单的一对一，而是存在一对多、多对一或多对多等复杂关系，数据元素之间的前驱和后继关系不",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，其核心性质是利用堆的特性将待排序数据构建成一个最大堆或最小堆，然后通过不断取出堆顶",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树的遍历是指按照某种规则依次访问二叉树中的每个节点，使得每个节点被访问且仅被访问一次，遍历方式包括先序遍历、中序遍历、后",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点间的关系可以是有向边或无向边，顶点集合不能为空且顶点间关系集合定义了顶点",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中存储与该顶点相邻接的其他顶点信息，从而以一种链式存储结构来表示图",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "树的节点是树结构中的基本数据元素，包含数据项以及指向子节点的分支，根节点没有父节点，非根节点有且仅有一个父节点，叶子节点没有",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序都会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中的所有节点的值均小于该节点的值，其右子树中的所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "归并排序是将一个序列分成两个子序列分别进行排序，再把已排序的子序列合并成一个最终的有序序列，其核心特征是通过递归地将序列不断",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "堆的核心特征是对于堆中的每个节点，其值大于或等于其子节点的值（最大堆）或者小于或等于其子节点的值（最小堆），并且堆是一种完全",
    "head": "堆",
    "tail": "堆",
    "head_offset": "33",
    "tail_offset": "51"
  },
  {
    "sentence": "父节点是树结构中位于某个节点之上，与该节点存在直接连接关系且具有较高层级的节点，其具有能够直接衍生出子节点的特点，在树的层级",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "50"
  },
  {
    "sentence": "二叉搜索树是一棵二叉树，对于其中每个节点，其左子树中的所有节点的值都小于该节点的值，其右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "二叉树",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回路的核心性质是从回路中任意一点出发，沿着回路的边前进，最终能回到出发点且所经过的边互不重复（简单回路）或经过的边可以重复（",
    "head": "回路",
    "tail": "回路",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，且除了尾节点外每个节点的",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的节点具有唯一的根节点，除根节点外每个节点有且仅有一个父节点，节点可以有零个或多个子节点，并且节点之间通过父子关系形成层次",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的查找的核心特征是从根节点开始，按照特定规则遍历树的节点，通过比较节点的值来确定目标元素是否存在于树中，若存在则返回该节点",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "穷举法的核心特征是对问题所有可能的解逐一进行尝试，通过检查每一个可能情况来找到符合条件的解，在面对问题时会遍历所有可能的取值",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "53"
  },
  {
    "sentence": "归并排序是将数组分成两个子数组分别递归排序后再合并，其核心性质是通过分治策略将问题分解为较小子问题，利用合并操作将有序子数组",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中的所有节点的值都小于该节点的值，其右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与要查找的关键字进行比较，若找到相等的元素则查找成功，若遍历完整个线性表都",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "队列是一种特殊的线性表，其核心特征是元素按照先进先出的原则进行排列，即先进入队列的元素先离开队列，后进入队列的元素后离开队列",
    "head": "队列",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的查找是基于树这种数据结构，通过特定规则在其中寻找特定元素，其特点包括查找路径沿树的分支进行且在不同类型树（如二叉查找树等",
    "head": "查找",
    "tail": "树",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "映射的核心特征包括在集合A中的每一个元素在集合B中都有唯一的元素与之对应，集合A中的元素不能有剩余未被对应，且集合B中的元素",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的查找是在给定的树结构中，从根节点开始，按照特定规则遍历节点，以确定是否存在特定值的节点或获取满足特定条件的节点的操作过程",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "15"
  },
  {
    "sentence": "树的查找的核心特征是从树的根节点开始，按照某种特定规则（如二叉排序树的比较大小规则等）沿着树的分支逐步向下查找目标元素，通过",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树遍历的核心特征是按照某种特定顺序访问二叉树中的每个节点且每个节点仅被访问一次，遍历顺序包括前序遍历（根节点、左子树、右",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，并且任意两个节点间有且仅有一条路径相连，除根节点外",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "树的查找是在给定的树结构中，根据特定的条件或关键字，从根节点开始，通过遍历节点及其子节点，以确定是否存在满足查找条件的节点的",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "27"
  },
  {
    "sentence": "图的核心性质是由顶点集合以及顶点之间的边集合所构成的数据结构，顶点之间通过边进行连接，边可以具有权重等属性，图可分为有向图和",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的其他顶点，以此来直观反映图中",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与被查找元素进行比较，若找到相同元素则查找成功，若遍历完整个线性表都未找到",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "加权图的核心特征是图中的边被赋予了一个数值作为权重，该权重用来表示边的某种属性或代价，不同边的权重值可以不同，基于这些权重可",
    "head": "加权图",
    "tail": "边的权重",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据在计算机内存或存储设备中的实际存储方式包括存储位置存储顺序以及数据元素间的物理关系等",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "51"
  },
  {
    "sentence": "哈希表的核心特征是通过哈希函数将键映射为哈希值，并依据该哈希值来确定数据在表中的存储位置，使得数据的插入、查找和删除操作能在",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "操作效率是指在数据结构的各种操作（如插入、删除、查找等）中，完成这些操作所需要的时间、空间等资源的消耗情况以及与问题规模之间",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构，通过构建最大堆或最小堆，不断将堆顶元素与堆末尾元素交换并调整堆，从而实现对数据序列进行排序的",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性查找是从数据序列的一端开始，依次将每个数据元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "21"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到一个固定大小的数组中，使得插入、查找和删除操作的平均时间复杂度为O(1)，具有",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二叉树遍历的核心性质是按照某种特定顺序访问二叉树中的每个节点且仅访问一次，包括前序遍历根节点在前、中序遍历根节点在中间、后序",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "回路是在图中从一个顶点出发，沿着边经过一些顶点后又回到该起始顶点的路径且路径中除起始顶点外其他顶点不重复出现所构成的闭合路径",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "穷举法是一种通过对所有可能的情况进行逐一列举和检验，从而找到满足条件的解的方法其核心性质是在解决问题时会遍历问题的所有可能解",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "52"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找某一特定元素的搜索算法，通过不断将数组分成两部分并比较中间元素与目标元素来确定目标元素所在位置",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序表是一种线性表，其特点是逻辑上相邻的元素在物理存储位置上也相邻，它具有随机访问特性，通过数组形式存储元素，可高效地进行按",
    "head": "线性表",
    "tail": "访问",
    "head_offset": "6",
    "tail_offset": "39"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点间的关系通过边来表示，边可以具有权值等属性且任意两个顶点之间可能存在零条",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序数据构建成一个最大堆或最小堆，然后依次取出堆顶元素并调整堆结构，从而实现数据",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和相关操作的规格说明，而不依赖于具体的实现细节",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "堆排序的特点的核心性质是利用堆这种数据结构，将待排序序列构建成一个最大堆或最小堆，每次取出堆顶元素并调整堆，最终得到有序序列",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的其他顶点，从而直观地反映图中",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中的所有节点的值均小于该节点的值，右子树中的所有节点的值均大于该节点的值，",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，除根节点外每个节点有且仅有一个父节点，并且任意两个",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它通过构建最大堆或最小堆，将堆顶元素与末尾元素交换，然后重新调整堆结构，重复此过程直至",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素，集合中的元素具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问的节点的邻接节点会在后续被访问，且同一层节点的访问顺序不固定，直到遍历完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中的所有节点的值都小于该节点的值，且右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "子节点是树结构或图结构等数据结构中，直接与某个节点相连且处于该节点下方层级的节点，具有与父节点存在特定连接关系并处于其下一层",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "迭代法的核心特征是通过不断重复执行相同的计算步骤，利用上一次迭代的结果来逐步逼近问题的解，每次迭代都会使结果更接近最终目标值",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，其核心性质是利用堆的特性，将待排序序列构建成一个最大堆或最小堆，然后通过不断取出堆",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "操作效率的特点是指在数据结构中进行各种操作（如插入、删除、查找等）时所表现出的时间和空间方面的特性，包括操作所需的时间复杂度",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置以实现快速的数据插入、查找和删除操作，具有平均时间复杂度接近常数的特点",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "堆排序是一种选择排序，它的核心特征是将数组构建成最大堆或最小堆，通过不断取出堆顶元素并调整堆结构来实现排序，具有时间复杂度为",
    "head": "堆排序",
    "tail": "选择排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的节点具有唯一的根节点，除根节点外每个节点有且仅有一个父节点，节点可以有零个或多个子节点，并且不同节点之间通过父子关系形成",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "非线性结构是一个数据元素的有序（或无序）集合，它是指在该结构中至少存在一个数据元素，有两个或两个以上的直接前驱（或直接后继）",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它利用堆的特性将数据逐步排序，具有时间复杂度为O(nlogn)、空间复杂度为O(1)、",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种利用堆这种数据结构所设计的排序算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序，具有",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与被查找元素进行比较，若找到相同元素则查找成功，若遍历完整个线性表都未找到",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序都会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，这些权重可用于表示诸如距离、成本、流量等某种与边相关的度量，以便在图",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "归并排序是一种分治算法，将数组分成两个子数组分别排序，再将排序好的子数组合并成一个有序的数组，具有时间复杂度为O(n log",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或到达表尾，其特点核心性质为对线性表",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素，集合中的元素具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "父节点是在树形结构中直接拥有子节点的节点，具有作为子节点的上级、对其进行层级管理和关联等特点，在数据关系上处于较高层级位置并",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列的合适位置的排序算法其特点是比较次数少、排序速度快、平均时间复杂度为O(n^2)适",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "父节点的核心特征是在树形结构中处于较高层级，拥有子节点，且其属性和行为能够对其子节点产生影响并起到一定的统领或主导作用，是子",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是尾节点的指针指向头节点，形成一个环形结构，使得从链表中的任何一个节点开始都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点间的关系通过边来表示，顶点集合不能为空，边集合可以为空，图分为有向图和无",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "递归基础具有明确的终止条件且能直接给出简单情况的结果其核心性质是为递归过程提供初始状态或边界情况使递归能够逐步展开并最终结束",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "27"
  },
  {
    "sentence": "在数据结构中，稳定性是指在排序过程中，相等元素的相对顺序保持不变，即如果两个元素相等，在排序前它们的相对位置是靠前的那个，在",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "7",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉树是一种树形结构，每个节点最多有两个子节点，分别称为左子节点和右子节点，它具有递归定义的层次结构，并且在数据存储、搜索、",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "树的查找的特点的核心性质包括若存在从根节点到某节点的路径则该路径上的节点与要查找的值进行比较以确定是否找到目标节点且查找效率",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "18"
  },
  {
    "sentence": "树是一种非线性的数据结构，它包含一个根节点以及零个或多个子树，每个子树本身也是一棵树，且除根节点外每个节点有且仅有一个父节点",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "18",
    "tail_offset": "28"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中的所有节点的值均小于该节点的值，其右子树中的所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "图是一种由顶点集合及顶点间的关系集合组成的数据结构，顶点间的关系通过边来表示，边可以具有权重等属性，其特点包括可以表示多对多",
    "head": "集合",
    "tail": "集合",
    "head_offset": "7",
    "tail_offset": "16"
  },
  {
    "sentence": "子节点是树结构中与某一节点直接相连且处于该节点下方层次的节点，它具有相对于父节点的特定位置关系和在树型结构中的特定层级属性以",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，分别称为左子节点和右子节点，并且二叉树可以为空树，其递归定义为一棵二叉树要么为空",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和相关操作，而不依赖于具体的存储结构和实现细节",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，从起始顶点开始，先访问其所有邻接顶点，再依次访问这些邻接顶点的邻接顶点，按照层次依次扩展，直到",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含数据元素以及指向后继节点的指针，通过头节点的指针来访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的节点是树结构中的基本单元，包含数据以及指向其子节点的指针或引用，除根节点外每个节点有且仅有一个父节点，根节点没有父节点，",
    "head": "树的节点",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其核心性质是通过构建有序序列，对于未排序数据，在已排序序列中从后",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有依赖于父节点的层级关系，在特定的树形逻辑结构中有其特定的位置和作用",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "选择排序是在未排序序列中找到最小（大）元素存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点可以有零个或多个子节点，每个子节点又可以有自己的子节点，以此类推形成层次结构",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与被查找元素进行比较，若相等则查找成功，若遍历完整个线性表都未找到相等元素",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，其余节点被分为若干互不相交的子树，每个子树本身也是一棵树，并且具有一对多的关系特点",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "17",
    "tail_offset": "35"
  },
  {
    "sentence": "双向链表的每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，这使得双向链表可以双向遍历，既能从前往后遍历也能从后",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素，集合中的元素具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "选择排序的核心特征是每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序都会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的顶点，从而直观地反映图中顶点",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "穷举法是对问题所有可能的情况进行逐一列举和检验，通过遍历所有可能解来找到满足条件的解，其核心性质是能确保找到问题的完整解空间",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "抽象数据类型是一个数学模型及定义在该模型上的一组操作，其定义包括数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合",
    "head": "抽象数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其核心特征是比较当前元素与已排序部分的元素，若当前元素较小则将已",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，其核心特征包括：对于图中的每个顶点，都有一个链表与之对应，链表中存储了与该顶点相邻接的其他",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "线性表的核心性质是有且仅有一个开始节点没有前驱节点有且仅有一个终端节点没有后继节点其余节点有且仅有一个前驱节点和一个后继节点",
    "head": "线性表",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完同一层的所有节点后，再进入下一层进行访问",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序都会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "迭代法是一种不断用变量的旧值递推新值，从初始值出发逐步逼近问题解，通过重复执行相同或相似计算步骤，直至满足特定收敛条件或达到",
    "head": "迭代法",
    "tail": "递推",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它通过构建最大堆或最小堆，将堆顶元素与末尾元素交换，然后调整剩余元素形成新堆，",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种利用堆这种数据结构所设计的排序算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆来实现排序，具有时间",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有数量可根据父节点情况而定、每个子节点有特定的关联关系、子节点可以再",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问起始节点，再依次访问其邻接节点，然后是邻接节点的邻接节点等，直到遍历完所有节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数据的逻辑结构的特点是描述数据元素之间逻辑关系，独立于数据存储和运算，包括集合、线性、树形、图形等结构且各有其元素关系及特性",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问的节点的邻接节点会在后续被访问，且同一层节点的访问顺序不固定，直到遍历完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将数组中间元素与目标值比较，若相等则找到目标，若中间元素大于目标值则在左半部分继续查找，",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，其核心特征是将数组构建成一个最大堆或最小堆，通过不断取出堆顶元素并调整堆结构来实现排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树遍历的核心性质是按照某种特定顺序访问二叉树中的每个节点且仅访问一次，不同遍历方式（如前序遍历、中序遍历、后序遍历）有着",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可以访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "迭代法的核心性质是通过不断重复相同的计算步骤，从初始值出发逐步逼近问题的解，每一次迭代都利用上一次迭代的结果来生成新的近似解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到一个固定大小的数组中，使得插入、查找和删除操作的平均时间复杂度为O(1)，具有",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "选择排序的核心特征是每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "堆排序是一种利用堆这种数据结构所设计的排序算法，它将待排序的数据构建成一个最大堆或最小堆，然后依次取出堆顶元素并调整堆结构，",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序都会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半来查找目标值，每次比较中间元素与目标值，若相等则找到，若目标值小于中间元素则在左",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在一对一的线性关系，有且仅有一个开始和一个终端节点，并且所有节点都最多有一个前驱和一个后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将数组中间元素与目标值比较，若相等则找到目标，若目标值小于中间元素则在左半部分继续查找，",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构，通过将待排序数据构建成堆，利用堆的特性进行排序，不断将堆顶元素取出并调整堆结构，最终得到有序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树遍历的核心性质是通过特定规则访问二叉树中的每个节点且仅访问一次，不同遍历方式（前序遍历、中序遍历、后序遍历）基于不同的",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "回路是图中从一个顶点出发，沿着边经过一些顶点后又回到该顶点的路径，其核心性质包括至少包含三条边且各边互不相同（简单回路情况）",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成，顶点之间通过边相互连接，边可以具有不同的性质如方向、权重等，图能够直观地",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "冒泡排序是一种比较和交换相邻元素的排序算法，其核心性质是通过多次比较和交换，将最大（或最小）的元素逐步“冒泡”到数组的末尾（",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机存储器中的表示方式以及这种表示所带来的诸如数据访问效率、存储空间利用等方面的特性",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别进行排序，然后将排序好的子数组合并成一个有序数组，其核心性质是通过递归地对数组进行划分",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中每个元素都有且仅有一个直接前驱和一个直接后继（首元素无前驱，尾元素无后继",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将数组构建成最大堆或最小堆，通过不断取出堆顶元素并调整堆来实现排序，具有时间复杂度为",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点之间通过边相连，边可以具有方向或无方向，图可用于表示各种复杂的关系结构，如社交网络中",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素，集合中的元素具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "根节点是树结构中的一个特殊节点，它没有父节点，且树中的其他节点都直接或间接连接到根节点，根节点处于树结构的起始位置并具有引领",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序都会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "线性表是一种数据元素之间存在一对一线性关系的有限序列，其中每个数据元素最多有一个直接前驱和一个直接后继，且数据元素的个数有限",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，另一个指向后继节点，从而使得链表可以双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "循环链表是一种特殊的链表结构，其特点的核心特征是尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中没有明确的尾端，从",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "非线性结构中各数据元素之间的关系不再是一对一的，可能存在一对多、多对一或多对多的关系，其数据元素的逻辑关系不能用线性序列简单",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回路是图中一条至少包含一条边且起点和终点相同的路径其核心性质是从起点出发沿着边遍历最终能回到起点且途中经过的边和顶点是特定的",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "操作效率是指在数据结构中进行各种操作（如插入、删除、查找等）时所花费的时间、空间等资源的有效程度以及完成这些操作的速度和性能",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "邻接矩阵是表示图的一种方式，其核心特征为：用一个二维数组来存储图中顶点之间的关系，数组中元素的值表示对应顶点之间是否有边相连",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中的节点存储与该顶点相邻接的其他顶点的信息，以此来表示图的结构关系",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "树的查找是指在给定的树结构中，根据特定的条件或关键字，在树的节点中进行搜索以确定是否存在满足条件的节点以及获取该节点相关信息",
    "head": "查找",
    "tail": "树的节点",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个权重值，权重用于表示与边相关的某种度量，例如距离、成本、时间等，图中的顶点通过这些",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它由顶点表和边表组成，顶点表中每个顶点对应一个链表，链表中的节点表示与该顶点相邻的顶点及其",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑关系上相邻的元素在物理位置上也相邻，通过数组来存储元素，元素存储地址连续，可随机访问元素且支持在",
    "head": "线性表",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "34"
  },
  {
    "sentence": "子节点是树状结构中直接连接在父节点下方的节点，其特点包括在层级关系上低于父节点，并且与父节点存在特定的连接关系，可能具有多个",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的其他顶点，从而直观地反映图中",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，其核心特征包括将数组构建成最大堆或最小堆，每次将堆顶元素与堆末尾元素交换，然后重新调整",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其中矩阵的行和列对应图的顶点，矩阵元素的值表示对应顶点之间是否存在边以及边的相关信息（如权重",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "树的节点具有一个数据元素以及零个或多个指向子节点的指针，根节点没有父节点，除根节点外每个节点有且仅有一个父节点，叶子节点没有",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性，通过特定的遍历方式从根节点开始沿着分支逐步搜索目标元素，其效率受树的高度、节点分布等因素影响",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "21"
  },
  {
    "sentence": "线性表是具有相同数据类型的n(n≥0)个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种利用堆这种数据结构所设计的一种排序算法，它将数组构建成最大堆或最小堆，然后通过不断取出堆顶元素并调整堆来实现排序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与被查找元素进行比较，若相等则查找成功，若遍历完整个线性表都未找到相等元素",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的查找是在树结构中按照特定规则确定某个元素是否存在以及其位置的操作，具有从根节点开始逐步比较节点值以定位目标元素的核心性质",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "树的查找的核心特征是基于树的层次结构，从根节点开始，按照特定的规则（如比较节点值等）逐步向下遍历节点，以确定目标元素是否存在",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "堆排序是一种利用堆这种数据结构所设计的排序算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆来实现排序，具有时间",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回溯法是一种通过试探并逐步回溯来求解问题的方法，其核心特征是在搜索解空间时，按照深度优先策略，从根节点出发，不断扩展新节点，",
    "head": "回溯法",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，由表头指针唯一确定，每个节点包含数据域和指针域，指针域指向下一个节点，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始顶点开始，先访问其所有邻接顶点，然后再依次访问这些邻接顶点的邻接顶点，按照层次依次扩展，",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与被查找元素进行比较，若相等则查找成功，若遍历完整个线性表都未找到相等元素",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性，通过特定规则在树中定位特定元素，其查找过程依赖于树的层次关系和节点间的连接方式以高效确定目标",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "33"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，不能用线性结构的数据元素序列来表示的数据结构",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回溯法基础的特点的核心性质是在问题的解空间树中按照深度优先策略搜索解，通过递归地尝试各种可能的选择并在不满足条件时回溯，逐步",
    "head": "回溯法",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的其他顶点，从而实现对图的存储",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "树的节点是树结构中的基本元素，包含数据以及指向子节点的链接，根节点没有父节点，除根节点外每个节点有且仅有一个父节点，叶子节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间路径，在搜索过程中不断回溯以避免无效路径，从而找到问题的可行解或最优解的数据结构求解方法",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它通过构建最大堆或最小堆，将堆顶元素与末尾元素交换，然后重新调整堆，重复此过程直至整个",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，其核心特征是通过构建最大堆或最小堆，将堆顶元素与堆的末尾元素交换，然后调整剩余元素",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "冒泡排序是一种比较和交换相邻元素的排序算法，其核心性质是通过多次比较和交换，将最大（或最小）的元素逐步“冒泡”到数组的末尾（",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和修改所指向的变量的值，能灵活地进行数据的传递和操作，方便",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "父节点的核心性质是在树形结构中，一个节点存在直接的前驱节点，该前驱节点即为其父节点，且每个节点仅有一个父节点（根节点除外，根",
    "head": "父节点",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中的所有节点的值均小于该节点的值，其右子树中的所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "数据类型具有特定的取值范围和操作集合，其核心特征包括具有明确的数据表示形式、规定了可进行的操作以及能保证数据的一致性和安全性",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "树的定义的核心性质是它是一种非线性的数据结构，有且仅有一个根节点，且每个节点有零个或多个子节点，并且任意两个节点之间有且仅有",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "29",
    "tail_offset": "44"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，它们通过边相互连接共同构成图的结构，每个顶点可具有特定的属性且在图中处于特定位置以体现其与",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问的节点的邻接节点会在后续被访问，且同一层节点的访问顺序不固定，直到遍历完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "选择排序是一种排序算法，其核心特征是在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "图的顶点是图结构中的基本元素，是图中数据的载体，图由顶点集合以及顶点之间的边集合所构成，顶点之间通过边相互连接来表示特定关系",
    "head": "图的顶点",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "线性查找是在一个数据序列中从第一个元素开始依次逐个与要查找的目标元素进行比较，直到找到目标元素或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "27"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，是构成图的节点，图中的边连接这些顶点，顶点可以具有各种属性并用于表示实际问题中的对象或实体",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序查找是从数据结构的一端开始，依次将关键字与数据结构中的每个元素进行比较，直到找到匹配的元素或遍历完整个数据结构的查找方法",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，其核心特征是以层为单位依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到表中的特定位置，使得插入、查找和删除操作的平均时间复杂度为O(1)，其核心性质",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接矩阵是用于表示图的一种矩阵，其中矩阵的行和列分别对应图的顶点，矩阵元素的值表示对应顶点之间是否存在边以及边的相关信息（如",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将线性表中的元素与要查找的关键字进行比较，若找到相等的元素则查找成功，若遍历完整个线性表都",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其中每个元素都有且仅有一个直接前驱（除第一个元素外），有且仅有一个直接后继（除",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中的所有节点的值都小于该节点的值，其右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的其他顶点，从而直观地反映图中",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "子节点是树结构中直接位于某个父节点之下的节点，具有与父节点存在直接关联且处于特定层级关系的特点，一个父节点可以有零个、一个或",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其核心特征是通过构建有序序列，对于未排序数据，在已排序序列中从后",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中的所有节点的值均小于该节点的值，其右子树中的所有节点的值均大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树的节点具有一个数据元素以及零个或多个指向子节点的指针，根节点没有父节点，除根节点外每个节点有且仅有一个父节点，叶子节点没有",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，其核心性质包括：堆是一个完全二叉树，每个节点的值大于或等于其子节点的值（大顶堆）或小于",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与要查找的关键字进行比较，若找到相等的元素则查找成功，若遍历完整个线性表都",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "选择排序的核心性质是在未排序序列中找到最小（大）元素存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素，集合中的元素具有确定性、互异性和无序性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到一个固定大小的数组中，使得插入、查找和删除操作的平均时间复杂度为O(1)，具有",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序都会将未排序数据中最大（或最小）的元素“冒泡”到",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "二叉搜索树的核心性质是对于树中的每个节点，其左子树中的所有节点的值都小于该节点的值，其右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "路径是图中顶点与顶点之间的边所构成的序列其核心性质为从起始顶点开始依次通过这些边可到达终止顶点且路径中任意相邻顶点间都有直接",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "在树这种数据结构中，从根节点开始，沿着特定路径搜索特定节点的操作就是树的查找，其核心特征是依据树的结构特性从根出发按一定规则",
    "head": "树",
    "tail": "根节点",
    "head_offset": "1",
    "tail_offset": "11"
  },
  {
    "sentence": "堆排序的核心特征是利用堆这种数据结构进行排序，它将数组构建成最大堆或最小堆，每次取出堆顶元素并调整堆结构，重复此过程直到整个",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作以使其逐渐有序的排序方法包括冒泡排序选择排序插入排序等具体排序方式各有特点和适用场景",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "回路的核心特征是从一个顶点出发，沿着一系列边经过若干顶点后又回到该起始顶点，且路径中边不重复且除起始顶点外中间顶点也不重复，",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，其核心性质是利用堆的特性，将待排序数组构建成一个最大堆或最小堆，然后通过不断取出堆",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置以实现快速的数据插入、查找和删除操作，具有平均时间复杂度接近常数的特点",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问节点，先访问起始节点，再访问其相邻未访问节点，按此顺序逐层扩展直至遍历完所有可达节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将线性表中的元素与被查找元素进行比较，若相等则查找成功，若遍历完整个线性表都未找到相等元素",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间分成两半并根据目标值与中间元素的比较结果来确定目标值所在位置从而高效查找目标值的算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的其他顶点，从而直观地反映图中",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是最后一个节点的指针指向头节点，从而形成一个环形结构，使得链表可以从任意节点开始遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性表是一种由有限个数据元素组成的序列，其中数据元素之间存在一对一的线性关系，即除第一个元素外，每个元素有且仅有一个直接前驱",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，每个节点有零个或多个子节点，除根节点外每个节点有且仅有一个父节点，任意两个节点",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "19",
    "tail_offset": "33"
  },
  {
    "sentence": "线性表的核心特征是具有相同数据类型的n个数据元素的有限序列，其中每个元素在序列中都有唯一的前驱（除第一个元素外）和唯一的后继",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "回路是数据结构中从图的一个顶点出发，沿着边经过若干顶点后又回到该起始顶点且路径中除起始顶点外其他顶点不重复出现的路径所具有的",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "操作效率是指在数据结构的各种操作（如插入、删除、查找等）中，算法执行所花费的时间、空间等资源与问题规模之间的关系以及算法执行",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中每个数据元素都有唯一前驱（第一个元素除外）和唯一后继（最后一个元素除外）",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "子节点是树状结构中直接连接在父节点下方的节点，具有在层次关系中处于较低层级、与父节点通过特定连接关系相连且可能有自己的子节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将线性表中的元素与要查找的关键字进行比较，若找到相等的元素则查找成功，若遍历完整个线性表都",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "子节点是树结构中与某一节点直接相连且处于该节点下方层次的节点，其具有与父节点存在直接连接关系且相对位置在父节点之下的核心特征",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "二叉搜索树的核心特征是对于树中的每个节点，其左子树中的所有节点的值都小于该节点的值，而右子树中的所有节点的值都大于该节点的值",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "父节点的核心特征是在树形结构等层次关系中，直接位于某个节点之上，与该节点存在直接的层级关联，能够对其下一层级的子节点起到统领",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "55"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点较近的节点，具有先进先出的队列特性，能保证以最短路径优先的方式遍历图结构",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其核心特征是通过构建有序序列，对于未排序数据，在已排序序列中从后",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是具有相同数据类型的一组数据元素的有序集合，这些元素在内存中存储在连续的存储单元中，可通过数组名和下标来唯一标识每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "映射是一种特殊的二元关系，它在两个集合之间建立联系，使得对于一个集合中的每一个元素，在另一个集合中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有从属于父节点、可能有多个兄弟节点以及共同构成树状层次关系等特点，是",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，从起始节点开始，先访问其所有邻接节点，再依次访问这些邻接节点的邻接节点，按照层次依次扩展，直到",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序表是一种线性表，其特点是逻辑上相邻的元素在物理存储位置上也相邻，它具有随机访问特性，可通过下标直接访问元素，并且插入和删除",
    "head": "线性表",
    "tail": "访问",
    "head_offset": "6",
    "tail_offset": "39"
  },
  {
    "sentence": "图的顶点是图结构中的基本数据元素，是图中各个节点的统称，用于表示图中的一个具体对象或实体，且具有唯一标识，其可以与其他顶点通过",
    "head": "图的顶点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "选择排序是一种在未排序序列中找到最小（大）元素存放到排序序列起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，通过该别名可以访问其所引用的对象，引用一旦初始化便不能再引用其他对象，且引用必须在定义时初始化",
    "head": "访问",
    "tail": "初始化",
    "head_offset": "23",
    "tail_offset": "37"
  },
  {
    "sentence": "树是一种非线性的数据结构，它由n（n≥0）个有限节点组成一个具有层次关系的集合，其中有一个特定的节点称为根节点，其余节点被分为",
    "head": "集合",
    "tail": "根节点",
    "head_offset": "37",
    "tail_offset": "52"
  },
  {
    "sentence": "数据的逻辑结构的特点是反映数据元素之间逻辑关系且与数据的存储无关，它包括集合、线性结构、树形结构和图状结构等不同类型各有其独特",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序的数据构建成一个最大堆或最小堆，然后依次取出堆顶元素并调整堆结构，从而实现数据",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序的数据构建成一个最大堆或最小堆，然后依次取出堆顶元素并调整堆结构，从而得到有序",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其核心特征为每个节点包含数据域和指针域，指针域指向下一个节点，通过头指针可访问整个链表，数据元素",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将数组分成两部分并比较目标值与中间元素，根据比较结果在左半部分或右半部分继续查找，直到找到",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "快速排序是对无序数组通过选择一个基准值将数组分为两部分，小于基准值的元素在左边大于基准值的元素在右边，再对左右两部分子数组分别",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源的量度，包括时间复杂度和空间复杂度来衡量算法在不同输入规模下的运行效率和资源消耗情况",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "27",
    "tail_offset": "33"
  },
  {
    "sentence": "线性表是一种具有相同数据类型的n个数据元素的有限序列，其特点是数据元素之间存在一对一的线性关系，有唯一的表头元素和表尾元素，除",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "选择排序的核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式逐步逼近问题精确解的方法其核心性质是通过不断重复相同的计算步骤来逐渐改进近似解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有限序列，具有顺序存储、元素类型一致、通过下标唯一标识元素以及可根据下标进行随机访问等核心性质",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，按照层次依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点等，直到遍历",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作该地址所指向的内存单元中的数据，具有灵活高效地实现数据间",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其特点包括每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可访问整个链表，数据元素的",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二叉树遍历是按照某种特定顺序访问二叉树中的每个节点，且每个节点仅被访问一次，其核心性质包括先序遍历先访问根节点再递归访问左子树",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此操作将最大（或最小）元素逐步“冒泡”到数组末尾（或开头）从而实现对数组",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "47"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，直至找到目标值或确定目标值不存在的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "快速排序是对数组进行排序的一种算法，它选择一个基准值，将数组分为两部分，小于基准值的放在左边，大于基准值的放在右边，然后对左右",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "选择排序的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有且仅有一个根节点，且每个节点最多有一个父节点，除根节点外的其他节点被分为若干互不相交的有限集合，",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "20",
    "tail_offset": "34"
  },
  {
    "sentence": "路径是图中顶点与顶点之间经过边的序列，其核心性质包括路径长度为路径上边的数目，简单路径是顶点不重复的路径，回路是起点和终点相同",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "引用是C++中为已存在的变量起的一个别名，通过该别名可以直接访问和操作原始变量，其定义时必须初始化且初始化后不能再引用其他变量",
    "head": "访问",
    "tail": "初始化",
    "head_offset": "30",
    "tail_offset": "46"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点等，直到遍历完所有节点或找到",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其核心性质是通过不断将一个数据插入到前面已排好序的序列中的适当位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问的节点层次浅，后访问的节点层次深，在访问完当前层次的所有节点后再进入下一层",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "引用是给已存在对象起的一个别名，对引用的操作实际上就是对其所引用对象的操作，引用必须在定义时初始化且初始化后不能再引用其他对象",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "46",
    "tail_offset": "50"
  },
  {
    "sentence": "堆排序是一种利用堆这种数据结构特性进行排序的方法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序，具有",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二叉树的遍历是按照某种特定顺序访问二叉树中的每一个节点，并且每个节点仅被访问一次，遍历顺序通常有先序遍历（先访问根节点，再递归",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "子节点是树结构中直接连接在父节点之下的节点，具有与父节点存在特定连接关系、在树的层级结构中有其特定位置且可能存在多个兄弟子节点",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "选择排序的核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，从而确定目标值是否存在及所在位置的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑结构中数据元素之间是一对一的关系，其存储结构采用顺序存储方式，即把逻辑上相邻的元素存储在物理位置上",
    "head": "线性表",
    "tail": "逻辑结构",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序表是一种线性表，其核心特征是逻辑上相邻的元素在物理存储位置上也相邻，它用一组地址连续的存储单元依次存储线性表中的数据元素，",
    "head": "线性表",
    "tail": "线性表",
    "head_offset": "6",
    "tail_offset": "53"
  },
  {
    "sentence": "二叉树遍历的定义的核心性质是按照特定顺序访问二叉树中的每个节点且每个节点仅被访问一次，包括前序遍历先访问根节点再递归访问左子树",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "引用是给已存在变量起的一个别名，对引用的操作实际上就是对其引用的变量的操作，引用必须在定义时初始化且初始化后不能再引用其他变量",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "46",
    "tail_offset": "50"
  },
  {
    "sentence": "深度优先搜索是一种从起始节点开始，沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径的搜索算法",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将数组中间元素与目标值比较，若中间元素等于目标值则查找成功，若中间元素大于目标值则在数组前",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元，具有数据元素以及指向其孩子节点和父节点的指针（对于根节点无父节点指针），通过这些节点构成了树",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "堆排序是一种选择排序，它的核心特征是将数组构建成一个最大堆或最小堆，通过不断取出堆顶元素并调整堆结构来实现排序，具有时间复杂度",
    "head": "堆排序",
    "tail": "选择排序",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点，其特点包括处于树的末端位置没有分支延伸，在数据处理和遍历等操作中作为最终的访问对象，代表了",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度优先搜索是一种在搜索过程中优先沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到上一层继续探索其他路径的搜索策略",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法，其核心特征是通过构建有序序列，对于未排序数据，在已排序序列中从",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "顺序表具有逻辑上相邻的元素在物理存储位置上也相邻的特点，其内存空间是连续分配的，支持随机访问，可通过下标直接定位到元素，插入和",
    "head": "访问",
    "tail": "插入",
    "head_offset": "44",
    "tail_offset": "60"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据域和指针域，指针域指向下一个节点，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序表是一种线性表，其特点是逻辑上相邻的元素在物理存储位置上也相邻，它具有随机访问特性可通过下标直接定位元素且存储空间连续紧凑",
    "head": "线性表",
    "tail": "访问",
    "head_offset": "6",
    "tail_offset": "39"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其特点的核心性质是比较和插入操作，通过不断将一个数据插入到前面已排",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，其核心特征是将待排序的数据构建成一个最大堆或最小堆，然后依次取出堆顶元素并重新调整堆结构",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，这些权重可以表示诸如距离、成本、时间等各种与边相关的度量，图由顶点集合",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "广度优先搜索是一种从起始节点开始，按照层次依次访问节点，先访问距离起始节点近的节点，直到找到目标节点或遍历完所有节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，这些权重可以表示诸如距离、成本、时间等信息，图中顶点之间通过带权重的边",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可依次访问链表中的各个节点，其特点是",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "快速排序是对无序数组进行排序的高效算法，其核心特征是选择一个基准值，将数组分为两部分，小于基准值的元素在左边，大于基准值的元素",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，这些权重用于表示边的某种属性或代价等，边和其对应的权重共同构成加权图的",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和相关操作的定义而不涉及具体的存储结构和实现细节",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "二叉搜索树是一棵空树或者满足对于任意一个节点，其左子树上所有节点的值均小于该节点的值，其右子树上所有节点的值均大于该节点的值，",
    "head": "二叉搜索树",
    "tail": "左子树",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，它按照层次依次访问节点，先访问起始节点，接着访问其所有邻接节点，再依次访问这些邻接节点的邻接节点",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "算法效率的特点是指算法在执行过程中所表现出的诸如时间复杂度和空间复杂度等方面的特性，反映了算法执行所需资源随问题规模变化的情况",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "24",
    "tail_offset": "30"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，其核心特征是按照层次依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "选择排序的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点之间通过边相连，边可以具有方向也可以无方向，图可用于表示各种复杂的关系结构如社交网络、",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "图的核心性质是由顶点集合和边集合构成，顶点集合中的元素通过边集合中的边相互连接，边可以具有不同的属性如权重等，并且图可以分为有",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "14"
  },
  {
    "sentence": "回溯法是一种通过系统地尝试所有可能的解来解决问题的算法策略，它从问题的初始状态出发，按照深度优先搜索的方式，逐步构建解空间树，",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据域和指针域，指针域指向下一个节点，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据域和指针域，指针域指向下一个节点，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点，以此来体现图中",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "邻接矩阵是一种表示图的方式，其特点是以一个二维数组来存储图中顶点之间的关系，数组元素的值表示对应顶点之间是否存在边或弧以及边或",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "子节点的核心特征是在树状结构中，相对于某个特定节点而言，直接连接在该节点下方的节点，这些子节点与父节点通过特定的关系相连，并且",
    "head": "子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的目标值进行比较，直到找到目标值或遍历完整个数据序列的一种查找算法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和相关操作的抽象描述，而不依赖于具体的实现细节，",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "子节点是树结构或图结构中直接与某个特定节点相连且处于该节点下方一层的节点，具有与父节点存在直接连接关系且在层次结构中位置低于父",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心特征是通过比较元素并交换位置来逐步将无序序列转变为有序序列，在排序过程中不断地将较大（或较小）的",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表是一种链表结构，每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，从而支持双向遍历，且在插入和删除节点时可",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "选择排序的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成，顶点表示事物，边表示事物之间的关系，通过顶点和边的组合来直观地展现各种复杂",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法，其核心特征是比较和插入操作，每次从待排序数据中取出一个元素，与",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "树的查找是在给定的树结构中，通过特定的方法从根节点开始，按照一定规则遍历节点，以确定是否存在特定值的节点，如果存在则返回该节点",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "22"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它满足父节点的值与子节点的值之间存在特定的序关系（最大堆中父节点的值大于等于子节点的值，最小堆中父节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "15",
    "tail_offset": "21"
  },
  {
    "sentence": "二叉树遍历是按照某种规则依次访问二叉树中的每个节点，使得每个节点被访问且仅被访问一次，遍历方式分为前序遍历、中序遍历和后序遍历",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，这些权重可以表示诸如距离、成本、时间等信息，图中顶点之间通过带权重的边",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直至整个数组有序，每一趟会将未排序部分的最大（或最小）元素“冒泡”",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解路径并在发现不满足条件或无法继续推进时回溯到上一步重新选择，以找到问题最优解或所有解的算法策略",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "广度优先搜索是一种图或树的遍历算法，它从起始节点开始，按照层次依次访问节点，先访问距离起始节点近的节点，直到遍历完所有可达节点",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "归并排序是一种稳定的、采用分治思想将待排序序列分成子序列分别排序后再合并成有序序列的排序算法其时间复杂度为O(nlogn)空间",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "数据的逻辑结构的特点是指数据元素之间的逻辑关系，它独立于数据的存储方式，仅关注数据元素之间的关联方式，包括线性结构（如线性表）",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "12"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中所有节点可以依次被遍历且遍历可以循环进行",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "引用是C++中为已存在的变量起的一个别名，通过该别名可对同一变量进行访问和操作，其声明时必须初始化且初始化后不能再指向其他变量",
    "head": "访问",
    "tail": "初始化",
    "head_offset": "34",
    "tail_offset": "46"
  },
  {
    "sentence": "选择排序的核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "哈希表的核心性质是通过哈希函数将键映射到特定位置，使得在平均情况下能在常数时间内进行插入、查找和删除操作，并且不同的键能映射到",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "回溯法基础的特点是在问题求解过程中通过系统地尝试各种可能的解路径，当发现当前路径无法得到有效解时就回溯到上一步重新选择，以逐步",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "邻接表的核心特征包括对于图的每个顶点建立一个单链表，链表中节点包含与该顶点相邻的顶点信息，顶点表中存放顶点信息和指向对应单链表",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "深度优先搜索是一种从起始节点开始，沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径的搜索算法",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组都被排序，每一轮比较会将当前未排序部分的最大（或最小）",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "顺序查找是从表的一端开始，依次将关键字与表中元素进行比较，直到找到目标元素或遍历完整个表，其特点核心性质是按顺序逐个比较元素来",
    "head": "顺序查找",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问的节点的邻接节点会在后续被访问，并且同一层节点的访问顺序不固定，直到遍历完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点之间通过边相连，边可以具有方向或无方向，能够表示各种复杂的关系和结构，可用于描述网络、",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "树是一种非线性的数据结构，有且仅有一个根节点，其余节点分为若干互不相交的子树，每个子树也是一棵树，且除根节点外每个节点有且仅有",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "19",
    "tail_offset": "36"
  },
  {
    "sentence": "冒泡排序是一种比较和交换相邻元素的排序算法，其核心特征是通过多次重复比较和交换操作，将最大（或最小）的元素逐步“冒泡”到数组的",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储，通过一个统一的数组名和下标来唯一标识和访问每个元素",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在必要时交换位置，使得较大元素逐步“冒泡”到数组末尾，经过多次重复此操作将数组元素按升序或降序",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "路径是图中顶点与顶点之间经过边的序列，其核心性质包括由顶点和边组成且顶点之间通过边依次相连，路径长度是路径上边的数目，简单路径",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射为哈希值，利用哈希值来确定数据在表中的存储位置，具有快速查找、插入和删除操作的特点，能在平均情况下以",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "回溯法基础的特点是在包含问题的所有解的解空间树中，按照深度优先搜索策略，从根节点出发搜索解空间树，通过判断节点是否满足条件决定",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据域和指针域，指针域指向下一个节点，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它的特点包括对于图中的每个顶点，用一个单链表存储其所有邻接顶点，顶点表中每个节点包含顶点信息",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序的数据构建成一个堆，通过不断交换堆顶元素与末尾元素并调整堆结构，从而实现对数据",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "选择排序的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二叉树是一种树形结构，每个节点最多有两个子节点，其核心性质包括每个节点至多有两棵子树，并且二叉树的子树有左右之分，次序不能颠倒",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可顺序访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列的一种查找方法",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，通过多次重复此操作将最大（或最小）元素逐步“冒泡”到数组末尾（或开头），从而",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中的节点表示与该顶点相邻接的其他顶点，从而以一种链表结构的形式存储图",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将关键字与线性表中的元素进行比较，直到找到与关键字相等的元素或遍历完整个线性表为止的查找方法",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可间接访问其所指向的变量，能高效地进行数据传递和操作，具有灵活性和对内存",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "堆排序的核心特征是将数组构建成一个堆，堆顶元素为最大或最小元素，然后通过不断交换堆顶元素与末尾元素，并调整堆结构，使得剩余元素",
    "head": "堆排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "单链表是一种线性数据结构，每个节点包含数据和指向下一个节点的指针，其特点的核心性质为除了尾节点外每个节点都有且仅有一个后继节点",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，其核心性质是引用一旦初始化便不能再引用其他对象，它始终绑定到初始化时所引用的对象，对引用的操作",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "26",
    "tail_offset": "46"
  },
  {
    "sentence": "二叉树遍历是按照某种规则依次访问二叉树中的每个节点，使得每个节点被访问且仅被访问一次，常见的遍历方式有前序遍历（先访问根节点，",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "回路是数据结构中一种特定的路径形式，其核心特征是从一个顶点出发，沿着边的序列经过若干个顶点后又回到起始顶点，且回路中除起始顶点",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序表是一种线性表，其核心性质包括：逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过数组来实现，能随机访问表中的元素，元素",
    "head": "线性表",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "44"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，其核心特征包括能将不同的键通过哈希函数转换为不同的哈希",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "迭代法的核心特征是基于已有的初始值，按照固定的迭代公式不断重复计算，逐步逼近问题的解，每一次迭代的结果都作为下一次迭代的输入，",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点之间通过边相连，边可以具有方向或无方向，能表示各种复杂的关系结构，如社交网络中人与人的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "选择排序的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "哈希表的核心性质是对于每个键值对，通过哈希函数将键映射到一个特定的索引位置，使得在理想情况下能在接近常数时间内进行插入、查找和",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "递归基础是递归定义中的一部分，其核心特征是定义了递归终止的条件，即明确指出在什么情况下递归不再继续，而是直接给出一个确定的结果",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "堆排序的核心特征是利用堆这种数据结构进行排序，将待排序数据构建成最大堆或最小堆，每次取出堆顶元素并调整堆结构，从而实现有序排列",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的节点的核心特征是具有一个数据元素以及零个或多个指向子节点的指针，其中根节点没有父节点，其余节点有且仅有一个父节点，并且每个",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接表的核心特征是通过为图中的每个顶点建立一个单链表，链表中的节点存储与该顶点相邻接的顶点信息，从而以一种链表形式直观地表示图",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "选择排序的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "深度优先搜索是一种在搜索过程中优先沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径的搜索策略",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据域和指针域，指针域指向下一个节点，通过依次访问节点的指针域",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元，包含数据元素以及指向其子节点的链接，且根节点没有父节点，除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "选择排序是一种在未排序序列中找到最小（大）元素存放到排序序列起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素然后放到已",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法其核心性质是通过不断将一个数据插入到前面已排好序的子序列中的适当位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序都将最大（或最小）元素“冒泡”到数组末尾，经过若干",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "树是一种非线性的数据结构，它的核心性质包括有且仅有一个根节点，每个节点有零个或多个子节点，并且任意两个节点之间有且仅有一条路径",
    "head": "根节点",
    "tail": "子节点",
    "head_offset": "27",
    "tail_offset": "41"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其最后一个节点的指针域指向头节点，从而形成一个环形结构，使得从链表中的任意节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序的数据构建成一个最大堆或最小堆，然后依次取出堆顶元素并调整堆结构，直到整个数据",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可顺序访问各个节点，且插入和删除操作",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性表是一种数据元素的有限序列，其中每个元素有且仅有一个直接前驱（除第一个元素外），有且仅有一个直接后继（除最后一个元素外），",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "非线性结构的核心性质是其元素之间的关系不再是简单的线性顺序关系，存在一对多或多对多的关系，使得结构中至少有一个数据元素有两个或",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "55"
  },
  {
    "sentence": "树的查找的核心性质是若树中存在关键字等于给定值的结点则查找成功且可获取该结点信息，若树中不存在关键字等于给定值的结点则查找失败",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "27"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素的相对次序从而实现排序的一种排序算法类型其核心特征是通过对元素两两比较来逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "二叉树遍历的核心特征是按照某种特定顺序访问二叉树中的每一个节点，使得每个节点被访问且仅被访问一次，该顺序决定了遍历的方式，如前",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作所指向的变量，具有灵活高效地访问和修改内存数据、实现动态",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组都被排序，每一趟排序都会将未排序数据中最大（或最小）的",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "父节点是在树形结构中，其下方直接连接一个或多个子节点且位于某个节点之上一层的节点，具有可通过它访问其所有子节点及相关信息等特点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性通过特定的遍历或搜索方式来确定目标元素在树中的位置其效率受树的类型结构以及元素分布等多种因素影响",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "20"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解路径，在遇到不满足条件或无法继续推进时回溯到上一步，继续尝试其他路径，以找到问题的解的算法策略",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树的节点具有一个数据元素以及零个或多个指向其他节点的分支，根节点没有前驱节点，非根节点有且仅有一个前驱节点，每个节点可以有零个",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问离起始节点距离为1的所有节点，再访问距离为2的节点，以此类推，在访问完当前层所有节点后",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "选择排序是在未排序序列中找到最小（大）元素存放到排序序列的起始位置然后再从剩余未排序元素中继续寻找最小（大）元素然后放到已排序",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中每个元素都有唯一前驱（除第一个元素）和唯一后继（除最后一个元素），数据元素",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二叉树遍历是按照一定规则对二叉树中节点进行访问使得每个节点被访问且仅被访问一次，不同遍历方式（前序遍历先访问根节点再递归访问左",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "父节点是在树形结构中直接与一个节点相连且处于该节点之上层次的节点，具有比子节点更高的层级关系，子节点通过特定的连接关系与父节点",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点的搜索算法，先访问起始节点，再依次访问其邻接节点，然后按层次依次访问这些邻接节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和修改所指向的变量的值，它能够灵活地操作内存，方便实现数据的",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "子节点是树结构中直接连接到父节点的节点，它具有在树的层次结构中处于较低层级且与父节点通过特定连接关系相连从而构成树形结构的核心",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是它描述了数据在计算机内存或存储设备中的实际存储方式包括数据元素的存储位置以及它们之间的存储关系",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "43"
  },
  {
    "sentence": "邻接矩阵是用一个二维数组来表示图中顶点之间邻接关系的一种数据结构，其中数组元素的值表示对应顶点之间是否有边相连及边的相关信息（",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "冒泡排序是一种比较排序算法，其核心性质是通过多次比较相邻元素并交换位置，将最大（或最小）的元素逐步“冒泡”到数组的末尾（或开头",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含一个数据元素和一个指向后继节点的指针，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "引用是一种给变量起别名的机制，其特点包括必须在定义时初始化且初始化后不能再引用其他对象，它和被引用的对象共用同一块内存空间，对",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "26",
    "tail_offset": "30"
  },
  {
    "sentence": "选择排序的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回溯法基础的定义的核心特征是在解决问题的过程中通过尝试不同的选择路径，当发现当前路径无法达到目标或不满足条件时，就回溯到上一步",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其特点的核心性质为每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可依次访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "穷举法是一种通过对所有可能情况进行逐一列举和检验，从而找出满足特定条件的解的算法策略其特点是在解决问题时会遍历问题的整个解空间",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "53"
  },
  {
    "sentence": "选择排序的核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "选择排序的核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其核心性质是比较和插入，通过不断将元素与已排序部分的元素比较并插入",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "路径是图中顶点与顶点之间经过边的序列，其核心性质包括路径有起点和终点，由一系列边依次连接顶点组成，边的数量决定路径长度，路径上",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "图的核心性质是由顶点集合及顶点间的边的集合所构成，顶点之间通过边相连，边具有方向性或无方向性，并且图可以用于表示各种复杂的关系",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "19"
  },
  {
    "sentence": "选择排序是一种在未排序序列中找到最小（大）元素存放到排序序列起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素然后放到已",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "冒泡排序是一种比较排序算法，其核心性质是通过多次比较相邻元素并在需要时交换它们的位置，将最大（或最小）的元素逐步“冒泡”到数组",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "堆是一种优先队列数据结构，它是一棵完全二叉树，并且每个节点的值都大于或等于其子节点的值（大顶堆）或者小于或等于其子节点的值（小",
    "head": "队列",
    "tail": "完全二叉树",
    "head_offset": "6",
    "tail_offset": "17"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可顺序访问链表中的各个节点，其特点是",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将关键字与线性表中的元素进行比较，直到找到与关键字相等的元素或遍历完整个线性表的一种查找方法",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序，具有时间复杂度为",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表，其核心特征是按顺序",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，不断重复此过程，将最大（或最小）元素逐步“冒泡”到数组末尾（",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "58"
  },
  {
    "sentence": "双向链表每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，这使得它可以双向遍历且在插入和删除节点时相对单链表在某些",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据域和指针域，指针域指向下一个节点，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序方法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的节点是树结构中的基本数据元素，包含数据以及指向其子节点的引用，根节点没有父节点，非根节点有且仅有一个父节点，每个节点可以有",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，其核心特征包括有明确规定的取值范围、特定的存储方式以及针对该类型数据",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有唯一的表头和表尾，元素之间存在一对一的线性关系，相邻元素之间有顺序，可进行",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "哈希表的核心特征是通过哈希函数将键映射为哈希值，依据哈希值来确定元素在表中的存储位置，使得在平均情况下能在常数时间内完成插入、",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "选择排序是一种简单直观的排序算法，它的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "选择排序的核心特征是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "在树这种数据结构中，从根节点开始，按照特定规则沿着节点间的连接关系进行搜索，以确定是否存在特定数据元素，这就是树的查找的定义的",
    "head": "树",
    "tail": "根节点",
    "head_offset": "1",
    "tail_offset": "11"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点间的关系通过边来表示，图中的顶点可以是各种类型的对象，边可以具有不同的属性",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "选择排序的核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "堆排序的核心特征是将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序，具有时间复杂度为O(nlogn)、空间",
    "head": "堆排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个单链表，链表中每个节点存储与该顶点相邻接的顶点信息，从而以链表",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个单链表，链表中存储与该顶点相邻接的其他顶点，从而以链表形式简洁",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成，顶点表示事物，边表示事物之间的关系，它能直观地展示元素之间的连接和关联情况",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "图由顶点集合及顶点间的关系集合组成，顶点之间的关系通过边来表示，边可以具有权重等属性，图可以用来描述各种复杂的关系结构，包括有",
    "head": "集合",
    "tail": "集合",
    "head_offset": "4",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序表的特点的核心特征是逻辑上相邻的元素在物理存储位置上也相邻，其存储结构是连续的，可通过数组下标直接访问元素，支持随机存取，",
    "head": "存储结构",
    "tail": "数组",
    "head_offset": "33",
    "tail_offset": "45"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针指向头节点，使得整个链表形成一个环，从链表中的任意节点出发都可以遍历到链表中的其他节点",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "交换排序的核心特征是通过比较元素并交换位置，将无序数组逐步转换为有序数组，其基本思想是在未排序序列中找到最小（大）元素，存放到",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，不同数据类型具有不同的值集合和操作集合，其特点包括有特定的取值范围、",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个将元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个数据序列",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "冒泡排序的核心特征是通过比较相邻元素大小，若顺序错误就把它们交换过来，每一趟排序都会将未排序数据中最大（或最小）的元素“冒泡”",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "归并排序是一种分治算法将数组分成两个子数组分别对两个子数组进行排序然后将排序好的子数组合并成一个有序的数组其核心性质包括稳定性",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与给定的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的一种查找方法",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中，从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步，",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "冒泡排序的核心特征是比较相邻元素大小，若顺序错误就把它们交换过来，不断重复此过程，将最大（或最小）元素逐步“冒泡”到数组末尾（",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "58"
  },
  {
    "sentence": "二叉树遍历的核心性质是通过特定规则访问二叉树中的每个节点且仅访问一次，不同遍历方式（先序遍历、中序遍历、后序遍历）有着各自独特",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "顺序查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列的一种查找方法",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它将数组构建成最大堆或最小堆，通过不断取出堆顶元素并调整堆结构来实现排序，具有时间复杂度",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素之间的相对顺序从而实现排序的一种排序算法其核心特征是通过对元素两两比较来逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外还包含两个指针，一个指向前驱节点，另一个指向后继节点从而形成双向链接关系",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由表头指针唯一确定，每个节点包含数据域和指针域，指针域指向下一个节点，最后一个节点的指针域为空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "哈希表是一种数据结构，通过哈希函数将键映射到特定位置来存储和检索数据，具有核心性质为能在平均常数时间内进行插入、删除和查找操作",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将数组中间元素与目标值比较，若相等则找到目标，若目标值小于中间元素则在数组前半部分继续进行",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组有序，较小元素像气泡一样逐渐“浮”到数组前端的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "线性表是一种具有相同数据类型的n个数据元素的有限序列，其特点是数据元素之间存在一对一的线性关系，有唯一的表头元素和表尾元素，除",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点等，直到遍历完所有节点或",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，通过该别名可以访问和操作被引用的对象，引用在定义时必须初始化，且初始化后其引用关系不能再改变，",
    "head": "访问",
    "tail": "初始化",
    "head_offset": "23",
    "tail_offset": "43"
  },
  {
    "sentence": "回溯法基础的特点的核心性质是通过深度优先搜索的方式，在解空间树中按照一定规则搜索，当发现当前路径无法得到有效解时回溯到上一步，",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "快速排序是对一组数据进行排序的算法，其核心特征是选择一个基准值，将数据分为两部分，小于基准值的放在左边，大于基准值的放在右边，",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "非线性结构的特点的核心性质是其各数据元素之间的逻辑关系不再是线性的，存在一对多或多对多等复杂关系，不像线性结构那样有唯一的前驱",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "选择排序的核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树的节点具有一个数据元素及若干指向其子树节点的分支，根节点无父节点，其余节点有且仅有一个父节点，叶子节点无后续分支，非叶子节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点近的节点，通过队列来辅助实现逐层遍历图或树等数据结构中节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "树的节点是树结构中的基本单元，包含数据元素以及指向其子节点的指针或引用，根节点没有父节点，除根节点外每个节点有且仅有一个父节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "二叉树的核心特征是每个节点最多有两个子节点，并且可以为空，它是一种树形数据结构，其递归定义为要么为空树，要么由一个根节点和两棵",
    "head": "二叉树",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "冒泡排序比较相邻元素大小，将较大元素交换到右侧，每一轮比较都会将未排序部分的最大元素“冒泡”到末尾，重复此过程直到整个数组有序",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "选择排序的核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "双向链表每个节点包含两个指针，一个指向前驱节点，一个指向后继节点，这使得在链表中可以双向遍历，既能从前往后也能从后往前，插入和",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点等，直到遍历完所有可达节点的",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "顺序表是一种线性表，其特点是逻辑上相邻的元素在物理存储位置上也相邻，通过数组来存储元素，可随机访问元素且插入和删除操作效率较低",
    "head": "线性表",
    "tail": "数组",
    "head_offset": "6",
    "tail_offset": "36"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间缩小一半来快速定位目标元素的查找算法其特点是查找效率高平均时间复杂度为O(log n)",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和操作的规格说明，而不考虑其具体的存储表示和实现",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，其中顶点集合不能为空，顶点间的关系集合可以为空，顶点间的关系可以是有向的或无向",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，描述了数据元素之间的关联方式，包括线性结构如线性表、栈、队列",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元，包含数据元素以及指向其子节点的指针（对于有子节点的情况），并且根节点没有父节点，其余节点有且",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "归并排序是一种分治算法，将数组分成两个子数组分别排序，再将排序好的子数组合并成一个有序数组，具有时间复杂度为O(n log n",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有直接受父节点关联、处于树状层次结构下层、在数据组织和关系表达中有特定",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二分查找针对有序数组，通过不断将数组中间元素与目标值比较，每次比较后可将查找范围缩小一半，从而高效确定目标值是否存在及所在位置",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且除根节点外的每个节点有且仅有一个父节点，并且树中任意两个节点之间存在唯一的一条路径",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "23"
  },
  {
    "sentence": "堆是一种优先队列的数据结构，它是一棵完全二叉树，其中每个节点的值都大于或等于其子节点的值（大顶堆）或小于或等于其子节点的值（小",
    "head": "队列",
    "tail": "完全二叉树",
    "head_offset": "6",
    "tail_offset": "18"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将数组中间元素与目标值比较，若相等则找到目标，若中间元素大于目标值则在数组前半部分继续查找",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问起始节点，接着访问其所有邻接节点，再依次访问这些邻接节点的邻接节点等，直到遍历完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "快速排序是对无序数组进行分治的排序算法，选择一个基准值将数组分为两部分，小于基准值的元素放在左边，大于基准值的元素放在右边，通过",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "冒泡排序是比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤，将最大元素逐步“冒泡”到数组末尾，每次比较和交换都能确定一个",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "回路是指在电路中，从电源的一端出发，经过若干个元件后又回到电源另一端的闭合路径，其特点包括能形成电流通路、各元件相互关联影响电流",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素，集合具有确定性、互异性和无序性，即给定一个",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点，以此类推，直到遍历",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点较近的节点，在访问当前层节点时才会拓展到下一层节点，通过队列来辅助实现，保证",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "递归基础是递归函数中最简单的情况，其特点是函数直接返回一个已知值而不再调用自身，它是递归过程的终止条件，确保递归不会无限进行下去",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，仅考虑数据元素之间的关联方式，包括集合、线性结构、树形结构和图",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问离起始节点距离为1的所有节点，再访问距离为2的节点，以此类推，直到遍历完所有可达节点，其",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，将最大（或最小）元素逐步“冒泡”到数组末尾，重复此过程对整个数组进行排序的算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "叶子节点是树结构中没有子节点的节点，其特点包括处于树的末端位置，没有分支延伸出去，是数据存储或信息表示的最终单元，在一些应用场景",
    "head": "叶子节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "单链表的核心特征是每个节点包含数据域和指针域，指针域指向下一个节点，通过依次遍历这些节点形成一个线性序列，且除了尾节点外每个节点",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "回溯法基础的核心性质是在问题求解过程中通过深度优先搜索尝试所有可能解并在搜索过程中利用约束条件和目标函数对解进行筛选和剪枝以找到",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在一对一的线性关系，即除了第一个和最后一个数据元素外，每个数据元素都有且仅有一个前驱和一个后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据和指向下一个节点的指针外，还包含一个指向前一个节点的指针，从而可以在两个方向上",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是一种具有相同数据类型的n个数据元素的有限序列，其特点是数据元素之间存在一对一的线性关系，有唯一的开始元素和终端元素，且除",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的查找是基于树这种数据结构，通过特定规则在树中定位特定元素以确定其是否存在及获取相关信息的操作过程，具有从根节点开始逐层比较等",
    "head": "查找",
    "tail": "树",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "树的节点是包含数据元素以及指向其子节点的分支的基本数据结构单元且具有唯一的父节点（根节点除外）同时每个节点可以有零个或多个子节点",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完同一层节点后再访问下一层节点，通过队列来辅助实现，以确保",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "子节点的核心特征是其与父节点存在特定的关联关系，处于父节点之下，是树形结构等数据结构中父节点进一步细分或延伸出来的节点，具有继承",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "指针是一种变量，其值为内存地址，通过指针可以直接访问和操作该地址所指向的内存单元，具有灵活性和高效性，能方便地处理动态数据结构和",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问离起始节点距离为1的所有节点，再访问距离为2的节点，以此类推，直到遍历完所有节点，它通过",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索是一种图或树的遍历算法，它从起始节点开始，按照层次依次访问节点，先访问距离起始节点近的节点，通过队列来辅助实现，直到",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序表具有逻辑上相邻的元素在物理存储位置上也相邻的特点，其存储单元是连续的，可通过数组下标直接计算出元素的存储地址，支持随机访问",
    "head": "数组",
    "tail": "访问",
    "head_offset": "41",
    "tail_offset": "62"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历，没有明显的头和尾",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "哈希表的核心特征是通过哈希函数将键映射为哈希值，利用哈希值来确定元素在表中的存储位置，使得插入、查找和删除操作的平均时间复杂度为",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成，顶点表示事物，边表示事物之间的关系，图中的顶点之间通过边相互连接，体现了各个",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "回溯法基础是一种通过尝试所有可能的解空间路径来求解问题的方法，其核心特征是在搜索过程中，一旦发现当前部分解无法导致完整的有效解，",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点创建一个链表，链表中的每个节点表示与该顶点相邻接的顶点，其特点的核心性质",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "子节点的核心性质是其与父节点存在特定关联关系且在所属数据结构层次中有明确位置和作用，是构成整体结构的重要组成部分，在数据的组织和",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式或规则不断重复计算，逐步逼近问题的精确解的方法，其核心特征是利用前一步的",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "集合具有确定性、互异性和无序性，确定性指集合中的元素必须是确定的，互异性指集合中的元素互不相同，无序性指集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完当前层次的所有节点后，再进入下一层进行访问，",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "映射是一种特殊的二元关系，它在两个集合之间建立对应关系，使得对于一个集合中的每一个元素，在另一个集合中都有唯一确定的元素与之对应",
    "head": "映射",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，通过多次重复此操作将最大（或最小）元素逐步“冒泡”到数组末尾（或开头）从而实现",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它为图中的每个顶点建立一个单链表，链表中的每个节点表示与该顶点相邻接的顶点，通过这种方式来直观",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中进行遍历或搜索的算法，其核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "树的节点特点包括有一个根节点，除根节点外其余节点被分为若干互不相交的有限集合且这些集合中的节点又各自构成一棵树，每个节点有零个或",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性表是一种具有相同数据类型的有限序列，其中数据元素之间存在一对一的线性关系，有唯一的表头和表尾，且除表头外每个元素有唯一前驱，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的查找特点是基于树的结构特性，通过特定的遍历方式从根节点开始沿着分支路径搜索目标元素，其查找效率受树的高度、节点分布等因素影响",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "21"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即各数据元素之间的逻辑关系不再是线性的一对一关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "迭代法的核心特征是基于已有的初始值，按照固定的迭代公式不断重复计算，逐步逼近问题的解，每次迭代的结果都作为下一次迭代的输入，直到",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "回溯法基础的特点的核心性质是在问题的解空间树中，按照深度优先策略，从根节点出发搜索解空间，通过判断当前节点是否满足约束条件和目标",
    "head": "回溯法",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "递归基础是递归定义中确定的最简单情况，它直接给出问题在最小规模或最基本形式下的解，不依赖于递归调用，是递归过程能够开始并逐步展开",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环形结构，从而可以依次遍历链表中的所有节点且能循环访问",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，关系集合中的元素为边，边是顶点的无序对或有序对用于表示",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置来存储和检索数据，具有平均时间复杂度为O(1)的高效查找、插入和删除操作，能快速定位数据，但",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心特征是通过比较元素并交换位置，逐步将无序序列转换为有序序列，在排序过程中不断地对相邻或不相邻的元素",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "顺序查找对线性表中元素的存储方式没有要求，从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到相等的元素或遍历完",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "树的查找的特点的核心性质是若树中存在关键字值等于给定值的结点，则一定可以通过从根结点开始的一条路径找到该结点，若不存在则查找失败",
    "head": "查找",
    "tail": "路径",
    "head_offset": "2",
    "tail_offset": "47"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其特点包括有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个直接",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "回溯法是一种通过系统地尝试所有可能解，以深度优先搜索方式遍历解空间树，在搜索过程中通过剪枝函数避免无效搜索，从而找出问题所有解或",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "堆是一种优先队列的数据结构，它通常分为最大堆和最小堆，最大堆中父节点的值大于或等于其子节点的值，最小堆中父节点的值小于或等于其子",
    "head": "队列",
    "tail": "堆",
    "head_offset": "6",
    "tail_offset": "25"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点创建一个链表，链表中的每个节点表示与该顶点相邻接的顶点，从而直观地反映图",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心特征为：它是一个完全二叉树，并且每个节点的值都大于或等于其子节点的值（最大堆），或者每个节点的值都",
    "head": "完全二叉树",
    "tail": "堆",
    "head_offset": "23",
    "tail_offset": "52"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历，没有明确的头和尾之分，",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组都被排序，较大元素会像气泡一样逐渐“浮”到数组末尾，每次",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "选择排序是一种排序算法，其核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "归并排序是将一个序列分成两个子序列分别进行排序，然后将排序好的子序列合并成一个有序序列的排序算法，其核心特征在于通过递归地对序列",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组有序，每次比较都将最大（或最小）元素“冒泡”到数组末尾（",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中，从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，若未找到目标则回溯",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完当前层所有节点后再进入下一层，通过队列来辅助实现，保证按",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中进行遍历的算法，其核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "冒泡排序比较相邻元素大小，若顺序错误就把它们交换过来，每一趟将一个最大或最小元素“冒泡”到数组末尾，经过多趟比较和交换使数组有序",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其核心性质包括每个节点包含数据元素以及指向下一个节点的指针，并且除了尾节点外每个节点都有唯一的后继",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "快速排序是对无序数组进行分治，通过一趟排序将数组分为两部分，小于基准值的元素在前大于基准值的元素在后，然后对两部分分别递归排序以",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中，通过尝试不同的选择路径，当发现当前路径无法达到目标或不满足条件时，就返回到上一步重新选择",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，通过多次重复此过程将最大元素逐步“冒泡”到数组末尾从而实现对数组进行排序的算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "邻接矩阵是用于表示图中顶点之间相邻关系的矩阵，其中行和列分别对应图的顶点，矩阵元素的值表示对应顶点之间是否存在边以及边的相关属性",
    "head": "邻接矩阵",
    "tail": "图的顶点",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和修改其所指向的变量的值，能灵活地实现数据的动态存储和高效操作",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止其核心性质为适用于",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "选择排序是一种排序算法，每次从未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间来寻找问题解的算法策略，它从初始状态出发，按照深度优先搜索的方式，逐步构建解向量，在构建过程",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "树的查找是在树结构中按照特定规则寻找特定元素，若存在则返回其位置等相关信息，若不存在则返回特定标识表明查找失败，具有根据树的节点",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "51"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，其插入操作对应的一端称为栈顶，删除操作对应的一端称为栈底，当栈中没有元素时称为",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作所指向的内存位置的数据，具有灵活高效地实现数据间逻辑关系、",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，一个指向后继节点，通过这两个指针可以双向遍历链表",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，其特点包括具有特定的数据表示形式、定义了相应的操作规则且不同数据类型有",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "迭代法的核心特征是通过不断重复执行相同的计算步骤，利用上一次迭代的结果来逐步逼近问题的解，每一次迭代都基于前一次的结果进行更新，",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其核心特征包括每个节点包含数据域和指针域，指针域指向下一个节点，通过头指针唯一标识链表，节点在内存",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序，每一趟冒泡会将未排序部分的最大",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完当前层次的所有节点后，再进入下一层进行访问，",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可依次访问整个链表，具有插入和删除操作",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在逆序时交换，重复此过程直到整个数组有序的排序算法，其特点在于每次比较和交换会将未排序部分的最大",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且处于较低层次的节点，具有数量上的不确定性，其与父节点通过特定的连接关系构成树形层次结构，并且在",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，仅考虑数据元素之间的关联方式，如线性结构、树形结构、图形结构等",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "归并排序的核心特征是采用分治策略将数组分成两个子数组分别排序后再合并成一个有序数组，通过递归不断分解问题直到子数组规模为1，合并",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "二叉树遍历是按照某种规则依次访问二叉树中的每个节点，使得每个节点被访问且仅被访问一次，其核心特征包括先访问根节点再递归访问左子树",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它是一个近似完全二叉树的数据集合，满足堆中每个节点的值都大于或等于其子节点的值（大顶堆）或小于或等于其子",
    "head": "完全二叉树",
    "tail": "集合",
    "head_offset": "18",
    "tail_offset": "26"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种顺序排列，每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，这些对象称为该集合的元素，集合具有确定性、互异性和无序性，确定性是指",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它为图中的每个顶点建立一个单链表，链表中的每个节点表示与该顶点相邻接的顶点，通过这种方式来体现",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据域外，还有两个指针分别指向前一个节点和后一个节点，通过这些指针可实现双向遍历",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其特点的核心特征包括每个节点包含数据域和指针域，指针域指向下一个节点，通过头指针唯一标识链表，逻辑",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问离起始节点距离为1的所有节点，再访问距离为2的所有节点，以此类推，直到遍历完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过它可以间接访问和操作所指向的内存位置的数据，具有灵活高效地访问和修改数据、实现",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，其核心特征是沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步，",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "集合的核心特征是具有确定性、互异性和无序性，其中确定性是指集合中的元素必须是确定的，即任何一个对象要么是该集合的元素，要么不是，",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点，从而直观地反映图",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始顶点开始，逐层地访问顶点，先访问距离起始顶点较近的顶点，直到遍历完所有可达顶点，其核心性质是",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，顶点间的关系集合中的元素是由顶点对构成的边，这些边反映",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "线性查找是从线性表的一端开始，依次将每个元素与给定值进行比较，直到找到匹配元素或遍历完整个线性表的一种查找方法其特点是比较次数与",
    "head": "查找",
    "tail": "线性表",
    "head_offset": "2",
    "tail_offset": "6"
  },
  {
    "sentence": "快速排序是对无序数组通过选择基准值将数组分为两部分，小于基准值的元素放在左边大于的放右边，再对两部分分别递归进行此操作以实现排序",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "非线性结构的核心特征是其数据元素之间的关系并非简单的一对一或顺序排列关系，而是存在一对多、多对一或多对多等复杂关系，这些关系使得",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表，其核心特征是逐个元素",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了有指向后继节点的指针外还有指向其前驱节点的指针，这使得在双向链表中既可以方便地向前遍历也可以方便",
    "head": "双向链表",
    "tail": "后继节点",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "集合的核心性质包括确定性、互异性、无序性，确定性是指集合中的元素必须是确定的，互异性是指集合中的元素互不相同，无序性是指集合中的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "广度优先搜索按照层次依次扩展节点，先访问距离起始节点较近的节点，在访问完同一层的所有节点后再进入下一层，通过队列来辅助实现对节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据的逻辑结构特点是指数据元素之间抽象化的相互关系，它与数据的存储无关，仅考虑数据元素间的逻辑关系，包括集合、线性结构、树形结构",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "11"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问起始节点的所有邻接节点，再依次访问这些邻接节点的邻接节点，直到遍历完所有节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "集合具有确定性、互异性和无序性，确定性指集合中的元素必须是确定的，互异性指集合中的元素互不相同，无序性指集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个直接前驱，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "树的查找是在树结构中基于特定规则从根节点开始通过比较节点元素值沿着树的分支路径搜索以确定是否存在目标元素的操作其核心性质是依据树",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "17"
  },
  {
    "sentence": "快速排序是对无序数组在选择一个基准值后，将数组分为两部分，小于基准值的放在左边大于基准值的放在右边，然后对左右两部分分别递归进行",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的逻辑结构的核心性质包括数据元素之间的逻辑关系，以及这种关系如何影响数据的组织和操作，并且独立于数据的存储方式和具体实现细节",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个直接前驱，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将数组中间元素与目标值比较，根据比较结果将查找范围缩小到数组的前半部分或后半部分，持续此过程",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法基础的定义的核心特征是在问题的解空间中，通过深度优先搜索的方式，按照一定规则依次尝试每个可能的解，当发现当前部分解无法继续",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，其核心性质是将数组构建成一个最大堆或最小堆，根节点的值大于或小于其子节点的值，然后通过",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "归并排序的核心特征是将一个数组分成两个子数组分别递归排序，然后将排序好的子数组合并成一个有序的数组，其时间复杂度为O(n log",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，具有快速查找、插入和删除操作的特点，能在平均情况下以接近",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的内存地址，通过它可以间接访问和操作所指向的内存位置的数据，具有灵活高效地访问和修改",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历且遍历完尾节点后能回到头",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元，包含数据元素以及指向其子节点的若干分支，根节点没有前驱，叶节点没有后继，非根非叶节点有一个前驱",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "哈希表的核心性质是通过哈希函数将键映射到特定位置，使得插入、查找和删除操作能在平均常数时间内完成，且不同键经过哈希函数映射后可能",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "邻接矩阵是一种用于表示图的数据结构，其特点是用一个二维数组来存储图中顶点之间的关系，数组中元素的值表示对应顶点之间是否存在边或弧",
    "head": "邻接矩阵",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "归并排序是将一个序列分成两个子序列分别进行排序，然后把排序好的子序列合并成一个有序序列的排序算法其核心特征是通过递归地将序列不断",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "非线性结构中各数据元素之间的逻辑关系不再是线性的，存在一对多或多对多的关系，不像线性结构那样有唯一的前驱和后继，而是一个数据元素",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树等数据结构中节点的搜索算法，先访问起始节点，再依次访问其邻接节点，然后按层次依次访问这些",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和修改所指向的变量的值，指针的核心特征包括指向特定内存地址、可",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问离起始节点距离为1的所有节点，再访问距离为2的节点等，直至遍历完所有节点或找到目标",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "选择排序是一种每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问的节点的邻接节点会在后续被访问，且同一层次的节点被访问顺序无关紧要，直到遍历",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置来存储数据，具有快速查找的特点，平均情况下查找、插入和删除操作的时间复杂度为O(1)，但可能",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完同一层所有节点后再进入下一层访问的搜索算法，其特点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序好，每次比较都会将最大（或最小）元素“",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "回溯法基础的特点的核心特征是在解决问题的过程中通过尝试不同的选择路径，当发现当前路径无法得到有效解时就回溯到上一步重新选择，不断",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问起始节点，再依次访问其相邻节点，在访问完当前层所有节点后再进入下一层进行访问的图或",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "集合的核心性质包括确定性、互异性和无序性，确定性是指集合中的元素必须是确定的，互异性是指集合中的元素互不相同，无序性是指集合中的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组有序，每次遍历将最大（或最小）元素“冒泡”到数组末尾（或",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "树的定义的核心特征是有且仅有一个特定的称为根的节点，并且其余节点被分成若干个互不相交的有限集合，每个集合本身又是一棵树且称为根的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "45",
    "tail_offset": "50"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点较近的节点，再逐渐扩展到距离更远的节点，在访问完同一层的所有节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半并根据目标值与中间元素的比较结果来缩小查找区间从而确定目标值是否存在及位置的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "集合的核心特征是具有确定性、互异性和无序性，其中确定性是指集合中的元素必须是确定的，即任何一个对象要么是该集合的元素，要么不是，",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "堆是一种特殊的数据结构，其核心特征为：它是一个完全二叉树，并且每个节点的值都大于或等于其子节点的值（最大堆），或者每个节点的值都",
    "head": "完全二叉树",
    "tail": "堆",
    "head_offset": "23",
    "tail_offset": "52"
  },
  {
    "sentence": "集合的核心性质包括确定性、互异性、无序性，确定性是指集合中的元素必须是确定的，互异性是指集合中的元素互不相同，无序性是指集合中的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完当前层次的所有节点后，再进入下一层继续访问，",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次将每个数据元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止的查找方法",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "23"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构的排序算法，它将待排序数据构建成一个堆，通过不断取出堆顶元素并调整堆结构来实现排序，具有时间复杂度",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "集合的核心性质包括确定性、互异性、无序性，确定性是指集合中的元素必须是确定的，互异性是指集合中的元素互不相同，无序性是指集合中的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中进行遍历的算法，其核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它是一个完全二叉树，并且每个节点的值都大于或等于其子节点的值（最大堆）或小于或等于其子节点的值（最小堆）",
    "head": "完全二叉树",
    "tail": "堆",
    "head_offset": "16",
    "tail_offset": "45"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其中数据元素之间存在一对一的线性关系，且在数据元素的非空有限集中有唯一的开始元素和",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其中每个元素都有且仅有一个直接前驱（除第一个元素外）和一个直接后继（除最后一个元素",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "冒泡排序是一种比较排序算法，通过多次比较和交换相邻元素，将最大（或最小）元素逐步“冒泡”到数组末尾，每一趟比较都会将未排序部分的",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "树的查找是基于树这种数据结构，通过特定的算法从根节点开始，按照一定规则比较节点值来确定目标元素是否存在于树中以及其所在位置的操作",
    "head": "查找",
    "tail": "树",
    "head_offset": "2",
    "tail_offset": "7"
  },
  {
    "sentence": "递归基础是递归函数中最简单的情况，其特点的核心特征是直接返回一个确定的结果而不调用自身，它是递归算法终止的条件，为递归的后续步骤",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置，通过逐步将元素从无序部分移动到有序部分来完成排序，每次将一个待排序的",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "回溯法基础是一种通过尝试所有可能的解空间路径，从根节点出发，按照深度优先策略搜索解空间树，在搜索过程中通过剪枝函数避免无效搜索，",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "抽象数据类型的核心性质包括数据对象集、数据对象上的关系集以及定义在这些数据对象和关系上的基本操作集，其强调数据的逻辑结构而不涉及",
    "head": "抽象数据类型",
    "tail": "集",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果将查找范围缩小一半，从而高效地找到目标值位置的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "图是一种由顶点集合及顶点间的关系集合组成的数据结构，顶点之间的关系通过边来表示，其特点包括顶点个数可以为零或多个，边可以具有不同",
    "head": "集合",
    "tail": "集合",
    "head_offset": "7",
    "tail_offset": "16"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中，从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点，先访问起始节点，再依次访问其相邻未访问节点，按此逐层推进直至遍历完所有可达节点的",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，在这种结构中数据元素按顺序排列，每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始元素，有且仅有一个终端元素，除第一个元素外每个元素有且仅有一个",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间减半来查找特定目标值，每次比较中间元素与目标值大小以确定继续在左半区间还是右半区间查找，",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的两个元素在物理位置上也相邻，从而通过物理位置上的邻接",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且除根节点外，其余节点被分成若干互不相交的有限集合，每个集合又是一棵树，这些树称为该根",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "23"
  },
  {
    "sentence": "集合的核心性质包括确定性、互异性和无序性，确定性是指集合中的元素必须是确定的，互异性是指集合中的元素互不相同，无序性是指集合中的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，通过多次重复此操作将最大（或最小）元素逐步“冒泡”到数组末尾（或开头）从而实现",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "集合的核心性质包括确定性、互异性、无序性，确定性是指集合中的元素必须是确定的，互异性是指集合中的元素互不相同，无序性是指集合中的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "引用是给已存在的变量起一个别名，其核心性质是引用必须初始化且一旦初始化便不能再引用其他变量，它和被引用的变量共享内存空间，对引用",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "26",
    "tail_offset": "32"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，将最大（或最小）元素逐步“冒泡”到数组末尾（或开头）从而实现对数组元素进行排序",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其中每个数据元素最多只有一个直接前驱和一个直接后继，且元素之间存在一对一的线性关系",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "选择排序是一种排序算法，其核心性质是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "顺序查找是从线性表的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个线性表为止的查找方法其特点是",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点，从而直观地反映图",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "双向链表的每个节点除了有指向后继节点的指针外还有指向其前驱节点的指针，这使得在双向链表中既可以方便地向前遍历也可以方便地向后遍历",
    "head": "双向链表",
    "tail": "后继节点",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间缩小一半来查找特定值的高效查找算法其特点是每次比较都能排除一半的元素从而快速定位目标元素",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "交换排序是通过比较元素大小并交换位置，将无序序列逐步转变为有序序列的排序方法，其特点在于通过元素间的两两比较和交换来实现排序效果",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "回溯法基础的特点的核心性质是在问题的解空间树中，按照深度优先策略从根节点出发搜索解空间，通过判断当前节点是否满足条件来决定是继续",
    "head": "回溯法",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "线性表是零个或多个数据元素的有限序列，其中数据元素之间存在一对一的线性关系，且有唯一的开始元素和终端元素，除开始元素外每个元素有",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序好，每一趟排序都会将未排序数据中最大（",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "二叉树的遍历是指按照某种规则依次访问二叉树中的每个节点，使得每个节点被访问且仅被访问一次，其核心特征是通过特定的顺序规则对二叉树",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "4"
  },
  {
    "sentence": "交换排序通过比较和交换元素位置来逐步将无序序列转变为有序序列，其核心性质是在排序过程中不断地交换逆序对元素，使得序列中元素的顺序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "集合的核心特征包括确定性、互异性和无序性，确定性是指集合中的元素必须是确定的，即任何一个对象要么是该集合的元素，要么不是，二者必",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "快速排序是对无序数组通过选择一个基准值，将数组分为两部分，小于基准值的放在左边大于的放右边，然后对左右两部分分别递归进行此操作以",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的内存地址，通过它可以间接访问和操作所指向的内存位置的数据，具有灵活高效地访问和修改",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个直接前驱，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序，每一趟冒泡会将未排序部分的最大",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "父节点的核心特征是在树形数据结构中，对于某个节点而言，其直接位于该节点之上的那个节点所具有的关键特性，这些特性使得该父节点在整个",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "58"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，且除根节点外其余节点被分成若干互不相交的有限集合，每个集合又是一棵树并称为该根节点的子",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "23"
  },
  {
    "sentence": "栈是一种只能在一端进行插入和删除操作的特殊线性表，允许进行插入和删除操作的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为",
    "head": "插入",
    "tail": "删除",
    "head_offset": "11",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个单链表，链表中每个节点存放与该顶点相邻接的顶点信息，从而简洁高效",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中，从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步并继续",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完当前层次的所有节点后再进入下一层，直到遍历完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间路径，并在满足特定条件时记录或进一步处理解，不满足条件时回溯到上一步重新尝试，以找到问题的解",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "广度优先搜索是一种图或树的遍历算法，它从起始节点开始，按照层次依次访问节点，先访问距离起始节点较近的节点，直至遍历完所有可达节点",
    "head": "广度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元包含数据以及指向其子节点的指针且根节点没有父节点叶节点没有子节点中间节点有一个父节点和多个子节点",
    "head": "树的节点",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素在计算机内存中的存储方式及相互关系会影响数据的访问效率、存储空间利用率以及算法实现的复杂度等",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "抽象数据类型具有数据抽象和数据封装的特点，数据抽象是指将数据的逻辑结构和操作与数据的物理表示分离，数据封装是指将数据和操作数据的",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "二分查找的核心特征是在有序数组中通过不断将数组分成两部分，每次根据中间元素与目标值的比较结果，决定在左半部分还是右半部分继续查找",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据类型是一组值的集合以及定义在这组值上的一组操作的总称，其特点包括具有特定的数据表示形式、取值范围和对该类型数据所能进行的合法",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是尾节点的指针指向头节点，从而形成一个环形结构，使得链表可以循环遍历，不存在明显的头和尾的区别，",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，具有优先访问深度方向上节点的特点",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "哈希表是一种数据结构，通过哈希函数将键映射到表中的特定位置，具有常数时间的平均查找、插入和删除操作，不同的键可能映射到相同位置即",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其核心性质为每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可顺序访问链表中的各个节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将数组中间元素与目标值比较，根据比较结果将搜索范围缩小到数组的前半部分或后半部分，重复此过程",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点近的节点，具有每层节点先于下一层节点被访问的特点且能保证找到的路径是最短路径",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完当前层次的所有节点后，再进入下一层继续访问，",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，通过多次重复此操作将最大（或最小）元素逐步“冒泡”到数组末尾（或开头）从而实现",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个直接前驱，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种顺序排列，每个元素最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是尾节点的指针指向头节点，形成一个环形结构，使得链表中的节点可以依次遍历，没有明确的头和尾之分，",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "父节点的核心特征是在树形结构等相关数据结构中，直接位于某个节点之上，该节点与其子节点存在特定的层次关系，并且对其下一级子节点具有",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "59"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组有序，每次遍历会将最大（或最小）元素“冒泡”到数组末尾（",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "迭代法的核心特征是基于已有的初始值，按照固定的迭代公式不断重复计算，使结果逐步逼近目标值，每一次迭代都利用上一次迭代的结果来生成",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "引用是给已定义变量起别名，使同一内存位置有多个名字，对引用操作就是对其绑定对象操作，引用在定义时必须初始化且初始化后不能再绑定到",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "50",
    "tail_offset": "54"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中，通过尝试不同的选择路径，当发现当前路径无法达到目标或不满足条件时，就回溯到上一步重新选择",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "引用是给已存在对象起的一个别名，通过引用可以直接访问该对象，对引用的操作会直接作用于其所引用的对象，引用在定义时必须初始化且一旦",
    "head": "访问",
    "tail": "初始化",
    "head_offset": "24",
    "tail_offset": "58"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，不断重复此过程，将最大元素逐步“冒泡”到数组末尾，经过多轮比较",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "53"
  },
  {
    "sentence": "双向链表是一种链表结构，每个节点除了有指向下一个节点的指针外还有指向前一个节点的指针，从而支持双向遍历，在插入和删除操作时比单向",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点，从而直观地反映图",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "线性查找是从数据序列的开头开始，依次将每个元素与目标值进行比较，直到找到目标值或遍历完整个序列，其核心性质是按顺序逐个检查元素来",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "40"
  },
  {
    "sentence": "树的节点是树结构中的基本单元，包含数据以及指向其子节点的引用，根节点没有父节点，其他节点有且仅有一个父节点，并且每个节点可以有零",
    "head": "树的节点",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "指针是一种变量，其值为内存地址，通过指针可以间接访问和修改所指向内存位置的数据，指针的类型决定了它所指向数据的类型以及对该数据的",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "快速排序是对数组进行排序的一种算法，它选择一个基准值，将数组分为两部分，小于基准值的元素放在左边，大于基准值的元素放在右边，然后",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，将最大（或最小）元素逐步“冒泡”到数组末尾，重复此过程对整个数组进行排序的简单",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法核心特征为每一趟将一个待排序的数据元素，插入到前面已经排好序的数列中的",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "非线性结构的特点的核心性质是其节点之间的关系不再是一对一的线性关系，存在一对多、多对多等复杂关系，数据元素之间的前驱和后继关系不",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "49"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻的其他顶点，从而实现对图的存储",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "深度优先搜索的核心特征是沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，优先访问深度大的节点",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，其余节点被分为若干互不相交的子树，每个子树也是一棵树，并且具有层次关系，除根节点外每个",
    "head": "根节点",
    "tail": "子树",
    "head_offset": "17",
    "tail_offset": "35"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，通过多次重复此过程将最大（或最小）元素逐步“冒泡”到数组末尾（或开头）从而实现",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "集合的核心性质包括确定性、互异性和无序性，确定性是指集合中的元素必须是确定的，互异性是指集合中的元素互不相同，无序性是指集合中的",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问其所指向的变量，能灵活地对内存进行操作，方便实现数据的动态存储",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "选择排序每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完，其核心特征是",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "线性表是一种具有相同数据类型的n个数据元素的有限序列，其特点是数据元素之间存在一对一的线性关系，有唯一的开始元素和终端元素，且除",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点，从而直观地展示图",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "集合的核心特征是具有确定性、互异性和无序性，确定性指集合中的元素必须是确定的，即任何一个对象要么是该集合的元素，要么不是，二者必",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问其所指向的变量，能灵活方便地进行数据的传递和操作，并且可以动态",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，通过队列来辅助实现，以确保每个节点都能被访问到且按层次顺序",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即各数据元素之间的逻辑关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问起始节点及其所有邻接节点，再依次访问这些邻接节点的邻接节点等，直到遍历完所有节点或",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定的存储位置，从而实现快速的数据查找、插入和删除操作，其核心特征是能高效地根据键",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其核心特征包括每个节点包含数据域和指针域，指针域指向下一个节点，通过依次访问节点的指针域来遍历整个",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据的逻辑结构的核心性质是描述数据元素之间的逻辑关系，它独立于数据的存储方式，且与数据的运算和处理方式密切相关，反映了数据在组织",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "15"
  },
  {
    "sentence": "比较排序是基于元素之间的比较操作来确定元素之间的相对次序从而实现排序的一种排序算法其核心性质是排序结果仅依赖于元素之间的比较关系",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "父节点的核心特征是在树形结构等相关数据结构中，对于某个特定节点而言，它是直接位于该节点之上一层的节点，并且该父节点具有能够连接和",
    "head": "父节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "54"
  },
  {
    "sentence": "树的节点是树结构中的基本组成单元包含数据以及指向子节点的指针除根节点外每个节点有且仅有一个父节点根节点没有父节点叶节点没有子节点",
    "head": "树的节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "回溯法基础的定义的核心特征是在问题的解空间树中，按照深度优先策略从根节点出发搜索解空间，通过判断当前节点是否满足问题的约束条件来",
    "head": "回溯法",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历且遍历完尾节点后可回到头",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的查找特点是基于树型结构进行特定元素查找，依据其层次关系与节点间联系，通过特定算法从根节点或其他起始点出发，按一定规则遍历节点",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "19"
  },
  {
    "sentence": "路径是由顶点和相邻顶点序偶构成的序列，其特点的核心性质包括具有起点和终点，路径中任意两个相邻顶点之间存在边相连，路径的长度为路径",
    "head": "路径",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "迭代法的核心性质是通过从一个初始估计值开始，重复应用相同的计算规则或公式，逐步逼近问题的精确解，每一次迭代都基于上一次迭代的结果",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "迭代法的核心特征是通过不断重复执行相同的计算步骤，利用上一次迭代的结果来逐步逼近问题的解，每一次迭代都基于前一次的结果进行更新，",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半，每次根据目标值与中间元素的比较结果，决定在左半区间或右半区间继续查找，直至找到目标",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表是一种线性数据结构，每个节点包含数据和指向下一个节点的指针，其特点包括除了尾节点外每个节点都有一个后继节点，通过头节点可以",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "线性表的核心性质是具有有限个数据元素，数据元素之间存在一对一的线性关系，有唯一的表头元素和表尾元素，除表头元素外每个元素有且仅有",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "集合具有确定性、互异性和无序性这三个核心特征，其中确定性是指集合中的元素必须是确定的，互异性是指集合中的元素互不相同，无序性是指",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "子节点是树结构中与父节点直接相连且位于父节点下方的节点，具有与父节点存在特定连接关系以及在树的层级结构中有明确位置关系等核心性质",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，且最后一个节点的指针指向空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和相关操作的抽象描述，而不涉及具体的存储结构和实现",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "深度优先搜索是一种在搜索过程中优先沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续探索其他路径的搜索策略",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "回路是图中从一个顶点出发，沿着边经过一系列顶点后又回到该起始顶点的路径，其核心特征包括至少包含一条边且起点和终点相同，不包含重复",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问图或树中节点的搜索算法，先访问起始节点，再依次访问其相邻未访问节点，然后按层次继续访问下一层的",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，它强调数据的逻辑结构和相关操作的抽象描述，而不涉及具体的存储结构和实现",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "顺序表的核心特征是其逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过数组下标直接计算出元素的存储地址，支持随机访问，插入和删除",
    "head": "数组",
    "tail": "访问",
    "head_offset": "36",
    "tail_offset": "57"
  },
  {
    "sentence": "回溯法基础的定义的核心性质是在问题求解过程中通过深度优先搜索方式，系统地尝试所有可能的解路径，当发现当前路径无法得到有效解或已无法",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，它从起始顶点开始，按照层次依次访问其邻接顶点，直到遍历完所有顶点或找到目标顶点，通过队列来辅助实现以",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "回路的核心性质是从回路中任意一点出发，沿着回路的边行进，最终能回到出发点，且回路中的边不重复经过（在简单回路情况下），同时回路包含",
    "head": "回路",
    "tail": "回路",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间缩小一半来快速定位目标元素的查找算法其特点是每次比较都能排除一半的元素从而高效地找到目标值",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心特征是通过不断比较和交换元素的位置，将无序序列逐步转换为有序序列，在排序过程中相邻元素或不相邻元素间",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "非线性结构的核心特征是其数据元素之间存在着一对多或多对多的关系，各个数据元素不再保持依次的线性顺序，而是呈现出较为复杂的层次或网状",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑结构中数据元素之间呈线性关系，其物理存储结构是用一组地址连续的存储单元依次存储数据元素，使得逻辑上相邻",
    "head": "线性表",
    "tail": "逻辑结构",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，另一个指向后继节点，通过这两个指针可以在两个方向上",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，其核心性质是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置以实现快速数据访问，具有插入、删除和查找操作平均时间复杂度接近O(1)的特点，能高效存储和检索",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "选择排序是一种每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "简单排序的特点的核心特征是比较和交换元素的位置以实现排序，其操作相对直接和基础，通常基于相邻元素的比较与交换来逐步将无序序列转变为",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "二分查找的核心特征是在有序数组中，通过不断将数组分成两部分并比较目标值与中间元素，从而逐步缩小查找范围，直到找到目标值或确定目标值",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是一种每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过每次将查找区间缩小一半的方式，不断比较中间元素与目标值，若中间元素等于目标值则查找成功，若中间元素",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后对这两部分分别",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个单链表，链表中存储与该顶点相邻接的顶点，具有存储空间较小、便于查找",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "存储结构的特点是指数据在计算机内存或外存中存储方式所具有的诸如数据元素间逻辑关系的表示方法、数据元素的存储方式以及数据元素间关系的",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列，其核心性质是按顺序逐个",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "哈希表的核心特征是通过哈希函数将键映射到特定位置，使得插入、查找和删除操作在平均情况下能在接近常数时间内完成，并且不同的键经过哈希",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点近的节点，通过队列来辅助实现，直至遍历完所有节点或找到目标节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "引用是给已存在的变量起一个别名，对引用的操作实际上就是对其所引用变量的操作，其核心性质包括：引用必须在定义时初始化，且初始化后不能",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "54",
    "tail_offset": "59"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法其核心性质是通过构建有序序列对于未排序数据在已排序序列中从后向前扫描找到",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，使得可以通过该别名来访问和操作原本的对象，其核心特征包括与被引用对象绑定、具有相同的数据类型以及对",
    "head": "访问",
    "tail": "数据类型",
    "head_offset": "26",
    "tail_offset": "58"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问离起始节点距离为 0 的节点，再访问距离为 1 的节点，以此类推，直到访问完所有可达",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "指针是一种变量，其值为内存地址，通过指针可以间接访问其所指向的内存位置，能灵活地对内存中的数据进行操作，具有高效性和灵活性，可用于",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置来存储数据，其核心特征包括能在平均常数时间内进行插入、删除和查找操作，具有较高的存储和检索效率",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间路径，利用深度优先搜索策略，在搜索过程中通过剪枝函数避免无效搜索，以找到满足特定条件的解或最优",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "加权图是一种图结构，其中每条边都被赋予一个数值作为权重，这些权重可以表示诸如距离、成本、时间等各种含义，用于描述图中顶点之间关系的",
    "head": "加权图",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "回溯法是一种通过系统地尝试所有可能的解，以深度优先搜索方式递归地构建解空间树，并在搜索过程中通过剪枝策略避免无效搜索路径，从而找到",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序方法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与目标值进行比较，直到找到目标值或遍历完整个序列，其核心性质是顺序性地逐个检查",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "43"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，具有在平均情况下能以接近常数时间进行插入、删除和查找操作的",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构使得链表中各个节点可以依次被访问而不会出现访问越界的情况",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过头节点指针来访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外还包含两个指针域，分别指向前驱节点和后继节点，通过这些指针可在两个方向上遍历",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "顺序表是一种线性表，它的逻辑结构中数据元素之间是一对一的关系，其物理存储结构是用一组地址连续的存储单元依次存储数据元素，使得逻辑上",
    "head": "线性表",
    "tail": "逻辑结构",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "集合具有确定性、互异性和无序性这三个核心特征，其中确定性是指集合中的元素必须是确定的，即任何一个对象要么是该集合的元素，要么不是，",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "迭代法的核心特征是通过从一个初始估计值开始，利用相同的计算规则或公式不断重复计算，逐步逼近问题的精确解，每次迭代产生的结果会作为下",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "54"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点较近的节点，在访问完同一层所有节点后再进入下一层，直到找到目标节点或遍历完所有",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "指针的核心特征是其存储的是变量的内存地址，通过该地址能够直接访问和操作所指向变量的值，并且指针变量本身也有自己的内存地址用于存储所",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，其核心性质是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，直至找到目标值或确定目标值不存在的一种查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "双向链表是一种链表结构，其每个节点除了包含数据域外还包含两个指针域，分别指向前驱节点和后继节点，从而支持双向遍历，在插入和删除节点",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，其核心性质是从起始节点开始，尽可能深地探索一条路径，直到无法继续或达到目标节点，然后",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列，其核心特征是按顺序逐个",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点的核心特征是尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历且遍历完尾",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "非线性结构的核心特征是在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即数据元素之间的关系不再是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "快速排序的核心性质是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后对这两部分分别",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，具有平均情况下快速的插入、删除和查找操作，不同的键经过哈希",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "引用是给已存在的变量起一个别名，对引用的操作实际上就是对其所引用变量的操作，引用必须在定义时初始化且一旦初始化便不能再引用其他变量",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "46",
    "tail_offset": "52"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外，还包含两个指针，一个指向前驱节点，另一个指向后继节点，通过这两个指针可以在两个方向上",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "顺序表的核心性质是其逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过数组下标直接计算出元素的存储地址，访问元素的时间复杂度为O",
    "head": "数组",
    "tail": "访问",
    "head_offset": "36",
    "tail_offset": "53"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻接的其他顶点，具有空间复杂度低、",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中，从起始节点开始，沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过头节点的指针来访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "循环链表是一种链表结构，其尾节点的指针域指向头节点，使得整个链表形成一个环，从而实现从链表中任意节点出发都能遍历到链表中的所有节点",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "快速排序是对数组进行划分，选择一个基准值，将数组分为两部分，小于基准值的放在左边大于基准值的放在右边，然后对左右两部分分别递归进行",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "选择排序是一种每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "父节点的核心特征是在树形结构中，处于较高层级且与其他节点存在特定关联关系，能够直接衍生出子节点，对整个树形结构的层次和关系起到关键",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，另一个指向后继节点，通过这两个指针可以在两个方向上",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "顺序表是一种线性表，其核心性质为用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理存储位置上也相邻",
    "head": "线性表",
    "tail": "线性表",
    "head_offset": "6",
    "tail_offset": "32"
  },
  {
    "sentence": "引用是一个已定义变量的别名，对引用的操作等同于对其引用的变量的操作，其核心性质包括：引用必须在定义时初始化且初始化后不能再引用其他",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "50",
    "tail_offset": "54"
  },
  {
    "sentence": "树的核心特征是有且仅有一个特定的节点被称为根节点，其余节点被分成若干个互不相交的有限集合，每个集合本身又是一棵树，这些集合被称为该",
    "head": "根节点",
    "tail": "集合",
    "head_offset": "21",
    "tail_offset": "42"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，其中每个元素在序列中有唯一的前驱和后继（除第一个元素无前驱，最后一个元素无后继外",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列，其核心特征是按顺序逐个",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间的逻辑关系，如线性结构中元素一对一的关系、树形结构中元素一对多的关系、图状结构中元素",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，通过多次重复此过程将最大元素逐步“冒泡”到数组末尾，从而实现对数组进行排序的算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "链表是一种线性数据结构，其特点是用一组任意的存储单元存储线性表中的数据元素，这些存储单元可以是连续的也可以是不连续的，数据元素之间",
    "head": "链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "线性表是一种由有限个数据元素组成的序列，其中每个元素都有且仅有一个直接前驱和一个直接后继（除第一个元素无前驱，最后一个元素无后继外",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始结点和一个终端结点，并且所有结点都有且仅有一个直接前驱和一个直接",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法其核心性质是通过构建有序序列对于未排序数据在已排序序列中从后向前扫描找到",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和修改其所指向的变量的值，具有灵活性和高效性，可用于动态内存分配",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的每个节点表示与该顶点相邻接的顶点，具有存储紧凑、便于",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "在数据结构中，稳定性是指对于相等的元素，排序前后它们的相对顺序保持不变，即如果两个元素的值相等，在排序前一个元素在另一个元素之前，",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中，从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续探索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "非线性结构的核心性质是存在一对多或多对多的关系，各数据元素之间不再保持线性关系，其中至少有一个数据元素有两个或两个以上的直接前驱或",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点近的节点，通过队列来辅助实现，直至遍历完所有节点或找到目标节点的搜索算法",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性查找是一种在数据序列中从起始位置开始依次逐个检查元素，直到找到目标元素或遍历完整个序列的查找方法，其特点的核心性质是顺序性地对",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "交换排序的核心特征是通过比较元素并交换位置，将无序序列逐步转变为有序序列，在排序过程中不断调整元素间的相对顺序直至达到最终有序状态",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，其核心特征包括能将键高效映射到存储位置以实现快速的数据插入",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后对这两部分分别",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "线性查找是一种在数据序列中从起始位置开始依次逐个比较元素，直到找到目标元素或遍历完整个序列的查找方法其核心特征是按顺序逐一检查元素",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种简单且稳定的排序算法其特点是比较操作主要针对未排序数据与已排序序列中的元素从",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "非线性结构的特点的核心特征是数据元素之间存在着一对多或多对多的关系，不像线性结构那样存在唯一的前驱和后继关系，其元素的排列没有明显",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，另一个指向后继节点，通过这两个指针可以在两个方向上",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找特定元素的高效算法，其核心性质是每次比较都将搜索区间缩小一半，通过不断将区间中点与目标值比较，若相等",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始节点开始，按层次依次访问节点，先访问距离起始节点近的节点，通过队列来辅助实现，保证每一层的节点",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两部分并根据目标值与中间元素的比较结果，在其中一个子区间继续查找以确定目标值是否存在的查找",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二分查找的核心特征是在一个有序数组中，通过不断将数组分成两部分，并根据目标值与中间元素的比较结果，确定目标值所在的子数组，然后继续",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置，通过依次对未排序数据进行处理，不断扩大已排序序列的范围，最终使整个数组",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问的节点的邻接节点会在后续依次被访问，直至遍历完所有可达节点的搜索算法，其特点包括按照",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "集合的核心特征包括确定性、互异性和无序性，确定性是指集合中的元素必须是确定的，即任何一个对象要么是这个集合的元素，要么不是，二者必",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针域指向头节点，使得整个链表形成一个环，从链表中的任意一个节点出发都可以遍历到链表中的其他所有节点",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除第一个元素外每个元素有且仅有一个直接前驱，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储表示形式，其核心性质包括数据元素在存储器中的存储方式以及数据元素之间的逻辑关系如何在存储中体现",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "30"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "双向链表的每个节点除了包含数据域外，还包含两个指针域，一个指向前驱节点，另一个指向后继节点，这使得双向链表既可以向前遍历也可以向后",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "回溯法基础的特点是在问题求解过程中通过深度优先搜索策略，对解空间进行遍历，按照一定规则尝试构建解，当发现当前部分解无法继续扩展或不",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，具有平均情况下快速的插入、删除和查找操作，不同的键经过哈希",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始顶点开始，逐层地访问顶点，先访问距离起始顶点近的顶点，直至访问完所有可达顶点，其核心性质是按照",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个单链表，链表中的每个节点表示与该顶点相邻接的顶点，从而有效地存储和",
    "head": "邻接表",
    "tail": "单链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，直至找到目标值或确定目标值不存在的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有唯一的表头和表尾，元素之间存在一对一的线性关系，相邻元素之间顺序存储，通过下标",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "穷举法是一种通过对所有可能的情况进行逐一列举和检验，从而找到问题解决方案的方法，其核心性质是在解决问题时会遍历所有可能的情况来寻找",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "53"
  },
  {
    "sentence": "迭代法的核心特征是通过从一个初始估计值开始，利用固定的迭代公式不断重复计算，逐步逼近问题的精确解，每一次迭代都基于上一次的结果进行",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "冒泡排序的核心性质是比较相邻元素大小，若顺序错误就把它们交换过来，经过多次这样的比较和交换，将最大元素逐步“冒泡”到数组末尾，重复",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "58"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除第一个元素外每个元素有且仅有一个直接前驱，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性查找是从数据序列的开头开始，依次将每个元素与目标值进行比较，直到找到目标值或遍历完整个序列，其特点的核心性质是逐一比较数据元素",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "40"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组有序，较小元素像气泡一样逐渐“浮”到数组前端，较大元素“沉",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，其核心特征是能在平均情况下以接近常数的时间复杂度进行插入、",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "回路是数据结构中从一个顶点出发，沿着边经过一系列顶点后又回到该起始顶点所形成的路径，其特点包括顶点和边的特定组合关系且至少包含一条",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "选择排序是一种每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序方法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "图的核心特征是由顶点集合以及顶点之间的边集合所构成，顶点用于表示事物，边用于表示事物之间的关系，且边具有方向性或无方向性，顶点之间",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "20"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并根据比较结果交换位置，将最大或最小元素逐步“冒泡”到数组末尾，重复此过程直至整个数组有序的排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的地址，通过指针可以间接访问和修改所指向的内存位置的数据，具有指向特定内存地址、可用于",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "非线性结构的核心特征是每个节点至少有一个前驱节点和一个后继节点并且节点之间的关系不是一对一的，可能存在一对多、多对一或多对多的关系",
    "head": "非线性结构",
    "tail": "前驱节点",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其中数据元素之间存在一对一的线性关系，即除第一个元素外，每个元素有且仅有一个直接前驱",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储方式，包括数据元素的存储及其关系的表示，其特点涵盖存储位置、存储顺序、存储格式等多方面具体表现",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "抽象数据类型是一个数学模型以及定义在该模型上的一组操作，其特点包括数据的逻辑结构独立于具体的存储结构，通过定义的操作来处理数据，且",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列，其特点的核心性质是逐一",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法其核心性质是通过构建有序序列对于未排序数据在已排序序列中从后向前扫描找到",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "集合具有确定性、互异性和无序性，其中确定性是指集合中的元素必须是确定的，互异性是指集合中的元素互不相同，无序性是指集合中的元素没有",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，描述了数据元素之间的抽象关系，包括集合结构、线性结构、树形结构和",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，通过该别名可访问其所引用的对象，对引用的操作实际上就是对其所引用对象的操作，引用在定义时必须初始化",
    "head": "访问",
    "tail": "初始化",
    "head_offset": "22",
    "tail_offset": "62"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，它按照层次依次访问节点，先访问起始节点，再依次访问其相邻节点，然后是相邻节点的相邻节点等，直到遍历完",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法基础的特点是在问题求解过程中通过尝试所有可能的解路径，当发现当前路径无法得到有效解时就回溯到上一步重新选择其他路径以寻找满足",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序方法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "引用是一种变量，它为已存在的变量起一个别名，通过该别名可对同一内存位置的数据进行访问和操作，其特点包括与被引用对象绑定、一旦初始化",
    "head": "访问",
    "tail": "初始化",
    "head_offset": "40",
    "tail_offset": "62"
  },
  {
    "sentence": "抽象数据类型的定义的核心特征是以数据对象、数据关系、基本操作这三方面来描述，其中数据对象是所操作数据的集合，数据关系是数据对象中各",
    "head": "抽象数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "顺序表具有随机访问特性可在O(1)时间内通过下标访问元素，其存储元素紧凑无间隙存储利用率高，逻辑上相邻元素物理存储位置也相邻，插入",
    "head": "访问",
    "tail": "访问",
    "head_offset": "7",
    "tail_offset": "24"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和修改所指向的变量，具有指向特定内存地址、灵活操作内存以及可作为",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作，通过多次遍历序列逐步将数据按特定顺序排列，具有操作相对简单直观、时间复杂度通常较高等特点",
    "head": "简单排序",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "快速排序是对无序数组通过选择基准值将数组分为两部分，小于基准值部分和大于基准值部分，再对这两部分分别递归进行排序从而实现整体有序，",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后对这两部分分别",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "非线性结构的核心特征是其元素之间的关系并非简单的一对一或顺序排列，存在一对多、多对多等复杂关系，数据元素之间的逻辑关系呈现出网状或",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间的逻辑关系，以及数据元素在这种关系下的组织方式和相互作用方式等方面共同构成其独特性质",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "树是一种非线性的数据结构，它的核心特征包括有且仅有一个根节点，根节点没有前驱节点，其余节点有且仅有一个前驱节点，每个节点可以有零个",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "27",
    "tail_offset": "31"
  },
  {
    "sentence": "顺序表具有随机访问特性可在O(1)时间内通过下标访问元素，逻辑上相邻的元素在物理存储位置上也相邻，存储空间连续，插入和删除操作平均",
    "head": "访问",
    "tail": "访问",
    "head_offset": "7",
    "tail_offset": "24"
  },
  {
    "sentence": "图的核心性质是由顶点集合和边集合构成，顶点集合中的元素通过边集合中的边相互连接，且边具有方向性或无方向性，同时顶点和边可以带有各种",
    "head": "集合",
    "tail": "集合",
    "head_offset": "10",
    "tail_offset": "14"
  },
  {
    "sentence": "树的查找的核心特征是基于树的结构特性，通过特定的遍历方式从根节点开始，沿着特定路径搜索目标节点，利用节点之间的父子关系及层次结构，",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "24"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，其核心特征是能在平均情况下以接近常数的时间复杂度进行插入、",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "引用是对变量的别名，其特点包括与被引用变量共享内存空间，对引用的操作等同于对被引用变量的操作，定义时必须初始化且一旦初始化便不能再",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "52",
    "tail_offset": "58"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间来求解问题，在搜索过程中按照深度优先策略，当发现当前路径无法得到有效解时就回溯到上一步重新选择",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "抽象数据类型定义的核心特征是由数据对象、数据对象上的关系以及定义在这些数据对象和关系上的操作组成且数据对象是一个值的集合其数据关系",
    "head": "抽象数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "58"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过每次将数组中间元素与目标值比较，根据比较结果决定在数组的前半部分或后半部分继续进行同样的查找操作，",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "穷举法是一种通过对所有可能情况进行逐一列举和检验，从而找出满足特定条件的解的方法其特点在于会全面遍历问题的所有可能解空间不遗漏任何",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "树的节点是树中的数据元素包含数据项及指向其子树节点的分支且根节点没有前驱节点非根节点有且仅有一个前驱节点叶子节点没有后继节点非叶子",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "子节点是树结构中直接与某个节点相连且处于其下一层级的节点，具有直接隶属于某个父节点、与父节点通过特定连接关系形成树形层次结构以及其",
    "head": "子节点",
    "tail": "父节点",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "非线性结构的特点的核心性质是其元素之间的关系并非简单的顺序关系，存在一对多或多对多的关系，不像线性结构那样呈现一对一的线性排列，在",
    "head": "非线性结构",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "47"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间路径，当发现当前路径无法达到目标时就回溯到上一步，以找到问题的所有解或最优解的数据结构求解方法",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个将元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列仍未找到",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，一个指向后继节点，这使得双向链表既可以从前往后遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，其核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其核心性质包括比较相邻元素大小，若顺序错误就把它们交换过来，对于未排序",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列合适位置的排序算法，其特点是比较次数较少、稳定排序且适用于部分有序数据或数据量较小的情况",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间路径，利用深度优先搜索策略逐步构建解，当发现当前路径无法得到有效解时则回溯到上一步，以找到问题",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定的存储位置，从而实现快速的数据查找、插入和删除操作，其核心特征是利用哈希函数把键",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定的存储位置，使得在平均情况下可以在常数时间内进行插入、查找和删除操作，其核心特征",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后对这两部分分别",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，对引用的操作实际上就是对其所引用对象的操作，引用在定义时必须初始化且初始化后不能再引用其他对象，其",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "46",
    "tail_offset": "50"
  },
  {
    "sentence": "选择排序是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的一种排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "归并排序是一种稳定的排序算法，它采用分治思想，将数组分成两个子数组分别排序后再合并，时间复杂度为O(n log n)，空间复杂度为",
    "head": "归并排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的查找的核心性质是若树中存在关键字值等于给定值的结点则查找成功否则查找失败且从根结点开始按一定规则依次比较关键字值来确定是否找到",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "哈希表是一种数据结构，其特点的核心性质包括通过哈希函数将键映射到特定位置以实现快速查找，不同键可能映射到相同位置会产生哈希冲突，且",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，其核心性质是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "交换排序的核心特征是通过比较元素并交换位置，将无序序列逐步调整为有序序列，在排序过程中不断地对相邻元素进行比较，若顺序错误就把它们",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "树的节点是构成树结构的基本单元，具有一个数据元素及指向其子节点的若干分支，根节点没有前驱，其余节点有且仅有一个前驱，每个节点可以有",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作，通过逐步将较小（或较大）元素移动到合适位置来实现排序，具有操作相对简单直观、适用于数据量",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始顶点开始，按层次依次访问顶点，先访问距离起始顶点最近的一层顶点，再访问更远层的顶点，通过队列来",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "选择排序是一种每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序方法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心特征是通过比较元素并交换位置，逐步将无序序列转换为有序序列，在排序过程中，相邻元素或不相邻元素会根据",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间来求解问题的算法策略，从初始状态出发，按照深度优先搜索的方式，逐步构建解向量，当发现当前部分解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "抽象数据类型定义的核心性质包括数据对象集是一个值的集合且有确定范围，数据关系集定义了数据对象之间的逻辑关系，基本操作集是对数据对象",
    "head": "抽象数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和修改所指向的变量的值，指针具有指向特定内存地址、可用于传递地址",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "冒泡排序是一种比较排序算法，通过多次比较和交换相邻元素，将最大（或最小）元素逐步“冒泡”到数组末尾，其核心性质是比较相邻元素大小并",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "顺序表是一种线性表，其核心特征为用一组地址连续的存储单元依次存储数据元素，数据元素在内存中按顺序存放，元素之间的逻辑顺序与物理存储",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "6",
    "tail_offset": "32"
  },
  {
    "sentence": "二分查找的核心特征是在一个有序数组中，通过不断将数组分成两部分，并根据目标值与中间元素的比较结果，确定目标值所在的子数组，从而逐步",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始结点和一个终端结点，并且所有结点都有且仅有一个直接前驱和一个直接",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中的节点表示与该顶点相邻的其他顶点，从而能够高效地存储和",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后对这两部分分别",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，将最大元素逐步“冒泡”到数组末尾，通过多次重复此过程对整个数组进行排序的算法，其",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "操作效率的特点是指在数据结构相关操作中，包括但不限于数据的存储、检索、插入、删除等操作，所呈现出的诸如时间复杂度、空间复杂度等方面",
    "head": "操作效率",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据和指向下一个节点的指针外，还包含一个指向前一个节点的指针，从而可以在两个方向上",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环形结构，从而可以从链表中的任意一个节点出发遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到该关键字或者遍历完整个序列都未找到的查找方法",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并根据比较结果交换位置，将最大（或最小）元素逐步“冒泡”到数组末尾（或开头）从而实现对数组进行排序的",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "44"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问其所指向的变量，从而实现对该变量存储内容的操作以及在不同内存位置",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "快速排序是对无序数组通过选择一个基准值将数组分为两部分，小于基准值的元素放在左边，大于基准值的元素放在右边，然后对左右两部分子数组",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回溯法基础特点是通过深度优先搜索遍历问题解空间树，在搜索过程中对当前部分解进行可行性检查，若不可行则回溯到上一步重新选择，直到找到",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "快速排序的核心性质是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后对这两部分分别",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点较近的节点，同一层节点的访问顺序不固定，直到遍历完所有可达节点，其核心性质是按",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中，从起始节点开始，沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "抽象数据类型具有数据对象集、数据对象上的关系集以及对数据对象的基本操作集，其特点是数据封装、信息隐藏，将数据和操作封装在一起，对外",
    "head": "抽象数据类型",
    "tail": "集",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置，能在平均常数时间内进行插入、删除和查找操作，具有高效的数据访问能力，且不同",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "非线性结构中至少存在一个数据元素有两个或两个以上前驱或后继，其数据元素之间存在着一对多或多对多的关系，不满足线性结构中数据元素之间",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "回溯法基础特点是在问题求解过程中通过尝试多种可能路径，当某一路径探索到不符合条件时就退回上一步重新选择，直到找到满足条件的解或遍历",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问节点，先访问的节点其邻接节点在后续被访问，且同一层次节点的访问顺序任意，直到所有节点被访问，访问过程",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法其核心特征是通过构建有序序列对于未排序数据在已排序序列中从后向前扫描",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问其所指向的变量，具有指向特定内存地址、可用于动态内存管理、能提高",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中，通过深度优先搜索的方式，从初始状态出发，按照某种规则不断尝试扩展解空间树的节点，当发现当前",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，若遇到死路则回溯到前一步，继续探索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "选择排序是一种每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法，其核心性质是利用前一步的计算结果来",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "选择排序是一种每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序方法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是否属于这个集合是确定的，互异性即集合中的元素互不相同，无序性即集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "快速排序是对无序数组进行排序的高效算法，其核心性质是通过一趟排序将数组分为两部分，使得一部分元素都比另一部分元素小，然后对这两部分",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心特征是通过比较元素并交换位置，逐步将无序序列转换为有序序列，在排序过程中，相邻或不相邻的元素之间不断",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中通过尝试不同的选择路径，当发现当前路径无法达到目标或不满足条件时，就返回到上一步重新选择其他",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除第一个元素外每个元素有且仅有一个直接前驱，",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间路径，在搜索过程中不断检查并舍弃不符合条件的路径，以找到问题的可行解或最优解的数据结构搜索算法",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并将较大元素逐步交换到右侧，通过多次重复此过程把最大元素“冒泡”到数组末尾从而实现对数组元素按升序或",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "选择排序是一种每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序方法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点最近的节点，在访问完同一层的所有节点后，再进入下一层进行访问，通过",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "双向链表每个节点包含两个指针，一个指向前驱节点，一个指向后继节点，通过这两个指针可以方便地在链表中双向遍历，既可以从前往后也可以从",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置，每次将一个待排序的数据插入到前面已经排好序的数组中的适当位置直到全部待",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "回溯法基础的特点是按深度优先策略，从根节点出发搜索解空间树，在搜索过程中通过判断当前节点是否满足条件来决定是继续向下搜索还是回溯到",
    "head": "回溯法",
    "tail": "根节点",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "双向链表是一种线性数据结构，其每个节点除了包含数据域外，还有两个指针域，一个指向前驱节点，另一个指向后继节点，通过这两个指针可以在",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的一个整体，这些对象称为该集合的元素，具有确定性、互异性和无序性，其中确定性是",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "回溯法基础特点是通过深度优先搜索遍历解空间树，在搜索过程中利用剪枝函数避免无效搜索以提高求解效率，按深度优先方式系统地搜索问题的解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是否属于这个集合是明确的，互异性即集合中的元素互不相同，无序性即集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序查找是对线性表中的元素依次进行比较，直到找到目标元素或遍历完整个线性表，其特点是算法简单但效率较低，平均时间复杂度为O(n)，",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "双向链表是一种链表数据结构，每个节点除了有数据域外还有两个指针域，分别指向前驱节点和后继节点，通过这些指针可以在两个方向上遍历链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中，沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续探索其他路径的搜索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "顺序表的核心性质是其逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过数组下标直接计算出元素的存储地址，具有随机访问特性，插入和",
    "head": "数组",
    "tail": "访问",
    "head_offset": "36",
    "tail_offset": "57"
  },
  {
    "sentence": "顺序表的核心特征是其逻辑上相邻的元素在物理存储上也相邻，并且可以通过数组下标直接访问其中的任何元素，每个元素存储时按顺序依次排列，",
    "head": "数组",
    "tail": "访问",
    "head_offset": "34",
    "tail_offset": "40"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据域和指针域，指针域指向下一个节点，通过头节点可以依次访问链表中的各个节点，其特点包括",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性结构的特点的核心性质是数据元素之间存在着一对一的线性关系，有且仅有一个开始和一个终端元素，除开始和终端元素外，每个元素有且仅有",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点较近的节点，在访问下一层节点之前会遍历完当前层的所有节点，其核心特征是基于层次",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "快速排序的核心性质是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，之后分别对这两部分",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "回溯法基础的特点的核心性质是通过深度优先搜索策略，对问题的解空间进行系统搜索，在搜索过程中利用剪枝函数避免无效搜索路径，以提高搜索",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "数据的逻辑结构的特点是数据元素之间存在的某种逻辑关系，包括集合、线性、树形、图形等结构关系，它独立于数据的存储结构且仅关注数据元素",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "11"
  },
  {
    "sentence": "指针的核心特征是其存储的是变量的内存地址，通过该地址能够直接访问和操作所指向变量的值，从而实现对数据的间接访问和高效处理，并且指针",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "迭代法的核心性质是通过从一个初始估计值开始，不断重复执行相同的计算步骤，逐步逼近问题的精确解，每次迭代都利用上一次迭代的结果来更新",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "49"
  },
  {
    "sentence": "归并排序是一种分治算法，将数组分成两个子数组分别递归排序后合并，具有稳定、时间复杂度为O(n log n)、空间复杂度为O(n)的",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据的逻辑结构的核心性质是数据元素之间的逻辑关系，它描述了数据元素之间的相互联系，包括集合结构、线性结构、树形结构和图状结构等不同",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心特征是描述数据元素之间逻辑关系，独立于数据的存储方式，与数据的运算无关，反映数据在组织层面的整体架构特性",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "18"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，直至找到目标值或确定目标值不存在的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "循环链表是一种链表结构，其尾节点的指针指向头节点，使得整个链表形成一个环形，从链表中的任意节点出发都可以遍历到链表中的其他所有节点",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回溯法基础的核心性质是在问题求解过程中通过深度优先搜索对解空间进行探索，按照深度优先策略从根节点出发搜索解空间树，每到达一个节点时",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来，形成一个链式结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，若数组中存在目标元素则能高效找到其位置，",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "顺序表的核心性质是其逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过数组下标直接计算出元素的存储地址，访问元素的时间复杂度为O",
    "head": "数组",
    "tail": "访问",
    "head_offset": "36",
    "tail_offset": "53"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "抽象数据类型的核心性质包括数据对象集、数据关系集以及定义在数据对象集和数据关系集上的基本操作集，其中数据对象集是抽象数据类型所操作",
    "head": "抽象数据类型",
    "tail": "集",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "递归基础是递归算法中最简单的情况，是递归调用不再继续进行时的终止条件，通常是一个直接可解的简单问题，其特点为具有明确的终止条件使得",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "简单排序是对数据序列进行逐次比较和交换等操作，以将无序数据转变为有序数据，其特点是算法逻辑相对简单、易于理解和实现但时间复杂度通常",
    "head": "简单排序",
    "tail": "时间复杂度",
    "head_offset": "0",
    "tail_offset": "58"
  },
  {
    "sentence": "哈希表的核心特征是通过哈希函数将键映射为特定索引，使得在插入、查找和删除操作时能够在平均情况下以接近常数的时间复杂度完成，不同的键",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性表是一种具有零个或多个数据元素的有限序列，其中数据元素之间存在一对一的线性关系，即除第一个和最后一个元素外，每个元素都有且仅有",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "快速排序是对无序数组通过选择一个基准值，将数组分为两部分，小于基准值的元素放在左边大于基准值的元素放在右边，然后对左右两部分子数组",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列的合适位置的排序算法其特点是比较操作主要在未排序数据与已排序序列的元素之间进行通过不断将",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二叉树遍历是按照某种特定顺序访问二叉树中的每个节点，使得每个节点被访问且仅被访问一次，其核心性质包括先序遍历先访问根节点再递归访问",
    "head": "二叉树",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "3"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是否属于这个集合是明确的，互异性即集合中的元素互不相同，无序性即集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树是一种非线性数据结构，它有一个根节点，其余节点分为若干互不相交的子集，每个子集又是一棵树且称为该根节点的子树，其特点包括每个节点",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "16",
    "tail_offset": "49"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是否属于这个集合是明确的，互异性即集合中的元素互不相同，无序性即集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "指针的核心特征是其存储的是变量的内存地址，通过该地址可以对变量进行间接访问和操作，使得程序能够灵活地处理内存中的数据，在函数调用中",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "归并排序是将一个数组分成两个子数组分别递归排序后再合并成一个有序数组的排序算法其核心性质是通过递归地分解和合并操作实现对数组的排序",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后对这两部分分别",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，并且每个节点最多有一个父节点，除根节点外每个节点有且仅有一个前驱节点，同时每个节点可以有",
    "head": "根节点",
    "tail": "父节点",
    "head_offset": "17",
    "tail_offset": "32"
  },
  {
    "sentence": "指针是一种变量，其值为另一个变量的内存地址，通过指针可以间接访问和修改所指向变量的值，它能够灵活地操作内存中的数据，方便实现数据的",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，其特点包括数据的逻辑结构独立于具体存储结构，强调对数据的操作而不涉及具体",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问离起始节点距离为 0 的节点，再访问距离为 1 的节点，以此类推，直到遍历完所有可达",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外，还包含两个指针域，一个指向前驱节点，一个指向后继节点，通过这两个指针实现节点间的双向",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "回溯法基础的特点是在问题求解过程中，通过深度优先搜索的方式，按照某种规则逐步构建解空间树，在搜索过程中，一旦发现当前部分解无法导致",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "二分查找是在有序数组中，通过不断将区间分成两半，每次根据中间元素与目标值的比较结果，缩小查找区间，直到找到目标值或确定目标值不存在",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据域外，还有两个指针分别指向前一个节点和后一个节点，通过这些指针可以双向遍历链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法，其核心性质是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "非线性结构的核心特征是在数据元素之间存在一对多或多对多的关系，即一个数据元素可以与多个其他数据元素相关联，且这些关联关系不满足线性",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作，将数据按从小到大或从大到小顺序排列，且排序过程相对直接和基础，不涉及复杂的数据结构和算法",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "选择排序是一种每一趟从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完的排序算法",
    "head": "选择排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "迭代法的核心特征是通过从一个初始估计值开始，利用相同的计算规则不断重复计算，逐步逼近问题的精确解，每次迭代的结果都作为下一次迭代的",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，将最大（或最小）元素逐步“冒泡”到数组末尾，从而实现对数组进行排序的简单排序算法",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "抽象数据类型的核心性质包括数据的逻辑结构、定义在该结构上的一组操作以及这些操作所遵循的语义规则，且数据的表示与操作的具体实现相分离",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "快速排序的核心特征是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续探索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量或对象的内存地址，通过指针可间接访问和修改其所指向的内存位置的数据，具有灵活高效地操作内存、",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定的存储位置，使得在平均情况下可以在常数时间内进行插入、查找和删除操作，并且不同的",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "线性表的核心性质是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始元素和一个终端元素，除第一个元素外每个元素有且仅有一个",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，其特点的核心特征为存在唯一的一个被称作“第一个”的数据元素，存在唯一的一个被称作",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找特定元素的高效算法，其核心性质为每次比较都将数组分成两部分，通过判断目标值与中间元素的大小关系，确定",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间路径来寻找问题解的算法策略，在搜索过程中一旦发现当前路径无法导致有效解则回溯到上一步重新选择路径",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "回溯法基础的特点的核心特征是在搜索解空间时通过深度优先搜索策略，按照某种规则依次尝试每一种可能情况，当发现当前选择无法得到有效解时就",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问和修改其所指向的变量的值，具有灵活高效地操作内存、实现动态数据结构",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "双向链表每个节点包含两个指针，一个指向前驱节点，一个指向后继节点，通过这两个指针可以方便地在两个方向上遍历链表，且插入和删除节点时除",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列，其平均时间复杂度为O(n)，空间复杂度为O(",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "双向链表是一种数据结构，其每个节点除了包含数据域外，还包含两个指针域，一个指向前驱节点，一个指向后继节点，通过这些指针可以在两个方向",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "深度优先搜索的核心特征是沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，优先访问深度方向上的节点",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "快速排序是对包含n个记录的序列进行排序，通过一趟排序将序列分为两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中数据元素之间存在一对一的线性关系，即除第一个元素外，每个元素有且仅有一个直接前驱",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "递归基础是递归定义中确定初始元素或最简情况的部分，其核心性质是明确了递归过程的起始点或终止条件，使得递归能够从已知的简单情况逐步构建",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "快速排序是对无序数组通过一趟排序将其分割成两部分，其中一部分元素均比另一部分元素小，然后对这两部分分别进行快速排序以达到整个数组有序",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作以逐步将元素按特定顺序排列，其特点是算法相对直观、易于理解和实现，时间复杂度通常较高，一般适",
    "head": "简单排序",
    "tail": "时间复杂度",
    "head_offset": "0",
    "tail_offset": "53"
  },
  {
    "sentence": "回溯法是一种通过逐步构建问题的解空间树，按照深度优先策略遍历解空间树，在遍历过程中根据问题的约束条件和目标函数来判断当前节点是否满足",
    "head": "回溯法",
    "tail": "树",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标条件后回溯到前一步并继续探索其他",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "操作效率的核心特征是在特定的操作过程中，能够以最少的时间、资源和精力投入，实现最大程度的产出，同时保证操作的准确性和稳定性，并且能够",
    "head": "操作效率",
    "tail": "稳定性",
    "head_offset": "0",
    "tail_offset": "58"
  },
  {
    "sentence": "指针具有能直接访问内存地址、可灵活操作内存数据、能提高程序运行效率、但使用不当易引发内存错误如悬空指针、野指针等导致程序崩溃或出现未",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点较近的节点，逐层推进直至访问完所有节点，其访问过程中优先访问同一层中",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过下标来唯一标识和访问，在内存中按顺序存储，具有存储紧凑、可随机访问等特点",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过头节点的指针来访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "回溯法基础的特点的核心性质是在搜索过程中通过深度优先搜索策略，按照某种规则依次尝试各种可能的解，当发现当前部分解无法继续扩展或不满足",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，其余节点被分成若干互不相交的子集，每个子集又是一棵树，具有层次关系且每个节点有零个或多个子",
    "head": "根节点",
    "tail": "树",
    "head_offset": "17",
    "tail_offset": "46"
  },
  {
    "sentence": "数据的逻辑结构的特点是描述数据元素之间逻辑关系且与数据的存储无关，包括集合、线性结构、树形结构和图形结构等不同类型各有其独特关系特征",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "二分查找的核心特征是在有序数组中，通过不断将数组分成两部分，每次比较中间元素与目标值，根据比较结果缩小查找范围，直到找到目标值或确定",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据类型的核心特征是定义了一组值以及可施加于这些值的一组操作，不同的数据类型具有不同的取值范围和操作集合，它规定了数据在计算机中表示",
    "head": "数据类型",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "归并排序是一种将数组分成两个子数组分别递归排序后再合并成一个有序数组的稳定的分治算法，其时间复杂度为O(n log n)，空间复杂度",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的值进行比较，直到找到目标值或遍历完整个序列，其核心特征是逐个比较数据元素",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，通过下标来访问和修改元素，数组的长度在创建后通常是固定的，并且在内存中是连续",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序表具有随机访问特性即可以通过下标直接访问元素，存储密度高，逻辑上相邻的元素在物理存储上也相邻，插入和删除操作效率低，需要移动大量",
    "head": "访问",
    "tail": "访问",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "线性结构的核心性质是数据元素之间存在一对一的线性关系，有且仅有一个开始和一个终端元素，除开始和终端元素外，每个元素有且仅有一个前驱和",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解路径并在发现不符合条件时退回上一步继续尝试来求解问题的算法策略，其基础在于按照深度优先策略对问题的解",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "快速排序是对给定数组选择一个基准值，将数组分为两部分，小于基准值的元素放在左边大于基准值的元素放在右边，然后对左右两部分分别递归进行",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "快速排序是对无序数组通过选择一个基准值，将数组分为两部分，小于基准值的放在左边大于基准值的放在右边，然后对左右两部分分别递归进行同样",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据以及指向下一个节点的指针，通过这些指针将节点依次连接起来形成一个链式结构",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征为存在一个对数据元素的有限序列，该序列中的元素之间存在唯一的前驱和后继关系（除了第一个元素无前驱，",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，如果顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序，每一趟比较都会将最大（或最小）的元素“",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法，其特点包括能将复杂问题转化为简单重复",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，若目标元素存在则返回其索引，若不存在则返回",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "冒泡排序是一种比较简单的排序算法，它重复地走访要排序的数列，一次比较两个数据元素，如果顺序错误就把它们交换过来，直到整个数列都被排序",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据使得数据的插入删除和查找操作在平均情况下具有接近常数的时间复杂度",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置来逐步将无序序列转化为有序序列，其核心性质是在排序过程中不断对序列中的元素进行两两比较，若顺序错误就",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两部分，每次根据中间元素与目标值的比较结果，缩小查找区间，直至找到目标值或确定目标值不存在的",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "递归基础是递归定义中的一部分，它明确规定了递归过程中最简单、最基本的情况，是递归能够正常开始并逐步展开的起始点，具有能直接给出结果而",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "指针的核心特征是其存储的是变量的内存地址，通过该地址可以直接访问和操作所指向变量的值，使得程序能够灵活地处理数据的存储位置和间接访问",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "指针是一种变量，其值为内存中另一个变量的地址，通过指针可以间接访问其所指向的变量，具有指向特定内存地址、可用于动态内存管理和函数参数",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "回溯法基础的特点是在问题求解过程中，通过深度优先搜索方式，按照某种规则不断尝试，当发现当前尝试不满足条件或无法达到目标时就退回上一步",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "双向链表是一种数据结构，其每个节点除了包含数据域外，还包含两个指针，分别指向前一个节点和后一个节点，从而形成双向链接关系，便于在两个",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标节点后回溯到前一步再选择其他路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历，不存在链表尾端的概念，能够",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点较近的节点，同一层节点的访问顺序不固定，直到遍历完所有可达节点，其核心特征是基于",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "线性表是一种由零个或多个数据元素组成的有限序列，其中数据元素之间存在一对一的线性关系，即除了第一个和最后一个数据元素外，每个数据元素",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过头节点的指针可以访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，若目标元素存在则返回其索引，若不存在则返回",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，若目标元素存在则返回其索引，若不存在则返回",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回溯法基础的特点的核心特征是在搜索过程中通过深度优先策略逐步构建解空间树，在每一步决策时试探各种可能情况，若当前选择导致无法继续构建",
    "head": "回溯法",
    "tail": "树",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "非线性结构的核心特征是在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，或者说数据元素之间的关系不是一对一的线性关系",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种简单直观的排序算法其特点是比较操作主要在相邻元素间进行每次将一个待排序数据插入",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回溯法基础的核心性质是在问题求解过程中通过深度优先搜索尝试所有可能解，当发现当前部分解无法得到完整有效解时及时回溯到上一步重新选择，",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "深度优先搜索是一种沿着一条路径尽可能深地探索直到无法继续或达到目标后回溯，再选择其他路径重复该过程以遍历或搜索图或树等数据结构的搜索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性结构的特点的核心性质是数据元素之间存在一对一的线性关系，有且仅有一个开始和一个终端元素，除开始和终端元素外，每个元素有且仅有一个",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "双向链表是一种链表数据结构，每个节点除了包含数据域外，还包含两个指针，一个指向前驱节点，另一个指向后继节点，通过这两个指针可以在两个",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，其核心特征是以深度为导向进行搜索，从起始节点开始，沿着一条路径尽可能深地探索，直到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法其特点在于利用前一步或前几步的计算结果",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法，其特点的核心性质是比较相邻元素，如果顺序错误就把它们交换过来，重复此步骤",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "抽象数据类型具有数据对象、数据关系和基本操作这三个核心性质，数据对象是所操作数据的集合，数据关系定义了数据对象间的关系，基本操作是对",
    "head": "抽象数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "线性结构的特点的核心特征是数据元素之间存在着一对一的线性关系，即除了第一个和最后一个数据元素外，每个数据元素都有且仅有一个直接前驱和",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "数据的逻辑结构的核心特征是数据元素之间的逻辑关系，它描述了数据元素之间的相互关系以及数据的组织方式，而不涉及数据在计算机中的存储方式",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到一个特定的索引位置来存储和检索数据，具有常数时间复杂度的插入、删除和查找操作，能够高效",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与目标值进行比较，直到找到目标值或遍历完整个序列，其核心性质为逐个元素顺序比较以",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "43"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，它从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它是一个完全二叉树，并且每个节点的值都大于或等于其子节点的值（最大堆），或者每个节点的值都小于或等于其子节点",
    "head": "完全二叉树",
    "tail": "堆",
    "head_offset": "16",
    "tail_offset": "45"
  },
  {
    "sentence": "交换排序的核心特征是通过比较元素并交换位置，将无序序列逐步转换为有序序列，在排序过程中，相邻元素或不相邻元素不断进行比较和交换操作以",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "树的查找的核心特征是基于树的结构特性，通过特定的遍历方式从根节点开始沿着树枝逐步搜索目标节点，利用节点之间的层次关系和连接信息以提高",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "24"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素以及指向后继节点的指针，通过指针将各个节点依次连接起来，其特点是逻辑上相邻的元素在",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式逐步逼近问题精确解的方法，其核心性质是利用前一步的计算结果来生成下一步的近似解",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "广度优先搜索的核心特征是以起始节点为中心，按照层次依次扩展节点，优先访问距离起始节点较近的节点，直到找到目标节点或遍历完所有可达节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法其核心性质是利用前一步的计算结果来生成",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点近的节点，具有先进先出的队列特性来存储待访问节点，保证以最短路径优先的方式遍历图",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，其余节点分为若干互不相交的子集，每个子集又是一棵树且称为该根节点的子树，具有层次关系、递归",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "50"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据使得数据的插入删除和查找操作在平均情况下具有接近常数的时间复杂度",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "哈希表的核心性质是对于每个键值对，通过哈希函数将键映射到一个特定的索引位置，从而能够在平均情况下以接近常数的时间复杂度进行插入、查找",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中沿着一条路径尽可能深地探索直到无法继续或达到目标后回溯，再选择其他路径继续深度探索的搜索算法，",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将数据元素与给定值进行比较，直到找到匹配元素或遍历完整个序列，其特点包括适用于无序数据序列、平均",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "线性表是一种由同类型数据元素构成的有限序列，其中每个元素有且仅有一个直接前驱和一个直接后继（除第一个元素无前驱，最后一个元素无后继外",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它利用堆的特性将数据逐步调整为有序序列，具有时间复杂度为O(n log n)、空间复杂度为O(",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，若目标元素存在则返回其索引，若不存在则返回",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回溯法基础的特点是在问题求解过程中通过尝试不同的选择路径，当发现当前路径无法达到目标时就回溯到上一步重新选择，以此逐步探索所有可能的",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "线性查找是从数据序列的开头开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列的一种查找方式其特点是比较",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "25"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，如果顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序，且每一趟比较都会将未排序部分的最大（或",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，其核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数组是具有相同数据类型的一组数据元素的有序集合，在内存中连续存储，通过下标可以快速访问元素，其大小通常在创建时确定，元素的插入和删除",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是最后一个节点的指针指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历且遍历可以循环进行",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "存储结构的特点是指数据在计算机内存或存储设备中组织和存储的方式所具有的诸如数据元素间的逻辑关系如何表示、数据元素如何存储等方面的特性",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "深度优先搜索的核心性质是沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，通过递归或栈来实现对图或",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征是数据元素之间存在一对一的线性关系，有且仅有一个开始和一个终端元素，除开始和终端元素外，每个元素都",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程将最大元素逐步“冒泡”到数组末尾，依次对未排序部分进行同样操作，直至整个",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "42"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "双向链表每个节点包含两个指针，一个指向前驱节点，一个指向后继节点，这使得它可以双向遍历，在插入和删除节点时可以更方便地定位到相邻节点",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "单链表的核心特征是每个节点包含数据域和指针域，其中指针域指向下一个节点，通过这种方式将节点依次连接起来形成链表结构，且最后一个节点的",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "穷举法是一种通过对所有可能的情况进行逐一列举和检验，从而找到问题解决方案的方法其特点是在解决问题时会遍历所有可能的情况不遗漏任何一种",
    "head": "穷举法",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "50"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作以使其按特定顺序排列的排序方法，包括直接插入排序、冒泡排序、简单选择排序等，其特点是实现相对",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，它从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "循环链表的核心性质是表中最后一个节点的指针域指向头节点从而形成一个环形结构使得从表中任一节点出发均可通过不断遍历指针到达表中其他节点",
    "head": "循环链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，一个指向后继节点，通过这两个指针可以在两个方向上遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "迭代法的核心特征是通过从一个初始估计值开始，利用迭代公式不断重复计算，逐步逼近问题的精确解，每一次迭代都基于上一次迭代的结果进行更新",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点近的节点，同一层节点的访问顺序不固定，直到遍历完所有可达节点，且每个节点仅被访问",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "回溯法是一种通过尝试所有可能的解空间路径来求解问题的算法策略，在求解过程中一旦发现当前路径无法得到有效解便回溯到上一步重新选择路径，",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "非线性结构的核心特征是其元素之间存在一对多或多对多的关系，不像线性结构那样元素间具有一对一的顺序关系，这种结构中数据元素的排列不再是",
    "head": "非线性结构",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "线性表的核心性质是具有唯一的一个被称为“第一个”的数据元素，有且仅有一个被称为“最后一个”的数据元素，除第一个元素外每个数据元素有且",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "线性结构的核心特征是存在一个数据元素的有序序列，其中每个元素有且仅有一个直接前驱（除第一个元素外）和一个直接后继（除最后一个元素外）",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个将元素与要查找的关键字进行比较，直到找到匹配的元素或者遍历完整个数据序列为止",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问距离起始节点较近的节点，同一层次的节点在访问顺序上相对有序且在访问完当前层次所有",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列的合适位置，通过依次比较和移动元素来完成排序，其特点在于每次处理一个未排序的数据并将其插入",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "操作效率的核心特征是在单位时间内以最少的资源投入获得最大的产出，同时保证操作的准确性和稳定性，能够快速且有效地完成任务并达到预期目标",
    "head": "操作效率",
    "tail": "稳定性",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，若目标元素存在则返回其索引，若不存在则返回",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续探索其他",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问节点，先访问起始节点，再访问其相邻节点，然后依次访问相邻节点的相邻节点等，保证在访问完一层节点后才进入",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点近的节点，通过队列来辅助实现，能保证找到的路径是相对较短且按层次顺序遍历的",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "引用是对变量的别名，其核心性质包括与被引用对象具有相同内存地址，对引用的操作等同于对被引用对象的操作，引用在定义时必须初始化且初始化",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "59",
    "tail_offset": "63"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点没有前驱，除根节点外其余节点被分成若干互不相交的集合，每个集合又是一棵树，这些树称为",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及指向其下一个节点的指针，通过头节点的指针可以访问到整个",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，通过下标来访问和修改元素，内存中存储是连续的，其长度固定，元素在内存中按顺序",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外，还包含两个指针，一个指向前驱节点，另一个指向后继节点，通过这些指针能够在两个",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找特定元素的高效搜索算法，其核心性质为每次比较都能将搜索范围缩小一半，通过不断比较中间元素与目标值的大小",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置来逐步将无序序列转变为有序序列的排序方法其核心性质是在排序过程中通过不断交换逆序对元素使序列最终达到",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作以使其按特定顺序排列的排序方法，包括直接插入排序、冒泡排序、简单选择排序等，其特点是基本思想",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "非线性结构的核心特征是在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即数据元素之间的关系不再是一对一的线性关系，",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "快速排序是对数组进行排序的一种算法，其核心性质是选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分的",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数组是由相同类型的数据元素按一定顺序排列而成的集合，这些数据元素在内存中占用连续的存储单元，可通过下标来唯一标识和访问其中的每个元素",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点最近的节点，在访问完当前层所有节点后再进入下一层，直至找到目标节点或",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "简单排序的核心性质是通过比较元素之间的大小关系，将无序序列逐步转换为有序序列，在排序过程中每次操作都基于相邻元素或特定元素间的比较与",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "双向链表每个节点包含两个指针，一个指向前驱节点，一个指向后继节点，这使得在链表中既可以向前遍历也可以向后遍历，方便在链表中进行插入、",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "快速排序是对无序数组通过选择一个基准值将数组分为两部分，小于基准值的元素放在左边大于基准值的元素放在右边，然后对左右两部分子数组分别",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素的存储方式、数据元素之间的逻辑关系如何在存储中体现、以及对数据的操作如何基于存储结构来实现等方面",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "顺序查找是对线性表中的元素依次进行比较，直到找到目标元素或遍历完整个线性表的查找方法，具有对数据无要求、平均查找长度为线性表长度一半",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法其核心性质包括比较操作从后向前进行依次将待插入元素与已排序序列中的元素比较",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在一对一的线性关系，有且仅有一个开始和一个终端元素，除开始和终端元素外，每个元素都有且仅有一个前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "链表是一种线性数据结构，其特点的核心特征包括用一组任意的存储单元存储线性表的数据元素，这些存储单元可以是连续的也可以是不连续的，每个",
    "head": "链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "快速排序是对无序数组通过选择基准值将数组分为两部分，小于基准值的元素放在左边，大于基准值的元素放在右边，然后对左右两部分分别递归进行",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表的核心特征是每个节点包含数据元素以及一个指向后继节点的指针，通过指针依次连接各个节点形成线性序列，且首节点无前驱，尾节点无后继",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心特征是通过比较元素并交换位置，将无序序列逐步转换为有序序列，在排序过程中，不断比较相邻元素，若顺序错误",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续探索其他路径的搜索策略",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "双向链表是一种线性数据结构，其每个节点除了包含数据域外还包含两个指针，分别指向前一个节点和后一个节点，从而实现节点之间的双向链接关系",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法，其核心性质是利用前一步的计算结果来生成",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "线性查找是从数据序列的一端开始，依次将每个数据元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列的一种查找方法其特点是",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "21"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，一个指向后继节点，通过这两个指针可以在两个方向上遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "堆是一种优先队列数据结构，它通常采用完全二叉树形式存储数据，每个节点的值都大于或等于其子节点的值（最大堆），或者每个节点的值都小于或",
    "head": "队列",
    "tail": "完全二叉树",
    "head_offset": "6",
    "tail_offset": "18"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置从而完成排序的一种简单且稳定的排序算法其时间复杂度在最坏情况下为O(n²)平均和最好",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始，沿着一条路径尽可能深地探索直到无法继续或达到目标条件，然后回溯到前一步继续探索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "顺序查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止，其核心特征是按",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "回溯法基础的特点是在问题求解过程中通过深度优先搜索策略不断尝试各种可能的解路径，当发现当前路径无法得到有效解时就回溯到上一步重新选择",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法其核心特征是每次从待排序的数据中取出一个元素插入到已排序序列的适当位置",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性表是一种具有相同数据类型的有限个数据元素的序列，其中数据元素之间存在一对一的线性关系，有唯一的开始元素和终端元素，且除开始元素外",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它是一个完全二叉树，并且每个节点的值都大于或等于其子节点的值（最大堆），或者每个节点的值都小于或等于其子节点",
    "head": "完全二叉树",
    "tail": "堆",
    "head_offset": "16",
    "tail_offset": "45"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，独立于计算机的存储结构，主要包括集合结构、线性结构、树形结构和图形结构",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "广度优先搜索按照层次依次访问节点，先访问距离起始节点较近的节点，逐层推进，直到遍历完所有可达节点，其核心特征是逐层搜索以确保先访问到",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，根节点没有前驱，除根节点外其余节点被分成若干互不相交的集合，每个集合又是一棵树，这些树称为",
    "head": "根节点",
    "tail": "根节点",
    "head_offset": "17",
    "tail_offset": "21"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外，还包含两个指针，一个指向前驱节点，另一个指向后继节点，通过这些指针可以在两个",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表的核心性质是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，一个指向后继节点，通过这两个指针可以在两个方向上遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "顺序表具有随机访问特性即可以通过下标直接访问元素，其存储元素是连续存储，内存利用率高，插入和删除操作效率低，时间复杂度为O(n)，而",
    "head": "访问",
    "tail": "访问",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "堆排序是一种基于堆数据结构的排序算法，它利用堆的特性将数据逐步调整为有序序列，具有时间复杂度为O(n log n)、空间复杂度为O(",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，通过下标来访问和修改元素，数组的内存空间是连续的，其长度在创建后通常是固定的",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "抽象数据类型是指一个数学模型以及定义在该模型上的一组操作，其特点在于数据的逻辑结构与存储结构分离，通过定义一组抽象的操作来对数据进行",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "线性表的核心特征是具有线性结构，即数据元素之间存在一对一的线性关系，有唯一的开始元素和终端元素，除开始元素外每个元素有且仅有一个直接",
    "head": "线性表",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式逐步逼近问题精确解的方法，其特点包括能将复杂问题转化为简单的重复计算过程，每次迭代都",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外，还包含两个指针，一个指向前驱节点，另一个指向后继节点，通过这些指针可以在两个",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，重复使用相同的计算步骤，逐步逼近问题的精确解的方法，其核心性质包括能通过不断迭代改进近似解、计算",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "56"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将数组分成两部分并比较目标值与中间元素，从而逐步缩小查找范围以确定目标值是否存在及所在位置的查找",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序表的核心特征是其逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过数组下标直接计算出元素的存储地址，从而能够高效地进行随机访问",
    "head": "数组",
    "tail": "访问",
    "head_offset": "36",
    "tail_offset": "64"
  },
  {
    "sentence": "交换排序通过比较和交换元素位置来对序列进行排序，其核心性质是在排序过程中不断比较相邻元素，若顺序错误则进行交换，逐步将无序序列转变为",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，对引用的操作实际上就是对其所引用对象的操作，引用在定义时必须初始化且初始化后不能再引用其他对象，引用",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "46",
    "tail_offset": "50"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种简单且稳定的排序算法其特点是比较操作主要针对未排序数据与已排序序列中的元素依次",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环形结构，遍历链表时可以从任意节点开始沿着节点间的链接依次",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找特定元素的高效算法，其核心性质包括：每次查找都将数组分成两部分，通过比较目标元素与中间元素的大小，决定",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置，将无序序列逐步转换为有序序列，其核心性质是通过元素间的两两比较，若顺序错误则进行交换操作来实现排序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "64"
  },
  {
    "sentence": "指针是一种变量，其值为内存地址，通过指针可以间接访问其所指向的内存位置，从而实现对数据的灵活操作和高效处理，它能够方便地在不同的数据",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "哈希表的核心特征是通过哈希函数将键映射为特定索引，使得数据能以接近常数时间的复杂度进行插入、查找和删除操作，且不同键经过哈希函数映射",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度优先搜索的核心特征是沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，以深度为优先依次访问节点",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "哈希表是一种数据结构，其特点的核心性质包括通过哈希函数将键映射到特定位置以实现快速查找，不同键可能映射到相同位置即产生哈希冲突，并且",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间的逻辑关系，有线性结构如线性表中元素一对一的关系、树形结构中元素一对多的关系、图形结构",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "单链表的核心特征是每个节点包含一个数据元素和一个指向下一个节点的指针，通过指针将各个节点依次连接起来形成一个线性序列，且除了尾节点外",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外，还包含两个指针域，一个指向前驱节点，另一个指向后继节点，通过这些指针使得链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，其核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序表是一种线性表，其特点是逻辑上相邻的元素在物理存储位置上也相邻，它具有随机访问特性，可通过下标直接计算元素存储地址，存储空间连续",
    "head": "线性表",
    "tail": "访问",
    "head_offset": "6",
    "tail_offset": "39"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中，通过深度优先搜索的方式，按照某种规则依次尝试各种可能的解，当发现当前尝试的路径无法得到有效解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性表是一种具有相同数据类型的n个数据元素的有限序列，其中数据元素之间存在一对一的线性关系，且有唯一的开始元素和终端元素，除开始元素",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中通过尝试不同的选择路径，当发现当前路径无法达到目标或不符合条件时，就回溯到上一步重新选择，不断",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "哈希表的核心性质是对于每个键值对，通过哈希函数将键映射到一个特定的索引位置，从而可以在平均情况下以接近常数的时间复杂度进行插入、查找",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "顺序表是一种线性表，其特点包括用一组地址连续的存储单元依次存储线性表中的数据元素，逻辑上相邻的数据元素物理上也相邻，可随机访问元素，",
    "head": "线性表",
    "tail": "线性表",
    "head_offset": "6",
    "tail_offset": "31"
  },
  {
    "sentence": "指针的核心特征是其存储的是内存地址，通过该地址可以访问和操作存储在对应内存位置的数据，且指针变量本身也占用一定内存空间，其值可以改变",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，通过下标来访问和修改元素，数组的内存空间是连续的，其大小在创建时通常是固定的",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "双向链表每个节点包含两个指针，一个指向前驱节点，一个指向后继节点，通过这两个指针可以方便地在链表中双向遍历，且在链表中插入和删除节点",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "双向链表是一种数据结构，其每个节点除了包含数据域外，还包含两个指针，一个指向前驱节点，另一个指向后继节点，通过这些指针能够在两个方向",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置来将无序序列转换为有序序列，其核心性质是在排序过程中不断比较相邻元素大小，若顺序错误则进行交换，直至",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "回溯法基础的特点的核心特征是在搜索过程中通过深度优先策略逐步构建解空间树，每一步都基于当前状态进行决策，若当前决策导致无法得到可行解",
    "head": "回溯法",
    "tail": "树",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "快速排序是对一组数据通过选择一个基准值，将数据分为两部分，小于基准值的放在左边大于基准值的放在右边，然后对左右两部分分别递归进行同样",
    "head": "快速排序",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "60"
  },
  {
    "sentence": "指针的核心特征是其存储的是内存地址，通过该地址可以访问和操作内存中存储的数据，指针变量的值是它所指向对象的内存地址，并且可以进行指针",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "数据的物理结构是数据在计算机内存或存储设备中的存储方式及相关特点，包括数据元素存储的顺序、存储位置与逻辑结构中数据元素间关系的映射等",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "35"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，从起始节点开始，逐层地探索图中的节点，先访问距离起始节点较近的节点，具有按照层次依次访问节点的核心性质",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续探索其他",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，对引用的操作实际上就是对其所引用对象的操作，引用必须在定义时初始化且一旦初始化便不能再引用其他对象，",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "46",
    "tail_offset": "52"
  },
  {
    "sentence": "线性表的核心特征是具有零个或多个数据元素，这些数据元素之间存在一对一的线性关系，即除第一个元素外每个元素有且仅有一个直接前驱，除最后",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在一对一的线性关系，有且仅有一个开始和一个终端元素，除开始和终端元素外，每个元素都有且仅有一个前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "冒泡排序是一种比较简单的排序算法，它重复地走访要排序的数列，一次比较两个数据元素，如果顺序错误就把它们交换过来，直到整个数列都被排序",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "线性查找是一种逐一比较数据元素与目标值的查找算法，其特点是从数据序列的起始位置开始，依次检查每个元素，直到找到目标值或遍历完整个序列",
    "head": "查找",
    "tail": "数据元素",
    "head_offset": "2",
    "tail_offset": "11"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其每个节点包含数据元素以及一个指向后继节点的指针，通过头节点指针来标识链表，且最后一个节点的指针指向空",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "哈希表是一种数据结构，其特点的核心性质是通过哈希函数将键映射到特定位置以实现快速查找，能在平均情况下以接近常数的时间复杂度进行插入、",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "线性结构的特点是数据元素之间存在一对一的线性关系，有且仅有一个开始和一个终端元素，除开始和终端元素外，每个元素有且仅有一个前驱和一个",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，它从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据的逻辑结构的核心性质是数据元素之间的逻辑关系，它描述了数据元素之间的相互关联方式，而不依赖于数据在计算机中的存储方式和具体的实现",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，其核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中通过深度优先搜索的方式，按照某种策略依次尝试各种可能的解，当发现当前尝试的路径无法得到有效解时",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "快速排序是对包含n个记录的序列进行排序，通过一趟排序将序列分为两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始顶点开始，按照层次依次访问顶点，先访问距离起始顶点近的顶点，直至遍历完所有可达顶点，其核心性质是",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，通过下标来访问和定位元素，数组的大小在创建时通常是固定的，并且数组在内存中是",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的节点的核心特征是具有一个数据元素以及指向其子节点的若干分支，根节点没有前驱节点，其余节点有且仅有一个前驱节点，每个节点可以有零个",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "快速排序是对一组数据通过选择一个基准值，将数据分为两部分，小于基准值的放在左边大于基准值的放在右边，然后对左右两部分分别递归进行同样",
    "head": "快速排序",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "60"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置来逐步将无序序列转变为有序序列，其核心性质是在排序过程中不断对相邻元素进行比较，若顺序错误则进行交换",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，它从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序表的特点的核心性质包括逻辑上相邻的元素物理存储位置也相邻，可随机访问元素，存储密度高，插入和删除操作效率低，需要预先分配连续内存",
    "head": "访问",
    "tail": "插入",
    "head_offset": "34",
    "tail_offset": "45"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半，每次比较中间元素与目标值来缩小查找范围，直到找到目标值或确定目标值不存在，其核心特征是",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "迭代法的核心特征是通过从一个初始估计值开始，利用固定的迭代公式不断重复计算，逐步逼近问题的精确解，每次迭代都基于上一次迭代的结果进行",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "双向链表是一种数据结构，其每个节点除了包含数据域外还包含两个指针域，分别指向前驱节点和后继节点，通过这些节点的链接构成双向的链表结构",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "回溯法基础的定义的核心性质是在问题求解过程中通过深度优先搜索策略，不断尝试各种可能的解路径，当发现当前路径无法得到有效解或已无法继续",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始，沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "回溯法基础的特点的核心性质是在问题求解过程中通过深度优先搜索方式逐步构建解空间树，在搜索过程中根据问题的约束条件和目标条件对当前路径",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找特定元素的高效算法，其核心性质为每次比较都能将查找区间缩小一半，通过不断重复该过程，直到找到目标元素或",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，其核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，具有快速查找、插入和删除操作的特点，在平均情况下时间复杂度为",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "堆是一种特殊的数据结构，它是一个完全二叉树，并且每个节点的值都大于或等于其子节点的值（最大堆），或者每个节点的值都小于或等于其子节点",
    "head": "完全二叉树",
    "tail": "堆",
    "head_offset": "16",
    "tail_offset": "45"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，对引用的操作实际上就是对其所引用对象的操作，引用必须在定义时初始化且一旦初始化后其引用关系不能再改变",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "46",
    "tail_offset": "52"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，顶点间的关系集合描述了顶点之间的连接关系，这些关系可以是有",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "存储结构的特点是指数据在计算机内存或存储设备中组织和存放的方式所具有的诸如数据元素间逻辑关系的表示方法、数据元素的存储方式及数据元素",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，通过队列来辅助实现，以确保每个节点在其相邻节点被访问之前不会被",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种排序算法其核心特征是通过依次将每个元素与已排序部分进行比较并找到合适位置插入以",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表的每个节点除了有数据域外，还有两个指针域，一个指向前驱节点，一个指向后继节点，从而使得双向链表既可以向前遍历也可以向后遍历，",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中，通过深度优先搜索的方式，按照某种规则逐步尝试每一种可能的解路径，当发现当前路径无法得到有效解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "二分查找的核心特征是在有序数组中，通过不断将区间缩小一半，每次比较中间元素与目标值，根据比较结果确定目标值可能存在的区间，持续此过程",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "回溯法基础的特点的核心特征是在搜索过程中通过深度优先搜索策略，按照一定规则依次尝试各种可能的解路径，当发现当前路径无法得到有效解或已",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "快速排序是对包含n个记录的序列进行排序，通过一趟排序将序列分成两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "数组具有固定大小，元素类型相同，元素在内存中按顺序存储，可通过下标访问特定元素，支持随机访问，在存储和处理大量同类型数据时效率较高但",
    "head": "数组",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "引用是一种给已存在对象起别名的机制，其特点包括与所引用对象绑定紧密、必须初始化且初始化后不能再引用其他对象，通过引用操作实际上是对所",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "36",
    "tail_offset": "40"
  },
  {
    "sentence": "快速排序的核心特征是选择一个基准元素，通过一趟排序将数组分为两部分，使得基准元素左边的元素都小于等于它，右边的元素都大于等于它，然后",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，使得数据的插入、查找和删除操作在平均情况下具有接近常数的时间",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "广度优先搜索的核心特征是以层次为顺序依次访问节点，先访问距离起始节点较近的节点，在访问当前层所有节点后再进入下一层访问，直至找到目标",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "快速排序是对一组数据通过选择一个基准值，将数据分为两部分，小于基准值的放在左边大于的放在右边，然后对左右两部分分别递归进行同样操作以",
    "head": "快速排序",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "57"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，若目标元素存在则返回其索引，若不存在则返回",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回路是数据结构中从一个顶点出发，沿着边经过一系列顶点后又回到起始顶点的路径，其核心特征是存在一条封闭路径且路径上顶点和边构成一个循环",
    "head": "回路",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "树的节点的核心特征是具有一个数据元素以及零个或多个指向子节点的指针，每个节点是树结构中的基本组成单元，通过这些指针与其他节点建立父子",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，若目标元素存在则返回其索引，若不存在则返回",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中，通过深度优先搜索的方式，从初始状态出发，按照某种规则依次尝试每一种可能的情况，当发现当前选择",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "顺序查找是对线性表中的元素依次进行比较，直到找到目标元素或遍历完整个线性表，其时间复杂度在最坏情况下为O(n)，平均情况下也为O(n",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半，利用中间元素与目标值的比较结果，不断缩小查找范围，直到找到目标值或",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回溯法基础的定义的核心性质是在问题求解过程中通过深度优先搜索策略，按照某种规则逐步构建解空间树，在搜索过程中对不符合条件的情况进行剪",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "回溯法基础的特点的核心特征是在搜索解空间时，通过深度优先搜索策略，按照某种规则依次尝试各种可能的选择，当发现当前选择无法得到有效解时",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问图中节点，先访问起始节点，再访问其邻接节点，然后按照层次依次访问后续节点，直到访问完所有节点或达到目标",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "链表的核心性质是通过节点之间的指针链接来顺序存储数据元素，每个节点包含数据和指向下一个节点的指针，数据元素在内存中不要求连续存储，可",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "回溯法基础的核心性质是在问题求解过程中通过深度优先搜索方式系统地尝试所有可能解，当发现当前部分解无法达到目标或不满足约束条件时则回溯",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "抽象数据类型具有数据抽象和数据封装的特点，其核心性质包括有定义明确的逻辑结构、定义了该结构上的一组基本操作、数据表示和操作实现的分离",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "哈希表是一种数据结构，其核心特征是通过哈希函数将键映射到特定位置，以实现快速的数据插入、查找和删除操作，平均情况下时间复杂度为O(1",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "数据类型的特点的核心特征是具有特定的数据表示形式、取值范围、操作集合以及语义含义，不同数据类型在这些方面存在差异以适应不同的应用需求",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "非线性结构的核心特征是其数据元素之间存在一对多或多对多的关系，各元素不再保持顺序关系，不能像线性结构那样依次访问，而是呈现出较为复杂",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，其核心特征是以深度为导向进行搜索，从起始节点开始，沿着一条路径尽可能深地探索，直到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找特定元素的高效算法，其核心性质包括：每次比较都能将搜索范围缩小一半，通过不断比较中间元素与目标值来确定",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法基础的核心特征是在搜索过程中，当遇到当前选择无法满足问题条件或无法达到目标时，会退回上一步重新选择，通过深度优先搜索的方式遍历",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "55"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中沿着一条路径尽可能深地探索直到无法继续或达到目标后回溯，再选择其他路径重复该过程以遍历所有节点",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "回溯法基础的特点的核心特征是在搜索过程中通过深度优先策略，按照某种规则依次尝试各种可能的解，当发现当前路径无法得到有效解或已无法继续",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，其核心特征是以起始节点为中心，按照层次依次扩展节点，先访问距离起始节点较近的节点，在访问较远节点之前先",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，它从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "快速排序是对一组数据通过选择一个基准值，将数据分为两部分，小于基准值的放在左边大于的放在右边，然后对左右两部分分别递归进行同样操作以",
    "head": "快速排序",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "57"
  },
  {
    "sentence": "快速排序是对数组进行排序的算法，其核心性质是选择一个基准元素，将数组分为两部分，小于基准的元素放在左边，大于基准的元素放在右边，然后",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "插入排序是一种将未排序数据插入到已排序序列的合适位置的排序算法其特点在于比较相邻元素如果顺序错误就把它们交换过来并将每一个数据插入到",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，从起始节点开始，按照层次依次访问节点，先访问距离起始节点较近的节点，直到找到目标节点或遍历完所有节点，",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，通过引用可以使用该对象，对引用的操作等同于对其所引用对象的操作，引用在定义时必须初始化且初始化后不能",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "56",
    "tail_offset": "60"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将数据元素与给定关键字进行比较，直到找到匹配元素或遍历完整个序列，其优点是算法简单对数据无要求，",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "线性表是具有相同数据类型的n个数据元素的有限序列，有且仅有一个开始结点没有直接前驱，有且仅有一个终端结点没有直接后继，其余每个结点有",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的值进行比较，直到找到匹配的元素或遍历完整个序列，其核心特征是逐个比较数据",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "邻接表是一种用于表示图的数据结构，它通过为图中的每个顶点建立一个链表，链表中存储与该顶点相邻接的顶点信息，具有节省存储空间、便于查找",
    "head": "邻接表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置以实现快速数据访问，具有插入、删除和查找平均时间复杂度为常数（理想情况下）、能",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "广度优先搜索是一种图遍历算法，从起始节点开始，逐层访问节点，先访问距离起始节点近的节点，直到遍历完所有可达节点，其核心特征是按照层次",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "二分查找的核心性质是在一个有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，若数组中存在目标元素则返回其索引，若不存在",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "引用是给已存在对象起的一个别名，对引用的操作实际上就是对其所引用对象的操作，引用在定义时必须初始化且一旦初始化便不能再引用其他对象，",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "46",
    "tail_offset": "52"
  },
  {
    "sentence": "线性表的特点的核心特征是数据元素之间存在一对一的线性关系，即除第一个元素外每个元素有且仅有一个直接前驱，除最后一个元素外每个元素有且",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始，沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问节点，先访问距离起始节点近的节点，通过队列来辅助实现，保证每个节点只被访问一次，直到遍历完所有可达节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "非线性结构是指在该结构中至少存在一个数据元素，它具有两个或两个以上的前驱或后继，即数据元素之间的关系不再是一对一的线性关系的数据结构",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，直至找到目标值或确定目标值不存在的一种高效查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性表的核心特征是具有有限个数据元素，且数据元素之间存在一对一的线性关系，即除第一个元素外每个元素有且仅有一个直接前驱，除最后一个元素",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标条件后回溯到前一步继续探索其他路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "简单排序是对数据元素进行比较和交换操作以实现排序，其核心特征是算法逻辑相对直接，通常基于相邻元素的比较和位置交换来逐步将无序序列转变为",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步，继续探索其他未访问的",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "双向链表每个节点包含两个指针，一个指向前一个节点，另一个指向后一个节点，通过这两个指针可以方便地在链表中双向遍历，既能从前往后访问节点",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是表尾节点的指针域指向表头节点，从而形成一个环形结构，使得从链表中的任意一个节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "快速排序是对给定数组进行排序的一种算法，其核心特征是选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "快速排序是对给定数组进行排序的一种算法，其核心特征是选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "引用是一种给已存在变量起别名的机制，其特点包括必须初始化且初始化后不能再引用其他变量，通过引用访问变量本质上就是访问被引用的变量本身，",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "25",
    "tail_offset": "29"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止，其特点的核心性质",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据其核心特征是能在平均情况下以接近常数的时间复杂度进行插入删除和查找",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "快速排序是对数组进行排序的一种算法，其核心性质是通过选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "循环链表的核心特征是其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中各个节点可以依次遍历，不存在常规链表中尾节点指针域为空",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置来存储数据，具有快速查找、插入和删除的特点，能在平均情况下以接近常数的时间复杂度完成这些操作，并且",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "数据的物理结构的特点的核心性质包括数据元素在计算机中的存储方式有顺序存储、链式存储等，顺序存储是将数据元素依次存放在连续的存储单元中，",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，从而高效确定目标值是否存在及所在位置的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性查找是一种从数据序列的开头开始，依次逐个比较元素，直到找到目标元素或遍历完整个序列的查找方法其特点是对数据序列无特定要求且查找过程",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "顺序查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止，其核心特征是逐个",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "顺序查找是对线性表中的元素依次进行比较，直到找到目标元素或遍历完整个线性表，其特点包括时间复杂度在最坏情况下为O(n)，平均情况下为O",
    "head": "顺序查找",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在一对一的线性关系，有且仅有一个开始和一个终端节点，除开始节点外每个节点有且仅有一个前驱，除终端节点",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二分查找是在有序数组中，通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，直到找到目标值或确定目标值不存在，具有每次比较可",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的逻辑结构的定义的核心特征是数据元素之间的逻辑关系，它描述了数据元素之间的关联方式而不涉及数据在计算机中的存储方式，仅关注数据元素",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "16"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征为数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步并探索其他路径，其核心性质是优先访问深度大的节点，通过",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个前驱元素，除",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作以逐步将数据按特定顺序排列的排序方法，其特点是实现相对简单、基本思想易于理解但通常效率不如一些",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示，它描述了数据在存储器中的存储方式，如",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征为数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "简单排序是对一组数据按特定规则进行排列，其核心特征是通过比较和交换数据元素的位置，将无序的数据序列逐步转换为有序序列，在排序过程中基于",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "比较排序是基于元素之间的比较操作来确定元素的相对次序从而实现排序，其核心性质是决策树模型中叶子节点表示最终排序结果，内部节点为元素间的",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是最后一个节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任何一个节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "树的查找是在树形结构中基于节点间层次关系与连接特性，通过特定规则从根节点或指定起始节点出发，沿着分支路径遍历节点以确定目标元素是否存在",
    "head": "查找",
    "tail": "根节点",
    "head_offset": "2",
    "tail_offset": "33"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过下标来访问和修改元素，内存中存储紧凑且连续，在数据量较大时可方便地批量处理",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "交换排序的核心特征是通过比较元素并交换位置，将无序序列逐步转换为有序序列，其特点包括在排序过程中相邻元素不断比较大小，若顺序错误则进行",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在着一对一的线性关系，即除了第一个和最后一个数据元素外，每个数据元素都有且仅有一个直接前驱和一个直接",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半，每次比较中间元素与目标值，根据比较结果缩小查找区间，直到找到目标值或确定目标值不存在，其",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "抽象数据类型的定义核心特征是由数据对象、数据对象上的关系集合以及对数据对象的基本操作集合所构成且仅通过这些基本操作来访问和处理数据对象",
    "head": "抽象数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是链表中最后一个节点的指针域指向头节点，从而形成一个环形结构，使得从链表中的任何一个节点出发都可以遍历",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性表的核心特征是具有有限个数据元素，这些元素之间存在一对一的线性关系，即除第一个元素外每个元素有且仅有一个直接前驱，除最后一个元素外",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步，继续探索其他未访问的",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "循环链表的核心特征是其尾节点的指针域指向头节点，使得链表形成一个环，从而遍历链表时可以从任意节点出发沿着环依次访问各个节点直至回到起始",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心特征是描述数据元素之间的逻辑关系，它独立于数据的存储结构，关注数据元素之间的关联方式，如线性结构体现数据元素",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "18"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数组转变为有序数组的排序方法其特点在于相邻或不相邻元素间的两两比较并适时交换以逐步实现",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是尾节点的指针指向头节点，从而形成一个环形结构，使得链表可以循环遍历，不存在常规链表中尾节点指针为空的",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "递归基础是递归定义中的初始情况，明确规定了最简单或最基本的实例，是递归定义得以开始和后续递归展开的基础，具有明确的初始值或条件作为递归",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，再逐渐访问距离更远节点，通过队列来辅助实现，能保证找到从起始节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "双向链表是一种链表数据结构，每个节点除了包含数据域外，还有两个指针域，一个指向前驱节点，一个指向后继节点，通过这些指针可以在两个方向上",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据其核心特征是能在平均情况下以接近常数的时间复杂度进行插入删除和查找",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半并根据目标值与中间元素的比较结果来缩小查找区间，直到找到目标值或确定目标值不存在的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据类型是对数据的一种分类，它定义了数据的取值范围、存储方式以及可以进行的操作，不同的数据类型具有不同的特性和用途，通过明确数据类型能",
    "head": "数据类型",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "深度优先搜索是一种用于遍历或搜索图或树的算法策略，从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标节点，然后回溯到前一步",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "交换排序的核心特征是通过比较元素并交换位置，将无序序列逐步调整为有序序列，在排序过程中相邻元素或不相邻元素之间不断进行比较和交换操作以",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "递归基础是递归定义中针对最简单情况直接给出定义或值的部分，其核心性质是为递归过程提供初始条件，使得递归能够从这一基础情况开始逐步展开，",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示，可分为顺序存储结构、链式存储结构、索引存储结构和散",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "快速排序的核心特征是选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分的元素都大于等于基准元素，然后对",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，一个指向后继节点，通过这两个指针实现节点之间的双向链接",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心特征是描述数据元素之间的逻辑关系，它独立于数据的存储结构，关注数据元素之间的关联方式以及数据的组织形式，包括",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "18"
  },
  {
    "sentence": "链表的核心特征是通过节点来存储数据，每个节点除了包含数据域外还包含一个指向下一个节点的指针，从而形成一个链式结构，使得数据的存储和访问",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "哈希表的核心特征是通过哈希函数将键映射为特定索引，使得数据能以接近常数时间的复杂度进行插入、查找和删除操作，并且不同键经过哈希函数映射",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与目标值进行比较，直到找到目标值或遍历完整个序列，其核心性质是逐一比较数据元素直到",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "43"
  },
  {
    "sentence": "快速排序是对无序数组进行排序的高效算法，其核心性质是通过一趟排序将数组分为两部分，使得左边部分元素都小于等于右边部分元素，然后对左右两",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "快速排序是对无序数组通过选择基准元素将数组划分为两部分，小于基准的放在左边大于基准的放在右边，然后对两部分分别递归排序以达到整体有序，",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过指针将各个节点依次连接起来，",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "双向链表的核心特征是每个节点除了包含数据域外还包含两个指针域，一个指向前驱节点，一个指向后继节点，通过这两个指针实现节点之间的双向链接",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "抽象数据类型是一个数学模型以及定义在该模型上的一组操作，其特点包括数据的逻辑结构独立于具体的存储结构、操作的定义与实现分离以及通过封装",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "递归基础是递归定义中最简单最基本的情况，它为递归过程提供了初始条件，使得递归在满足该特定条件时直接给出明确结果而无需进一步递归调用，是",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "顺序表是一种线性表，其核心性质包括用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理存储位置上也相邻，",
    "head": "线性表",
    "tail": "线性表",
    "head_offset": "6",
    "tail_offset": "33"
  },
  {
    "sentence": "算法效率的特点是指算法在执行过程中所表现出的时间复杂度和空间复杂度等方面的特性，包括算法执行时间随输入规模的增长趋势以及算法运行所需的",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "22",
    "tail_offset": "28"
  },
  {
    "sentence": "操作效率的核心特征是在特定时间内以最少的资源投入和最优的流程执行来达成最大量且高质量的任务完成，同时确保整个操作过程具备高度的稳定性、",
    "head": "操作效率",
    "tail": "稳定性",
    "head_offset": "0",
    "tail_offset": "63"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征为数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，直至找到目标值或确定目标值不存在的一种高效查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它独立于数据的存储结构，描述数据元素之间抽象的相互关系，具有反映数据元素间内在联系的核心性质",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "递归基础是递归定义中最简单、最基本的情况，它直接给出问题的解而无需进一步递归调用，是递归定义的起点和终止条件，确保递归过程能够最终结束",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在需要时交换位置，重复此过程直到整个数组有序的排序算法，其核心特征是通过多次比较和交换将较大元素逐步“",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "算法效率的特点是指算法执行所需要的时间和空间资源随问题规模增长而变化的特性包括时间复杂度和空间复杂度来衡量其在时间和空间方面的效率表现",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "39",
    "tail_offset": "45"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在着一对一的线性关系，即除了第一个元素和最后一个元素外，每个元素都有且仅有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索是按照层次依次访问节点，先访问距离起始节点近的节点，直至遍历完所有可达节点，其特点包括按照层次遍历、先进先出的队列结构辅助",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其每个节点包含一个数据元素和一个指向下一个节点的指针，通过指针依次连接各个节点形成链表结构，且只有一个头",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度优先搜索的核心性质是按照深度优先的方式系统地访问图或树等数据结构中的节点，从起始节点开始，优先沿着一条路径尽可能深地探索，直到无法",
    "head": "深度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征是数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性表的核心特征是具有有限个数据元素，且数据元素之间存在一对一的线性关系，即除第一个元素外每个元素有且仅有一个直接前驱，除最后一个元素",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是不是这个集合的元素就确定了，互异性即集合中的元素互不相同，无序性即集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，直至找到目标值或确定目标值不存在的高效查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "双向链表的核心特征包括每个节点除了有数据域外还有两个指针域，一个指向前驱节点，一个指向后继节点，通过这些指针可以方便地在两个方向上遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "链表是一种线性数据结构，其特点包括每个节点包含数据和指向下一个节点的指针，数据元素的逻辑顺序通过指针链接来表示，无需在内存中连续存储，",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半，每次比较中间元素与目标值，根据比较结果缩小查找区间，直至找到目标值或确定目标值不存在，其",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标条件，然后回溯到前一步继续探索其他",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "非线性结构的核心特征是其中的数据元素之间存在着一对多或多对多的关系，不像线性结构那样具有唯一的前驱和后继，其节点之间的连接方式更为复杂",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "简单排序的核心特征是通过比较元素之间的大小关系，逐步将无序序列转化为有序序列，排序过程中通常基于相邻元素的比较和交换操作来实现排序目的",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步，继续探索其他未访问的",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，直至找到目标值或确定目标值不存在的一种高效查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "双向链表是一种链表数据结构，每个节点除了包含数据域外还包含两个指针分别指向前一个节点和后一个节点，从而支持双向遍历，在插入和删除节点时",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "指针的核心特征是其值为内存中一个地址，通过该地址能够直接访问和操作存储在对应内存位置的数据，可用于间接访问、传递数据地址、动态内存管理",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "二分查找的核心特征是在有序数组中，通过每次将查找区间缩小一半的方式，快速定位目标元素，每次比较中间元素与目标元素的大小关系，若中间元素",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与给定值进行比较，直到找到匹配元素或遍历完整个序列，其时间复杂度在最坏情况下为O(n",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "交换排序是一种通过比较和交换元素位置来逐步将无序数组转变为有序数组的排序方法其特点是在排序过程中不断比较相邻元素若顺序错误就把它们交换",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "线性查找是一种从数据序列的开头开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列的查找方法其特点是对数据序列无特定要求且查找过程",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，再访问距离起始节点较远的节点，通过队列来辅助实现，以确保每个节点",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式重复计算，逐步逼近问题精确解的方法其特点在于利用前一步的计算结果来推导下一步的",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过指针将各个节点依次连接起来形成",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "简单排序是对数据元素进行比较和交换等操作以确定其顺序，其核心特征包括操作相对直接简便，主要基于元素间的比较来逐步调整顺序，通过多次比较",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "图是由顶点集合及顶点间的关系集合组成的数据结构，顶点集合中的元素称为顶点，顶点间的关系集合描述了顶点之间的连接情况，这些连接关系可以是",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "14"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是最后一个节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任何一个节点出发都可以遍历整个链表",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "快速排序是对无序数组进行排序的高效算法，通过选择基准元素将数组分为两部分，小于基准的元素在前大于基准的元素在后，递归地对两部分进行排序",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "父节点是其每个子节点在数据结构层次关系中的直接前驱节点，具有比子节点更高的层级地位且与子节点存在特定的关联关系以构成整体的数据结构形态",
    "head": "父节点",
    "tail": "子节点",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心特征是描述数据元素之间的逻辑关系，它独立于数据的存储方式，关注数据元素之间的关联方式以及数据的组织形式，包括",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "18"
  },
  {
    "sentence": "深度优先搜索的核心特征是沿着一条路径尽可能深地探索，直到无法继续或达到目标状态，然后回溯到前一步，继续探索其他未访问的分支，以遍历整个",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "快速排序的核心特征是选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分的元素都大于等于基准元素，然后对",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "双向链表是一种链表数据结构，每个节点除了包含数据域外，还包含两个指针，一个指向前驱节点，一个指向后继节点，通过这两个指针可以在两个方向",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二分查找是在一个有序数组中，通过不断将区间分成两部分并比较中间元素与目标值，根据比较结果缩小查找区间，直到找到目标值或确定目标值不存在",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "深度优先搜索的核心特征是沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，优先选择新的未访问过的分支",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "线性查找是一种在数据序列中从起始位置开始依次逐个检查元素，直到找到目标元素或遍历完整个序列的查找方法其特点是对数据序列无特定要求且查找",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它包括数据元素的表示和关系的表示，其核心性质在于能高效地实现数据的存储、访问、插入",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的物理结构的特点的核心性质是数据元素在计算机存储器中的存储方式，包括顺序存储、链式存储、索引存储和散列存储等，它直接影响数据的存储",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "16"
  },
  {
    "sentence": "哈希表具有通过哈希函数将键映射到特定位置以实现快速数据存储与检索、平均情况下查找插入删除操作时间复杂度为O(1) 、可能存在哈希冲突需",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据类型的核心特征是它规定了数据的取值范围以及可以对该数据执行的操作集合，不同的数据类型其取值范围和操作集合各不相同，以此来确保数据在",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "树的核心特征是它是一种非线性的数据结构，有且仅有一个根节点，其余节点被分为若干互不相交的有限集合，每个集合又是一棵树，具有层次关系，除",
    "head": "根节点",
    "tail": "集合",
    "head_offset": "26",
    "tail_offset": "46"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标条件后回溯并继续探索其他路径的搜索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据元素，其中每个元素在内存中按顺序存储且通过下标来唯一标识",
    "head": "数组",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在着一对一的线性关系，即除了第一个元素和最后一个元素外，每个元素都有且仅有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域指向头节点，使得整个链表形成一个环形结构，从而实现从链表中的任意节点出发都可以遍历到链表中的",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算机资源量，包括时间资源和空间资源，通常用时间复杂度和空间复杂度来衡量其在时间和空间方面随问题规模增长的",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "36",
    "tail_offset": "42"
  },
  {
    "sentence": "顺序表是一种线性表，它的核心性质包括用一组地址连续的存储单元依次存储线性表的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻，并且",
    "head": "线性表",
    "tail": "线性表",
    "head_offset": "6",
    "tail_offset": "34"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，若未找到目标则回溯到前一步，继续探索其他",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是不是这个集合的元素就确定了，互异性即集合中的元素互不相同，无序性即集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "回溯法基础的定义的核心特征是在问题求解过程中，通过深度优先搜索的方式，按照某种规则依次尝试各种可能的解路径，当发现当前路径无法得到有效",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "二分查找针对有序数组，通过每次将查找区间缩小一半来快速定位目标元素，其核心性质是每次比较后能排除一半的元素，从而高效地找到目标值或确定",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征为数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "简单排序的核心特征是通过比较和交换元素的位置，逐步将无序序列转化为有序序列，每次操作通常只涉及相邻元素的交换或移动，排序过程相对直观和",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "58"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括顺序存储结构、链式存储结构等不同形式，用于组织和存储数据以便于计算机处理和操作",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是一种比较排序算法，它重复地走访要排序的数列，一次比较两个数据元素，如果顺序错误就把它们交换过来，直到整个数列都被排序，其核心",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "回溯法基础的特点的核心特征是在问题求解过程中通过深度优先搜索的方式，按照某种规则依次尝试每一种可能的解路径，当发现当前路径无法得到有效",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，其余节点被分成若干互不相交的有限集合，每个集合又是一棵树，具有层次关系且除根节点外每个节点有",
    "head": "根节点",
    "tail": "集合",
    "head_offset": "17",
    "tail_offset": "37"
  },
  {
    "sentence": "顺序表是一种线性表，它的核心性质包括用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理存储位置上也相邻",
    "head": "线性表",
    "tail": "线性表",
    "head_offset": "6",
    "tail_offset": "34"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源的量度它反映了算法在处理特定问题时的性能表现包括时间复杂度和空间复杂度分别衡量算法执行时间和",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "45",
    "tail_offset": "51"
  },
  {
    "sentence": "线性结构的特点是数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个前驱，除终端元素",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含一个数据元素和一个指向后继节点的指针，通过指针将各个节点依次连接起来，其特点包括节点间逻辑上",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是不是这个集合的元素就确定了，互异性即集合中的元素互不相同，无序性即集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问距离起始节点较近的节点，再访问距离起始节点较远的节点，同一层次的节点按某种顺序逐个",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置，将无序序列逐步转化为有序序列的排序方法，其核心性质是在排序过程中不断比较元素大小并交换位置以实现有序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将数组分成两部分并根据目标值与中间元素的比较结果来缩小查找范围从而确定目标值是否存在及所在位置的查找",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "抽象数据类型是一个数学模型及定义在该模型上的一组操作，其特点包括数据的逻辑结构独立于存储结构、通过定义一组抽象运算来描述数据的操作行为",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "广度优先搜索的核心特征是按照层次依次访问节点，先访问距离起始节点较近的节点，再访问距离起始节点较远的节点，通过队列来辅助实现，确保同一",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "顺序表是一种线性表，其核心性质包括用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻，并且",
    "head": "线性表",
    "tail": "线性表",
    "head_offset": "6",
    "tail_offset": "33"
  },
  {
    "sentence": "线性表的核心特征是具有有限个数据元素，数据元素之间存在一对一的线性关系，即除第一个元素外每个元素有且仅有一个直接前驱，除最后一个元素外",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素以及指向后继节点的指针，通过头节点开始依次访问各个节点形成线性序列，且除尾节点外每个",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度优先搜索按照深度优先的方式系统地访问图或树的节点，尽可能深地探索一条路径直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，",
    "head": "深度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "快速排序是对给定数组通过选择一个基准元素，将数组分为两部分，小于基准的元素在前大于基准的元素在后，然后对这两部分子数组分别递归进行相同",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "广度优先搜索的核心性质是按照层次依次访问节点，先访问的节点层次在前，后访问的节点层次在后，同一层次的节点按某种顺序依次访问，直到遍历完",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示，其重点在于描述数据在物理存储上的存储",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标条件后回溯并继续探索其他路径的搜索",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "归并排序是一种分治算法，将数组分成两个子数组分别递归排序后再合并成一个有序数组，具有时间复杂度稳定为O(n log n)、空间复杂度为",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素以及指向后继节点的指针，通过头节点可以依次访问链表中的各个节点，且除尾节点外每个节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定的存储位置使得插入、查找和删除操作平均具有接近常数的时间复杂度哈希表的核心性质是能够在",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "双向链表是一种数据结构，其中每个节点除了包含数据域外，还包含两个指针，分别指向前一个节点和后一个节点，通过这些指针可以在两个方向上遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，具有先深入探索一条路径到底再回溯的特点",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "回溯法基础的特点的核心性质是在问题求解过程中通过深度优先搜索策略，按照某种规则依次尝试各种可能的解，当发现当前尝试的部分解无法导致完整",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "回溯法基础是一种通过尝试所有可能解，按照深度优先策略搜索问题解空间，当发现当前路径无法得到有效解时回溯到上一步，继续尝试其他路径，直至",
    "head": "回溯法",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "双向链表是一种数据结构，其中每个节点除了包含数据外还包含两个指针，一个指向前一个节点，另一个指向后一个节点，通过这些指针形成双向链接的",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "抽象数据类型的定义具有数据对象、数据关系以及基本操作这几个核心性质 ，其中数据对象是所操作数据的集合 ，数据关系定义了数据对象间的关系",
    "head": "抽象数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "交换排序是一种基于元素比较和交换操作来对数据序列进行排序的算法，其核心性质是通过不断比较相邻元素并在顺序错误时进行交换，逐步将数据序列",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "非线性结构的核心特征是在数据元素之间存在一对多或多对多的关系，不像线性结构那样数据元素之间呈现一对一的线性关系，其元素的排列没有固定的",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "双向链表是一种数据结构，其中每个节点除了包含数据域外还包含两个指针域，分别指向前一个节点和后一个节点，通过这些指针可以在两个方向上遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找特定元素的高效搜索算法，通过将数组中间元素与目标元素比较，根据比较结果在数组的前半部分或后半部分继续进行",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法，其核心性质是通过不断迭代更新近似解使其",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "线性结构的核心性质是数据元素之间存在着一对一的线性关系，即除了第一个和最后一个数据元素外，其他数据元素都有且仅有一个直接前驱和一个直接",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，通过下标来访问和修改元素，数组的长度固定，内存中存储连续，可高效地进行随机访问",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "集合是由确定的、互不相同的元素所组成的整体，其中元素具有确定性、互异性和无序性，确定性指给定一个集合，任何一个对象是不是这个集合的元素",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "48"
  },
  {
    "sentence": "快速排序是对一组数据通过选择一个基准值将数据分为两部分，小于基准值的放在左边大于基准值的放在右边，然后对左右两部分分别递归进行同样操作",
    "head": "快速排序",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "59"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过这些指针将各个节点依次连接起来",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性查找是一种在数据序列中从起始位置开始依次逐个检查元素，直到找到目标元素或遍历完整个序列的查找方法其特点是对数据序列无特定要求且查找",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "线性查找是一种在数据序列中从起始位置开始依次逐个检查元素，直到找到目标元素或遍历完整个序列的查找方法，其核心特征是按顺序依次对每个元素",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据使得数据的插入、查找和删除操作在平均情况下具有接近常数的时间复杂度",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "快速排序的核心特征是选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分的元素都大于等于基准元素，然后对",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外，还包含两个指针域，一个指向前驱节点，一个指向后继节点，通过这些指针实现节点之间",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "哈希表具有通过哈希函数将键映射到特定位置以实现快速数据存储与检索、平均情况下查找插入删除操作时间复杂度为O(1) 、可能存在哈希冲突需",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构的特点的核心性质是它描述了数据在计算机内存或存储设备中的实际存储方式包括存储位置存储顺序以及数据元素之间的物理连接关系等",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "53"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针域不指向NULL，而是指向链表的头节点，从而形成一个环形结构，使得从链表中的任意一个节点出发，",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "交换排序通过比较和交换元素位置来逐步将无序序列变为有序序列，其核心性质是在排序过程中不断对相邻元素进行比较，若顺序错误则进行交换，从而",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "数组是一种有序数据集合，其核心特征包括具有固定大小，元素类型相同，通过下标唯一标识元素，内存中存储连续，可高效随机访问元素，能方便地按",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，其特点包括数据元素的存储方式（如顺序存储、链式存储等）、元素间关系的表示方法以及对",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，重复应用某种迭代公式来逐步逼近问题精确解的方法，其核心性质是利用迭代公式不断更新估计值以逐渐接近",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "单链表的核心性质是每个节点包含一个数据元素以及一个指向后继节点的指针，通过指针将各个节点依次连接形成线性序列，且除了尾节点外每个节点都",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性表是一种具有线性结构的数据结构，其核心特征包括有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个直接前驱，除终端",
    "head": "线性表",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "指针的核心特征是其存储的是内存地址，通过该地址能够直接访问和操作内存中的数据，并且指针变量本身也有其对应的内存地址用于存储所指向的目标",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是不是这个集合的元素就确定了，互异性即集合中的元素互不相同，无序性即集合中的元素没有顺序之分",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素和指向下一节点的指针，通过指针依次连接各个节点，形成线性结构，具有插入和删除操作灵活",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "递归基础的核心特征是存在无需进一步递归调用就能直接得出结果的最简情况，这些最简情况构成递归过程的终止条件，使得递归算法不会陷入无限循环",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个前驱元素，除",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征为数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，并且除开始元素外每个元素有且",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "插入排序的核心特征是将未排序数据插入到已排序序列的合适位置，通过逐步将无序数组中的元素插入到有序部分的正确位置来完成排序，每次插入一个",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "交换排序通过比较元素并交换位置来逐步将无序序列转变为有序序列其核心性质是在排序过程中不断比较相邻元素若顺序错误则进行交换以实现整体有序",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式逐步逼近问题精确解的方法，其特点包括能将复杂问题转化为简单重复计算，通过不断迭代使结果",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性结构的特点是数据元素之间存在一对一的线性关系，有且仅有一个开始和一个终端元素，除开始和终端元素外每个元素有且仅有一个前驱和一个后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "非线性结构的核心特征是各数据元素之间的逻辑关系并非线性关系，存在一对多、多对多等复杂关系，不像线性结构那样呈现出一对一的依次排列关系，",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "非线性结构的核心特征是其数据元素之间存在着一对多或多对多的关系，不像线性结构那样数据元素之间呈现一对一的线性关系，在非线性结构中，数据",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序表是一种线性表，其核心性质包括用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理存储位置上也相邻，",
    "head": "线性表",
    "tail": "线性表",
    "head_offset": "6",
    "tail_offset": "33"
  },
  {
    "sentence": "指针是一种变量，其值为内存地址，通过指针可以间接访问和修改该地址所存储的数据，具有灵活高效地操作内存、可作为函数参数实现数据传递和共享",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其每个节点包含数据元素和一个指向后继节点的指针，通过头节点开始依次访问各个节点，具有插入和删除操作效率高",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列为止其核心特征是逐个元素",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "快速排序是对给定数组进行排序的一种算法，其核心性质是选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，若未找到目标则回溯到前一步，继续探索其他",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "快速排序的核心特征是选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分的元素都大于等于基准元素，然后对",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "数据的物理结构是数据元素及其关系在计算机存储器内的表示，它包括数据元素的表示和关系的表示，具有存储方式、存储位置关系等特点以体现数据在",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "深度优先搜索是从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，若未找到目标则回溯到前一步，继续探索其他路径，直至",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性查找是从数据序列的开头开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列，其核心特征是按顺序依次比较每个元素来确定目标元素的",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "34"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间的逻辑关系，有集合、线性结构、树形结构、图形结构等，不同逻辑结构具有不同特点，如线性结构",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，如果顺序错误就把它们交换过来，对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟排序",
    "head": "冒泡排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "65"
  },
  {
    "sentence": "线性查找是一种在数据序列中逐个元素进行比较，直到找到目标元素或遍历完整个序列的查找方法，其特点包括时间复杂度在最坏情况下为O(n)，对",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "31"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历且没有明确的终点，从链表中的任意",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "存储结构的核心性质是它不仅要存储数据元素本身，还要存储数据元素之间的关系并且能够通过该结构高效地实现对数据的各种操作如插入删除查找等以",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式逐步逼近问题精确解的方法，其核心性质是通过不断重复相同的计算步骤，使结果逐渐收敛到所需",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是尾节点的指针指向头节点，从而形成一个环形结构，使得链表可以循环遍历，不存在明确的链表末尾，从任何节点",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将数组中间元素与目标值比较，根据比较结果缩小查找范围，从而高效确定目标值是否存在及所在位置的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "快速排序是对给定数组进行排序的一种算法，其核心特征是通过选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素顺序的排序算法，其核心特征是通过比较元素大小来逐步构建有序序列，在排序过程中主要依赖元素间的比较",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，如果顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序，每一趟排序都会将未排序数据中最大（或最小",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "线性结构是一种数据结构，其核心特征为数据元素之间存在一对一的线性关系，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "线性结构的核心特征是数据元素之间存在着一对一的线性关系，即除了第一个和最后一个数据元素外，每个数据元素都有且仅有一个直接前驱和一个直接",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "引用是对其他对象的间接访问，其核心性质包括具有与所引用对象相同的类型，通过引用来操作实际对象，引用一旦初始化便不能再引用其他对象，引用",
    "head": "访问",
    "tail": "初始化",
    "head_offset": "11",
    "tail_offset": "51"
  },
  {
    "sentence": "深度优先搜索按照深度优先的方式系统地访问图或树的节点，尽可能深地探索一条路径直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，",
    "head": "深度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的排序算法其核心性质是比较相邻元素如果顺序错误就把它们交换过来并且将一个数据插入到已经",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "集合是由具有某种特定性质的具体的或抽象的对象汇总而成的集体，其特点包括具有确定性即给定一个集合，任何一个对象是否属于这个集合是明确的，",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "递归基础是递归定义中的一部分，它明确给出递归所依赖的初始值或基本情况，是递归过程能够开始并逐步展开的起始点，具有定义递归运算起始状态或",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "引用是给已存在的对象起一个别名，通过引用可以使用该对象，对引用的操作实际上就是对其所引用对象的操作，引用在定义时必须初始化且一旦初始化",
    "head": "初始化",
    "tail": "初始化",
    "head_offset": "58",
    "tail_offset": "64"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点近的节点，直到遍历完所有节点或找到目标节点的搜索算法，其特点包括以起始节点为",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "集合是由确定的、互不相同的元素所组成的整体其中元素具有确定性即给定一个集合，任何一个对象是不是这个集合的元素是确定的且具有互异性即集合",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "交换排序通过比较和交换元素位置来逐步将无序序列变为有序序列 其核心性质是在排序过程中不断交换逆序对元素以达到最终有序状态 比较相邻元素",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，如果顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序，每一趟比较都会将未排序数据中最大（或最小",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "广度优先搜索是一种图搜索算法，从起始节点开始，按照层次依次扩展节点，先访问距离起始节点较近的节点，直至找到目标节点或遍历完所有可达节点",
    "head": "广度优先搜索",
    "tail": "图",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "广度优先搜索的核心特征是以起始节点为中心，按照层次依次扩展节点，先访问距离起始节点较近的节点，直到找到目标节点或遍历完所有节点，它通过",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置从而完成排序的一种简单直观的排序算法其特点是比较操作主要针对未排序数据与已排序序列中的",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素之间的相对次序从而对元素序列进行排序的排序方法其核心特征是通过两两比较元素大小来逐步构建有序序列",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及一个指向下一个节点的指针，通过头节点的指针来访问整个链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "快速排序是对一组数据通过选择一个基准值将数据分为两部分，小于基准值的放在左边大于基准值的放在右边，然后对左右两部分分别递归进行同样操作",
    "head": "快速排序",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "59"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置来存储和检索数据，具有常数时间复杂度的插入、删除和查找操作，能高效处理大规模数据",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "交换排序的核心特征是通过比较元素并交换位置，逐步将无序序列转变为有序序列，其特点在于在排序过程中主要依据元素之间的大小关系，不断地进行",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "快速排序是对给定数组进行排序的算法，其核心性质是选择一个基准元素，将数组分为两部分，使得左边部分元素都小于等于基准元素，右边部分元素都",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "快速排序是一种基于分治思想，通过选择一个基准元素将数组划分为两部分，小于基准的元素在前大于基准的元素在后，然后对两部分分别递归进行排序",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "线性查找是从数据序列的第一个元素开始，依次将每个元素与要查找的关键字进行比较，直到找到匹配的元素或遍历完整个序列，其时间复杂度为O(n",
    "head": "查找",
    "tail": "查找",
    "head_offset": "2",
    "tail_offset": "28"
  },
  {
    "sentence": "简单排序的核心特征是通过比较元素之间的大小关系，按照一定的规则逐步将无序序列转化为有序序列，通常是两两比较并交换元素位置来实现排序，其",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "63"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点较近的节点，直至遍历完所有节点的搜索算法，其特点包括借助队列存储待访问节点，",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "深度优先搜索是一种在图或树等数据结构中沿着一条路径尽可能深地探索直到无法继续或达到目标条件，然后回溯到前一步继续探索其他路径的搜索算法",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其每个节点除了包含数据域外还包含两个指针，一个指向前驱节点，另一个指向后继节点，从而支持从两个方向遍历链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "集合的核心性质包括确定性、互异性、无序性，确定性指集合中的元素必须是确定的，互异性指集合中的元素互不相同，无序性指集合中的元素没有顺序",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "深度优先搜索的核心性质是从起始节点开始，沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步，继续探索其他路径，直到遍历完",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "单链表的核心性质是每个节点包含一个数据元素和一个指向下一个节点的指针，通过这些指针依次连接各个节点形成线性序列，且除了最后一个节点外每个",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "哈希表是一种数据结构，它通过哈希函数将键映射到特定位置以实现快速数据访问，具有平均情况下常数时间的查找、插入和删除操作，不过可能存在哈希",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "快速排序是对给定数组通过选择一个基准元素，将数组分为两部分，小于基准的元素放在左边大于基准的元素放在右边，然后对左右两部分子数组分别递归",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器内的表示，它包括数据元素的表示和关系的表示，其中数据元素的表示即数据元素在计算机中的存储方式，",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "深度优先搜索是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步，继续探索其他路径，重复此过程直到",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用某种迭代公式不断重复计算以逐步逼近问题精确解的方法其特点包括能从一个初始值开始逐步迭代接近目标值",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "数据的逻辑结构是指数据元素之间的逻辑关系，它描述了数据元素之间的关联方式而不涉及数据在计算机中的存储方式，其核心特征在于体现数据元素之间",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "9"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素的相对次序从而实现排序，其核心性质为排序过程仅通过元素间的比较操作来决定元素在有序序列中的最终位置",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法，其特点包括能利用已有的计算结果进行下一步",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素的相对顺序从而进行排序的算法，其核心特征是通过比较元素大小来逐步构建有序序列，在排序过程中主要依靠",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "数组的核心特征是具有相同数据类型的一组数据元素，这些元素在内存中按顺序存储且占用连续的存储空间，通过数组名和下标可以唯一地标识和访问数组",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻，其核心性质包括具有随机访问特性可",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其核心特征为有且仅有一个开始和一个终端节点，并且除了开始和终端节点外，每个节点都",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式逐步逼近问题精确解的方法其特点包括能将复杂问题转化为简单重复计算、可通过有限步骤得到近似",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "集合是由确定的、互不相同的对象所组成的整体这些对象称为集合的元素集合具有确定性、互异性和无序性确定性指对于一个给定的集合任何一个对象是否",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "双向链表是一种数据结构，其中每个节点除了包含数据域外，还有两个指针域，一个指向前驱节点，另一个指向后继节点，通过这些指针使得链表中的节点",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "非线性结构的核心特征是其数据元素之间存在一对多或多对多的关系，不像线性结构那样数据元素之间呈现一对一的线性关系，非线性结构中元素的排列不",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "双向链表是一种数据结构，其中每个节点除了包含数据域外还包含两个指针，一个指向前驱节点，另一个指向后继节点，通过这些节点和指针形成双向链接",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素以及指向后继节点的指针，通过指针将各个节点依次连接起来形成一个线性序列，其中除了尾节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法其核心性质是利用前一步的计算结果来生成下一步",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示，它决定了数据在计算机中的存储方式和访问",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过这些节点的指针依次连接形成链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来，形成一个链式结构，其",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "顺序表是一种线性表，其核心性质包括用一组地址连续的存储单元依次存储数据元素，数据元素在内存中按逻辑顺序依次存放，并且可以通过数组下标直接",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "6",
    "tail_offset": "33"
  },
  {
    "sentence": "单链表是一种线性数据结构，其每个节点包含一个数据元素和一个指向下一个节点的指针，通过这些指针将各个节点依次连接起来形成链表，且只有一个头",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "简单排序是对给定元素序列按照特定规则进行比较和交换等操作以使其呈现出特定顺序的排序方式其核心特征是通过逐次比较元素并根据比较结果进行相应",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列为止，其核心特征是按顺序依次对每个元素进行比较查找",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示，其中数据元素的表示包含数据元素值的表示",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "哈希表具有通过哈希函数将键映射到特定位置以实现快速数据访问的特点，其核心性质包括能在平均情况下以接近常数的时间复杂度进行插入、查找和删除",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是最后一个节点的指针指向头节点，从而形成一个环形结构，使得链表可以循环遍历，不存在尾节点，从链表中的任意",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "交换排序通过比较元素并交换不满足顺序要求的元素位置来逐步将数组或序列调整为有序状态其核心性质是相邻元素间的比较与交换操作使得较大元素不断",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据其核心特征包括能在平均情况下以接近常数的时间复杂度进行插入删除和查找",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "递归基础是递归函数中最简单的情况，通常是函数直接返回一个已知值而不再进行递归调用，其核心性质是为递归函数提供了一个终止条件，使得递归调用",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "广度优先搜索的核心特征是以起始节点为中心，按照层次依次扩展节点，优先访问距离起始节点较近的节点，直至找到目标节点或遍历完所有节点，它通过",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "算法效率的特点是指算法在执行过程中所表现出的与时间和空间相关的特性，包括时间复杂度反映算法执行时间随输入规模增长的变化趋势以及空间复杂度",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "36",
    "tail_offset": "63"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间分成两半并根据目标值与中间元素的比较结果来缩小查找区间从而高效查找目标值的算法其特点在于查找过程",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据在计算机内存或存储设备中的实际存储方式，包括数据元素的存储位置以及它们之间的存储关系，它与数据的",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "42"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其每个节点包含一个数据元素和一个指向后继节点的指针，通过指针依次连接各个节点，具有逻辑上相邻但物理存储位置",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个将元素与要查找的关键字进行比较，直到找到匹配的元素或者遍历完整个数据序列仍未找到",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "循环链表是一种链表，其尾节点的指针指向头节点，从而形成一个环形结构，使得从链表中的任何一个节点开始，都可以通过依次遍历后继节点而遍历整个",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据域外，还包含两个指针分别指向前一个节点和后一个节点，通过这些指针可以在两个方向上遍历",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "简单排序的核心特征是通过比较元素之间的大小关系，将无序序列逐步转换为有序序列，其排序过程相对直观和基础，通常基于相邻元素的比较与交换操作",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "双向链表是一种数据结构，其中每个节点除了包含数据域外还包含两个指针，分别指向前一个节点和后一个节点，通过这些指针可以在两个方向上遍历链表",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "哈希表是一种数据结构，其核心特征包括通过哈希函数将键映射到特定位置以实现快速数据访问，能在平均情况下以接近常数的时间复杂度进行插入、删除",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过这些指针将各个节点依次连接起来",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "快速排序的核心特征是选择一个基准元素，将数组分为两部分，小于基准的元素放在左边，大于基准的元素放在右边，然后对左右两部分分别递归进行同样",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "线性表的核心特征是存在唯一的一个被称作“第一个”的数据元素，存在唯一的一个被称作“最后一个”的数据元素，除第一个元素外，集合中的每个数据",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "线性查找是一种在数据序列中从起始位置开始依次逐个比较元素，直到找到目标元素或遍历完整个序列的查找方法其特点是比较次数与数据规模相关且平均",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步，继续探索其他路径，重复",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步，继续探索其他路径，重复",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "递归基础是递归定义中针对最简单情况直接给出定义而不依赖递归步骤的部分，其核心性质是为递归定义提供初始值或最简形式的规定，使得递归过程能够",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻，从而可以通过数组下标直接访问元素",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个将元素与要查找的关键字进行比较，直到找到匹配的元素或者遍历完整个序列都未找到匹配",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "单链表的核心特征是每个节点包含一个数据元素和一个指向下一个节点的指针，通过这些指针将各个节点依次连接起来形成线性序列，且除了最后一个节点",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步，继续探索其他路径，不断",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "递归基础是递归定义中的一部分，它明确规定了递归过程中最简单、最基本的情况，是递归能够正确开始和终止的关键，通过定义初始条件或边界情况使得",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将节点依次连接起来形成链表结构，其核心特征是",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "线性表是一种数据元素之间存在一对一线性关系的有限序列，具有有且仅有一个开始元素和一个终端元素且除开始元素外每个元素有且仅有一个直接前驱、",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "递归基础是递归算法中最简单的情况，通常是不需要再次递归调用就能直接得到结果的终止条件，其核心性质是为递归提供了明确的结束点，确保递归不会",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，其特点包括数据元素的存储方式（如顺序存储、链式存储等）、数据元素间关系的表示方法以及",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并将较大元素逐步“冒泡”到数组末尾，重复此过程直到整个数组有序的排序算法，其特点包括比较次数随元素数量增加",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "时间复杂度是衡量算法执行时间随输入规模增长而变化的函数，它反映了算法执行时间的增长趋势，不同算法的时间复杂度不同，且时间复杂度低的算法在",
    "head": "时间复杂度",
    "tail": "时间复杂度",
    "head_offset": "0",
    "tail_offset": "49"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式逐步逼近问题精确解的方法其特点包括能将复杂问题转化为简单重复的计算过程，计算过程相对直观",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "比较排序是通过元素之间的比较来确定元素的相对次序从而实现排序的一种排序算法，其核心性质包括对于n个元素进行排序至少需要O(nlogn)次",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "树的定义的核心特征是它是一种非线性的数据结构，有且仅有一个根节点，其余节点被分为若干互不相交的有限集合，每个集合又是一棵树，这些集合称为",
    "head": "根节点",
    "tail": "集合",
    "head_offset": "29",
    "tail_offset": "49"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间具有特定的逻辑关系，这种关系决定了数据的组织方式和操作方法，并且不同的逻辑结构适用于不同的",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数据序列转变为有序序列的排序方法其特点在于相邻元素或不相邻元素之间的比较与交换操作以实现",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "快速排序是对给定数组进行排序的一种算法，其核心特征是选择一个基准元素，通过一趟排序将数组分为两部分，使得左边部分元素都小于等于基准元素，",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "算法效率的特点是指算法在执行过程中所表现出的时间复杂度和空间复杂度等方面的特性，时间复杂度反映算法执行时间随输入规模增长的变化趋势，空间",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "22",
    "tail_offset": "28"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过这些节点的指针依次连接形成一个",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "简单排序是一种较为基础的排序算法，其核心特征包括操作相对简单易于理解与实现，通常基于比较和交换元素的方式逐步将无序序列转变为有序序列，在",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "链表是一种线性数据结构，其特点包括每个节点包含数据和指向下一个节点的指针，数据元素的逻辑顺序通过指针链接来表示，插入和删除操作相对高效，",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "非线性结构中数据元素之间存在着一对多或多对多的非线性关系，其逻辑特征是每个数据元素可能有多个直接前驱或直接后继，不像线性结构那样数据元素",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "抽象数据类型的定义具有数据对象、数据关系以及基本操作这三个核心性质 ，数据对象是所操作的数据的集合，数据关系是数据对象中各数据元素之间的",
    "head": "抽象数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "47"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，若未找到目标则回溯到上一个节点继续探索其他",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "递归基础具有明确的最简情况或终止条件，在该条件下递归函数无需再次调用自身即可直接给出结果，这是递归基础区别于递归步骤的核心特征，递归步骤",
    "head": "递归基础",
    "tail": "递归基础",
    "head_offset": "0",
    "tail_offset": "47"
  },
  {
    "sentence": "算法效率的特点是指算法在执行过程中所表现出的时间复杂度和空间复杂度等方面的特性，时间复杂度反映算法执行时间随问题规模增长的变化趋势，空间",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "22",
    "tail_offset": "28"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小，如果顺序错误就把它们交换过来，重复此步骤直到整个数组都被排序好的排序算法，其核心特征是通过多次比较和交换",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "快速排序是一种基于分治思想，通过选择一个基准元素将数组分为两部分，小于基准的放在左边大于基准的放在右边，然后对左右两部分分别递归进行排序",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置以实现快速的数据查找插入和删除操作其中哈希函数能将任意长度的输入数据转换为固定长度的",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其特点的核心特征为每个节点包含一个数据元素和一个指向后继节点的指针，通过指针依次连接各个节点形成链表结构，",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "插入排序是将未排序数据插入到已排序序列的合适位置的一种简单且稳定的排序算法其特点在于比较次数和移动次数与初始数据排列顺序有关在最坏情况下",
    "head": "插入排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素之间的相对顺序从而对元素序列进行排序的一种排序方法其核心性质是排序过程中仅通过元素之间的比较来决定",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "线性结构具有在数据元素的非空有限集中存在唯一的一个被称为“第一个”的数据元素、存在唯一的一个被称为“最后一个”的数据元素且除第一个元素外",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "链表是一种通过指针将多个节点连接起来的数据结构，每个节点包含数据和指向下一个节点的指针，其中头节点指向链表的第一个节点，尾节点的指针为空",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "回溯法基础的核心特征是在解决问题的过程中，按照深度优先搜索的策略，通过尝试各种可能的步骤来逐步构建解决方案，当发现当前步骤无法得到有效解",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机内存中的存储方式决定了数据的访问效率、空间利用率以及对数据进行各种操作的难易程度等多方面特性",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机内存或存储设备中的存储方式，它包括数据元素的存储表示及其逻辑关系的表示，其核心特征是描述数据在实际存储介质",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "32"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作以使其按特定顺序排列的一种排序方式，包括直接插入排序、冒泡排序、简单选择排序等多种具体方法，每种",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "回溯法基础的核心特征是在问题求解过程中，通过深度优先搜索方式，按照某种规则逐步构建候选解，当发现当前部分候选解无法满足问题约束或不能得到",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "操作效率的核心特征是在一定时间内以最少的资源消耗完成最多且高质量的操作任务，同时保证操作流程的顺畅性和稳定性，能够快速响应并适应各种变化",
    "head": "操作效率",
    "tail": "稳定性",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "数组是由相同类型的数据元素组成的有限序列，这些元素在内存中按顺序存储，通过下标可以唯一地访问每个元素，数组具有固定的大小，一旦定义其大小",
    "head": "数组",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "简单排序是对数据序列进行比较和交换等操作，通过逐步将较小（或较大）元素移动到合适位置以实现有序排列，具有操作相对简单直接、时间复杂度通常",
    "head": "简单排序",
    "tail": "时间复杂度",
    "head_offset": "0",
    "tail_offset": "61"
  },
  {
    "sentence": "线性查找是一种在数据序列中从起始位置开始依次逐个检查元素，直到找到目标元素或遍历完整个序列的查找方法其核心性质是按顺序逐一比较元素来确定",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "哈希表的核心特征是通过哈希函数将键映射到特定位置以实现快速的数据存储和检索，能在平均情况下以接近常数的时间复杂度进行插入、删除和查找操作",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步，继续探索其他路径，优先扩展新发现的节点，直到遍历完所有",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找特定元素的高效搜索算法，它通过不断将数组分成两部分并根据中间元素与目标元素的比较结果来缩小搜索范围直至找到",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问距离起始节点近的节点，在访问同一层节点时按照一定顺序逐个访问，直到遍历完所有可达节点的搜索",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "快速排序是对无序数组通过选择基准元素将数组分为两部分，小于基准的放在左边大于基准的放在右边，然后对左右两部分子数组分别递归进行同样操作以",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "回溯法是一种通过系统地尝试所有可能解，按照深度优先搜索策略，在搜索过程中不断回溯以避免无效搜索路径，从而找到问题所有解或最优解的数据结构",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "顺序表的核心性质是其逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过数组下标直接访问元素，具有随机访问特性，存储空间连续，插入和删除",
    "head": "数组",
    "tail": "访问",
    "head_offset": "36",
    "tail_offset": "42"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，其中第一个节点称为头节点，最后一个",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "算法效率的特点是指算法在执行过程中所表现出的时间复杂度和空间复杂度等方面的特性，包括算法执行时间随输入规模增长的变化情况以及算法运行所需",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "22",
    "tail_offset": "28"
  },
  {
    "sentence": "链表的核心特征是通过节点之间的指针链接来存储数据元素，每个节点包含数据部分和指向下一个节点的指针，从而形成一种逻辑上的链式结构，使得数据",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及一个指向下一个节点的指针，通过指针将各个节点依次连接起来，",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "抽象数据类型具有数据抽象和数据封装的核心特征，数据抽象通过定义数据的逻辑结构及相关操作，屏蔽了数据的具体表示和实现细节，数据封装则将数据",
    "head": "抽象数据类型",
    "tail": "逻辑结构",
    "head_offset": "0",
    "tail_offset": "34"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器内的表示，它包括数据元素的表示和关系的表示，其中数据元素的表示涉及如何存储数据元素本身，关系的",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过这些指针将各个节点依次连接起来",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "交换排序是指通过比较和交换元素位置来对数据序列进行排序，其核心特征是在排序过程中不断比较序列中元素的大小关系，并根据比较结果交换元素位置",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "简单排序是对数据序列通过比较元素大小并进行位置交换等操作逐步将其排列成有序序列的排序方法，具有实现简单直观但平均时间复杂度相对较高等特点",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表，链表的节点在",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储方式，其特点的核心性质包括数据元素的存储表示以及数据元素之间关系的表示，它决定了数据在内存或存储设备",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "31"
  },
  {
    "sentence": "交换排序是一种排序算法，其核心性质是通过比较元素并交换位置，逐步将无序序列转换为有序序列，在排序过程中相邻元素之间不断进行比较和交换操作",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括顺序存储结构、链式存储结构、索引存储结构和散列存储结构等，它决定了数据在内存中的",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "在数据结构中稳定性是指在排序过程中，相等元素的相对顺序保持不变，即如果两个元素相等，排序前第一个元素在第二个元素之前，排序后第一个元素仍",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "顺序表的核心特征是其逻辑上相邻的元素在物理存储位置上也相邻，并且可以通过数组下标直接计算出元素的存储地址，具有随机访问特性，存储空间连续",
    "head": "数组",
    "tail": "访问",
    "head_offset": "36",
    "tail_offset": "57"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次逐个比较元素，直到找到目标元素或遍历完整个序列，其特点为逐个元素依次比较查找效率较低但算法简单适",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "数据的物理结构的特点的核心性质是其描述数据元素之间的存储关系，包括顺序存储、链式存储等，体现数据在计算机内存或存储设备中的实际存储方式及",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "19"
  },
  {
    "sentence": "快速排序的核心特征是通过选择一个基准元素，将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分的元素都大于等于基准元素，然后",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "数组是一种有序的数据集合，其中的元素具有相同的数据类型，并且可以通过下标来访问和修改特定位置的元素，其内存空间是连续存储的，这使得数组在",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性结构的核心性质是数据元素之间存在一对一的线性关系，即除第一个元素外每个元素有且仅有一个前驱，除最后一个元素外每个元素有且仅有一个后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性结构具有数据元素之间存在一对一的线性关系即有且仅有一个开始和一个终端元素且除开始和终端元素外每个元素有且仅有一个前驱和一个后继的特点",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值出发，按照一定的迭代公式不断重复计算，逐步逼近问题精确解的方法其特点在于利用前一步的计算结果来生成下一步",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步，继续探索其他路径，重复此",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并将较大元素逐步交换到右侧位置，重复此过程直至整个数组有序的排序算法，其核心性质是通过多次比较和交换将无序",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "广度优先搜索是一种按照层次依次访问节点，先访问起始节点，再依次访问其相邻节点，接着访问这些相邻节点的相邻节点等，直到遍历完所有节点或找到",
    "head": "广度优先搜索",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据域外，还有两个指针分别指向前一个节点和后一个节点，通过这些指针可在两个方向上遍历链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算机资源量，包括时间资源和空间资源，其完整定义涵盖算法在不同输入规模下的时间复杂度和空间复杂度等多方面因素",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "51",
    "tail_offset": "57"
  },
  {
    "sentence": "顺序表的特点的核心特征包括：逻辑上相邻的数据元素在物理存储位置上也相邻，可通过数组下标直接计算元素存储地址，支持随机访问，插入和删除操作",
    "head": "数据元素",
    "tail": "数组",
    "head_offset": "20",
    "tail_offset": "39"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括顺序存储结构、链式存储结构、索引存储结构和散列存储结构等不同形式，它决定了数据在",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素及其关系在计算机存储器内的表示，包括数据元素的表示和关系的表示，它决定了数据在计算机中的存储方式和访问",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "回溯法基础的特点是在问题求解过程中通过深度优先搜索不断尝试各种可能路径，当发现当前路径无法达到目标时就回溯到上一步重新选择路径以寻找问题",
    "head": "回溯法",
    "tail": "深度优先搜索",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "堆排序是一种基于堆这种数据结构进行排序的算法，它利用堆的特性将数据逐步调整为有序序列，具有时间复杂度为O(n log n)、空间复杂度为",
    "head": "堆排序",
    "tail": "堆",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性查找是从数据序列的起始位置开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列，其特点是比较次数与数据规模相关，平均时间复杂度为",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "数据的物理结构是数据元素及其关系在计算机存储器内的表示，它包括数据元素的表示和关系的表示，其特点在于具体描述了数据在计算机中的存储方式，",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "简单排序是对数据元素序列按特定规则进行排列，其核心性质包括将无序序列逐步转变为有序序列、基于比较和交换等操作来调整元素位置以实现排序目的",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算机资源量，包括时间资源和空间资源，其完整定义涵盖了算法在解决特定问题时的时间复杂度和空间复杂度等方面综合",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "52",
    "tail_offset": "58"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心特征包括：由一系列节点组成，每个节点包含数据和指向下一个节点的指针（或引用），通过指针依次连接各个节点从而",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "树的节点是包含数据元素以及指向其子节点的若干指针的基本数据结构单元，它是树型结构中的基本组成部分，每个节点通过这些指针与其他节点建立联系",
    "head": "树的节点",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式逐步逼近问题精确解的方法其核心性质包括通过不断重复相同的计算步骤来逐步改进近似解且收敛性",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素及其关系在计算机存储器内的表示，具体包括数据元素的表示和关系的表示，它决定了数据在计算机中的存储方式和",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "深度优先搜索按照深度优先的原则，从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步继续探索其他路径",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "顺序查找是从数据序列的一端开始，依次将每个数据元素与给定关键字进行比较，直到找到匹配元素或遍历完整个序列的一种查找方法其特点是算法简单但",
    "head": "顺序查找",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "线性表是一种具有相同数据类型的n个数据元素的有限序列，其中数据元素之间存在着一对一的线性关系，除第一个和最后一个数据元素外，每个数据元素",
    "head": "线性表",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数组转变为有序数组的排序方法其特点在于基于元素间的比较结果进行位置交换操作以达到排序目的",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "哈希表的核心特征是通过哈希函数将键映射到特定位置，使得数据的存储和检索能够在平均情况下达到接近常数时间的复杂度，并且不同的键经过哈希函数",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "简单排序通过比较元素间大小关系并逐步交换位置来实现排序，每一趟排序会将一个元素放置到其最终位置，具有操作简单、易于理解但时间复杂度较高的",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表，其核心特征是",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "深度优先搜索的核心特征是从起始节点开始，沿着一条路径尽可能深地探索，直到无法继续或达到目标节点，然后回溯到前一步，继续探索其他路径，重复",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "深度优先搜索的核心特征是沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步，再选择另一条路径重复上述过程，优先访问深度大",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "数组是一种有序数据集合，其核心特征包括具有固定大小，元素类型相同，通过下标访问元素，内存中存储连续，元素可通过下标进行修改替换，能方便地",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "交换排序的核心特征是通过比较元素大小并交换位置，将无序序列逐步转变为有序序列，在排序过程中相邻元素或不相邻元素之间不断进行比较和交换操作",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及指向其下一个节点的指针，通过这些指针将所有节点依次连接起来",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机中的存储表示及其关系，包括数据元素的表示和关系的表示，其核心性质是反映数据在计算机内的存储方式及相互连接",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "交换排序是通过比较和交换元素位置来将无序数组转变为有序数组的排序方法其核心性质是在排序过程中通过不断比较元素大小并交换位置使数组逐渐有序",
    "head": "交换排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素和指向下一节点的指针，通过指针依次连接各个节点，具有逻辑上相邻但物理存储位置不一定相邻",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "线性查找是一种从数据序列的开头开始，依次逐个比较元素，直到找到目标元素或遍历完整个序列的查找方法其特点是算法简单但平均查找时间较长适用于",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "36"
  },
  {
    "sentence": "快速排序是对给定数组进行排序的一种算法，其核心特征是选择一个基准元素，将数组分为两部分，使得左边部分元素都小于等于基准元素，右边部分元素",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据类型的核心性质包括其取值范围以及定义在这些取值上的一组操作，这些操作规定了对数据的合法处理方式，不同的数据类型通过其独特的取值范围和",
    "head": "数据类型",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "53"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并将较大元素逐步“冒泡”到数组末尾的排序算法，它重复地走访要排序的数列，一次比较两个数据元素，如果顺序错误",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "递归基础是递归定义中的一种初始情况，它为递归过程提供了一个明确的、无需进一步递归即可确定的终止条件或起始点，使得递归算法能够在满足该基础",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它具体包括顺序存储、链式存储、索引存储和散列存储等方式，不同的存储结构具有不同的特点",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "二分查找是在有序数组中通过不断将区间分成两半并根据目标值与中间元素的比较结果来缩小查找区间直至找到目标元素或确定目标元素不存在的查找算法",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "链表的核心性质是通过节点之间的指针连接来存储数据元素，每个节点包含数据部分和指向下一个节点的指针，从而形成一个链式结构，数据的存储顺序不",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "二分查找的核心特征是在有序数组中通过不断将区间缩小一半来确定目标元素的位置，每次比较中间元素与目标元素，若中间元素等于目标元素则查找成功",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "在数据结构中，稳定性是指在排序算法执行过程中，相等元素之间的相对顺序在排序前后保持不变，即如果两个元素相等，排序前第一个元素在第二个元素",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "7",
    "tail_offset": "13"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括顺序存储结构（将数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据域外还包含两个指针，一个指向前驱节点，另一个指向后继节点，通过这些指针可以在两个方向",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "双向链表是一种数据结构，每个节点除了包含数据域外，还有两个指针域，一个指向前驱节点，另一个指向后继节点，通过这些指针使得链表中的节点可以",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据域外还包含两个指针，一个指向前驱节点，另一个指向后继节点，通过这些指针可以在两个方向",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "快速排序是对给定数组通过选择一个基准元素，将数组分为两部分，小于基准的元素放在左边大于基准的元素放在右边，然后对左右两部分子数组分别递归",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "线性结构具有在数据元素的非空有限集中存在唯一的一个被称作“第一个”的数据元素、存在唯一的一个被称作“最后一个”的数据元素且除第一个外集合",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找特定元素的高效搜索算法，其核心性质包括：每次比较都将搜索区间缩小一半，通过不断缩小搜索范围来确定目标元素的",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心性质为通过指针将一系列节点连接起来，每个节点包含数据和指向下一个节点的指针，最后一个节点的指针指向空，从而",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含一个数据元素以及一个指向下一个节点的指针，通过这些节点的指针依次连接形成链表",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器内的表示，包括顺序存储结构（数据元素存于连续存储单元）、链式存储结构（数据元素存于任意存储单元",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "快速排序是对给定数组进行排序的一种算法，其核心特征是选择一个基准元素，通过一趟排序将数组分为两部分，使得左边部分的元素都小于等于基准元素",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "简单排序的核心特征是通过比较元素大小并逐步交换位置，将无序序列转换为有序序列，每次操作都基于相邻元素或特定位置元素的比较与交换来实现排序",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "66"
  },
  {
    "sentence": "线性结构具有在数据元素的非空有限集中存在唯一的一个被称作“第一个”的数据元素、存在唯一的一个被称作“最后一个”的数据元素且除第一个之外的",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "归并排序是一种采用分治思想将数组分成两个子数组分别排序后再合并成一个有序数组的稳定排序算法其时间复杂度为O(n log n)空间复杂度为",
    "head": "归并排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "深度优先搜索的核心特征是沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步，继续探索其他路径，优先选择深度方向的未访问",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "循环链表的核心特征是其尾节点的指针域指向头节点，从而形成一个环形结构，使得链表中的节点可以依次循环访问，不存在明确的链表结尾，从链表中的",
    "head": "循环链表",
    "tail": "尾节点",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间存在特定的关系，这些关系决定了数据的组织方式和操作规则，不同的逻辑结构具有不同的特点和应用",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针，通过指针将各个节点依次连接起来形成",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "算法效率的特点是指算法在执行过程中所表现出的时间复杂度和空间复杂度等方面的特性，包括算法执行时间随输入规模增长的变化情况以及算法运行所需",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "22",
    "tail_offset": "28"
  },
  {
    "sentence": "比较排序是基于元素之间的比较操作来确定元素顺序从而实现排序的一种排序算法，其核心特征是通过对元素两两比较来决定它们在有序序列中的相对位置",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "顺序查找的核心特征是从数据序列的第一个元素开始，依次逐个将元素与要查找的关键字进行比较，直到找到匹配的元素或者遍历完整个序列都未找到匹配",
    "head": "顺序查找",
    "tail": "查找",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，包括顺序存储结构（数据元素存放在地址连续的存储单元里，其逻辑关系由存储单元的邻接关系",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表，其核心特征是",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其特点是数据元素按顺序排列，有唯一的开始元素和结束元素，除开始和结束元素外每个元素",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机内存或存储设备中的实际存储方式，包括数据元素的存储位置以及它们之间的存储关系，其特点是具体体现数据在物理介质",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "33"
  },
  {
    "sentence": "存储结构的特点的核心特征包括数据元素在计算机内存中的存储方式、存储位置与逻辑关系的映射、数据元素间关系的表示方法以及对数据的访问和操作方式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "线性表是一种具有线性结构的数据结构，其特点的核心特征为存在唯一的一个被称为“第一个”的数据元素，存在唯一的一个被称为“最后一个”的数据元素",
    "head": "线性表",
    "tail": "线性结构",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，它包括数据元素的存储表示及其关系的表示，其核心特征是描述数据在计算机内存或存储设备中的实际存储",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "25"
  },
  {
    "sentence": "二分查找是一种在有序数组中查找某一特定元素的搜索算法，通过不断将数组中间元素与目标元素比较，根据比较结果缩小搜索范围直至找到目标元素或确定",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "深度优先搜索的核心性质是从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标节点，然后回溯到前一步继续探索其他路径，通过递归或栈",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "递归基础是递归定义中的一种情况，其核心特征是存在一种或多种简单、直接可解的基础情况，这些基础情况不需要通过递归调用自身来求解，而是能够直接",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "简单排序的特点是通过比较和交换元素位置逐步将无序序列转变为有序序列，包括直接插入排序比较并插入元素、冒泡排序相邻元素比较交换将最大元素沉底",
    "head": "简单排序",
    "tail": "插入",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "快速排序是对给定数组通过选择一个基准元素，将数组分为两部分，使得左边部分元素都小于等于基准元素，右边部分元素都大于等于基准元素，然后对左右",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其核心特征为每个节点包含一个数据元素以及一个指向后继节点的指针，通过这些节点的指针依次连接形成链表结构，并且",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度优先搜索的核心性质是沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，通过这种方式遍历或搜索整个图或",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "栈是一种后进先出（Last In First Out，LIFO）的数据结构，其操作主要包括入栈将元素添加到栈顶、出栈从栈顶移除元素以及获取",
    "head": "入栈",
    "tail": "出栈",
    "head_offset": "45",
    "tail_offset": "56"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及指向下一个节点的指针，其中第一个节点称为头节点，最后一个节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "存储结构的特点的核心特征是它决定了数据在计算机内存或存储设备中的存储方式，包括数据元素之间的逻辑关系如何映射到物理存储上，以及如何通过特定",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "循环链表是一种特殊的链表，其特点是最后一个节点的指针指向头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历，不存在链表结尾的情况，",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计值开始，利用某种迭代公式不断重复计算以逐步逼近问题精确解的方法其核心性质是通过重复执行相同的计算步骤逐渐改进",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "算法效率的定义的核心特征是指算法执行所需要的时间和空间资源与问题规模之间的关系，通常用时间复杂度和空间复杂度来衡量，时间复杂度关注算法执行",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "43",
    "tail_offset": "49"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其特点的核心特征为每个节点包含数据元素以及指向后继节点的指针，通过指针依次连接各个节点从而形成链表结构，并且",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "简单排序是对一组数据按照特定规则进行排列的操作，其核心特征在于通过比较数据元素之间的大小关系，依据设定的排序准则，逐步将数据调整为有序序列",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "数据的物理结构是数据在计算机内存中的存储方式，包括数据元素的存储表示及数据元素间关系的表示，其特点涉及存储结构、存储地址计算方式、数据元素",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "25"
  },
  {
    "sentence": "数组是一种有序数据集合，其中每个元素具有相同的数据类型，通过下标来唯一标识和访问元素，内存中存储连续，可高效随机访问但插入删除操作效率较低",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表的核心特征是每个节点包含一个数据元素以及一个指向下一个节点的指针，通过这些节点之间的指针依次连接形成线性序列，且只有头节点没有前驱，",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "双向链表是一种数据结构，其中每个节点除了包含数据域外还包含两个指针，分别指向前一个节点和后一个节点，从而形成双向链接关系，使得可以双向遍历",
    "head": "双向链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据在计算机中的存储方式包括数据元素的存储及其关系的表示，它具体体现为顺序存储结构中数据元素按逻辑顺序",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "32"
  },
  {
    "sentence": "递归基础是递归定义中的一部分，它明确规定了递归过程中最简单、最基本的情况，即不需要通过递归调用就能直接得出结果的情况，这是递归定义得以成立",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其特点为数据元素按顺序排列，有唯一的开始元素和结束元素，除开始和结束元素外每个元素",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "二分查找是一种在有序数组中通过不断将区间分成两半并根据目标值与中间元素的比较结果来缩小查找区间从而高效查找目标元素的算法其特点在于查找效率",
    "head": "二分查找",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "哈希表是一种数据结构，其核心特征是通过哈希函数将键映射到特定位置，从而实现快速的数据查找插入和删除操作，具有平均时间复杂度接近常数的高效性",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到特定位置来存储和检索数据元素使得数据的插入、查找和删除操作在平均情况下具有接近常数的时间复杂度",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "线性查找是一种在数据序列中从起始位置开始依次逐个比较元素，直到找到目标元素或遍历完整个序列的查找方法其特点是算法简单但平均查找长度较大时间",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "抽象数据类型具有数据对象、数据关系以及定义在这些数据对象和数据关系上的一组操作，且其强调数据封装和信息隐藏，用户只能通过特定接口访问和操作",
    "head": "抽象数据类型",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "64"
  },
  {
    "sentence": "冒泡排序是一种比较相邻元素大小并在必要时交换位置，通过多次重复此过程将最大元素逐步“冒泡”到数组末尾，从而实现对数组元素从小到大排序的排序",
    "head": "冒泡排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "数据类型具有特定的取值范围、存储方式、操作集合以及语义解释等特点，其核心特征包括明确规定数据所允许的值的集合，确定数据在内存中的存储形式，",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "21"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机中的存储表示及其存储方式，其核心性质包括数据元素的表示方式、元素间关系的表示方法以及数据的存储结构等方面，",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表是一种线性数据结构，其特点的核心特征包括每个节点包含一个数据元素和一个指向下一个节点的指针，通过指针依次连接各个节点形成链表结构，且",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表结构，其核心特征",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "线性查找是一种从数据序列开头开始依次逐个比较元素，直到找到目标元素或遍历完整个序列的查找方式其特点是对数据序列无特定要求且查找过程较为简单",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "34"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其特点是有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个前驱，",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及指向下一个节点的指针，通过头节点可以依次访问链表中的各个节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "单链表是一种线性数据结构，其每个节点包含一个数据元素和一个指向下一个节点的指针，通过这些指针依次连接各个节点形成链表，且只有一个头指针用于",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据域外，还有两个指针分别指向前一个节点和后一个节点，通过这些指针可以在两个方向上遍历链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间存在特定的逻辑关系，这些关系决定了数据的组织方式和操作规则，并且不同类型的逻辑结构具有不同的",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理存储位置上也相邻，进而通过数据元素物理存储的先后",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "哈希表是一种数据结构它通过哈希函数将键映射到表中的特定位置从而以接近常数的时间复杂度进行插入、查询和删除操作并且可能存在哈希冲突需采用特定",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "单链表是一种线性数据结构，其每个节点包含一个数据元素和一个指向下一个节点的指针，通过指针依次连接各个节点形成链表，具有顺序访问特性，插入和",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "简单排序的核心特征是基于比较的方式对数据元素进行逐一比较和交换操作，以将无序的数据序列转变为有序序列，每次操作主要针对相邻或特定位置的元素",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "哈希表具有通过哈希函数将键映射为索引以实现快速数据访问、能高效地进行插入删除查找操作且平均情况下时间复杂度为常数级但可能存在哈希冲突需解决",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素相对次序从而进行排序的算法，其核心特征是排序过程依赖元素间的比较操作，通过比较逐步确定元素在有序序列中的",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "25"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间的逻辑关系，如线性结构中数据元素存在一对一的线性关系，树形结构中数据元素呈现一对多的层次关系",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素都最多有一个直接前驱和一个直接后继（除了第一个和最后一个数据元素）",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性查找是一种在数据序列中从起始位置开始依次逐个比较元素，直到找到目标元素或遍历完整个序列的查找方法其特点是比较次数与数据规模相关平均时间",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它具体包括顺序存储结构、链式存储结构、索引存储结构和散列存储结构等，通过这些不同方式将",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其特点的核心特征包括每个节点包含数据元素和一个指向后继节点的指针，通过指针依次连接各个节点从而形成链表结构，",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器内的表示，其核心特征包括数据元素的表示以及数据元素之间关系的表示，具体体现为选择合适的存储方式如",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表结构，其中首节点",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "链表是一种线性数据结构，其特点的核心特征包括每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表，数据存储在节点",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素和一个指向后继节点的指针，通过这些节点的指针依次连接形成线性序列，并且只有一个头指针指向",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度优先搜索按照深度优先的方式遍历图或树等数据结构，优先沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径",
    "head": "深度优先搜索",
    "tail": "遍历",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及指向下一个节点的指针，其中第一个节点称为头节点，最后一个节点",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "简单排序是对数据序列按特定规则依次比较元素大小并交换位置以实现从小到大或从大到小有序排列的排序方法其特点包括操作相对简单易于理解但平均时间",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "45"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心特征包括：每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表，数据在链表中的存储",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素之间的逻辑关系在计算机中的存储方式决定了数据的存储和访问效率、不同的存储结构适用于不同的应用场景以及会",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "快速排序是对给定数组通过选择一个基准元素，将数组分为两部分，使得左边部分元素都小于等于基准元素，右边部分元素都大于等于基准元素，然后对左右",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式不断重复计算以逐步逼近问题精确解的方法其特点包括能通过有限步骤逼近精确解、计算过程相对简单",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "快速排序是对给定数组通过选择一个基准元素，将数组分为两部分，使得左边部分元素都小于等于基准元素右边部分元素都大于等于基准元素，然后对左右两",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "指针的核心特征是其存储的是内存地址，通过该地址可以直接访问和操作内存中的数据，使得程序能够灵活地处理和管理内存中的信息，实现高效的数据传递",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "简单排序的核心特征是通过比较元素之间的大小关系，将无序序列逐步调整为有序序列，排序过程相对直观且易于理解，通常基于相邻元素的比较与交换操作",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，每个节点包含数据元素以及指向后继节点的指针，通过指针将各个节点依次连接起来形成一个链表结构，其中首节点无前驱",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "比较排序是基于元素间比较来确定元素间相对次序从而对元素序列进行排序的排序算法，其核心特征在于通过比较元素大小来逐步构建有序序列，排序过程中",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "31"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其特点包括有且仅有一个开始和一个终端节点，除开始和终端节点外，每个节点有且仅有一个",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构的特点的核心性质是存在唯一的一个被称作“第一个”的数据元素，存在唯一的一个被称作“最后一个”的数据元素，除第一个之外，结构中的每个",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及一个指向下一个节点的指针，通过这些指针将所有节点依次连接起来",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "快速排序的核心特征是通过选择一个基准元素，将数组分为两部分，使得左边部分元素都小于等于基准元素，右边部分元素都大于等于基准元素，然后对左右",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "快速排序是对给定数组通过选择一个基准元素，将数组分为两部分，使得左边部分元素都小于等于基准元素，右边部分元素都大于等于基准元素，然后对左右",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "数据类型的特点的核心特征包括具有特定的数据值集合、定义了一组操作或运算规则、规定了数据的存储方式和表示形式以及体现了数据之间的内在逻辑关系",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "数据的物理结构的特点的核心性质是数据元素在计算机中的存储方式及它们之间的关系，包括顺序存储结构中数据元素按逻辑顺序依次存放，链式存储结构中",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "16"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心性质为每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成一个序列，最后一个节点的指针",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是它描述了数据在计算机内存或存储设备中的实际存储方式，包括数据元素的存储位置以及它们之间的逻辑关系是如何通过",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "44"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据域外，还包含两个指针分别指向前一个节点和后一个节点，通过这些节点的链接形成一个双向有序",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "链表的核心特征是通过节点之间的指针链接来顺序存储数据元素，每个节点包含数据和指向下一个节点的指针，数据元素在内存中不一定连续存储，从而可以",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间存在特定的逻辑关系，这些关系决定了数据的组织方式和操作方法，并且不同的逻辑结构具有不同的特点",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及一个指向下一个节点的指针，通过这些节点之间的指针依次连接形成",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "深度优先搜索的核心性质是沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，优先访问新发现的节点，直到遍历",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "指针是一种变量，其值为内存地址，通过指针可以间接访问和修改其所指向的内存位置的数据，具有灵活高效地操作内存、可作为函数参数方便传递复杂数据",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它包括数据元素的表示和关系的表示，具体可分为顺序存储结构、链式存储结构、索引存储结构和",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来，形成一个链式结构，数据",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "哈希表具有通过哈希函数将键映射到特定位置以实现快速数据存储与检索、能在平均情况下以接近常数的时间复杂度进行操作且可能存在哈希冲突需特定处理",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及指向下一个节点的指针，通过这些节点的指针依次连接形成链表结构",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "快速排序的核心性质是选择一个基准元素，通过一趟排序将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分的元素都大于等于基准元素",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "单链表是一种线性数据结构，其每个节点包含一个数据元素和一个指向下一个节点的指针，通过指针依次连接各个节点形成链表，具有逻辑上相邻但物理存储",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "存储结构的特点是指数据在计算机存储器中的组织方式及其所具有的诸如数据元素间的逻辑关系体现形式、数据元素的存储方式、数据运算的实现效率及空间",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "32"
  },
  {
    "sentence": "链表是一种线性数据结构，其特点的核心性质包括每个节点包含数据和指向下一个节点的指针，通过指针依次连接各个节点从而形成链表结构，数据在链表中",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "数据类型的特点的核心特征包括具有特定的数据表示形式、取值范围，规定了对其所能进行的操作，不同数据类型的这些方面存在差异以适应不同的应用需求",
    "head": "数据类型",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "46"
  },
  {
    "sentence": "线性查找是在一个数据序列中从起始位置开始依次逐个检查元素，直到找到目标元素或遍历完整个序列为止的查找方法其核心特征是按顺序逐一比对数据元素",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "38"
  },
  {
    "sentence": "树是一种非线性的数据结构，它有一个根节点，其余节点被分成若干互不相交的有限集合，每个集合又是一棵树，具有层次分明、分支关系明确、递归定义等",
    "head": "根节点",
    "tail": "集合",
    "head_offset": "17",
    "tail_offset": "37"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由一系列节点组成，每个节点包含一个数据元素以及一个指向下一个节点的指针，通过指针将各个节点依次连接起来形成",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "快速排序是对给定数组通过选择一个基准元素，将数组分为两部分，使得左边部分元素都小于等于基准元素右边部分元素都大于等于基准元素，然后对左右两",
    "head": "快速排序",
    "tail": "数组",
    "head_offset": "0",
    "tail_offset": "8"
  },
  {
    "sentence": "单链表的核心特征是每个节点包含数据元素以及一个指向后继节点的指针，通过这些指针将所有节点依次连接起来形成一个线性序列，其中首节点无前驱，尾",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "存储结构的定义的核心性质包括数据元素本身的信息表示以及数据元素之间关系的表示，它决定了数据在计算机内存或存储设备中的存储方式，影响着数据的",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "指针的核心特征是其存储的是内存地址，通过该地址能够直接访问和操作内存中的数据，使得程序可以灵活地处理不同位置的数据，方便实现数据的动态存储",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "算法效率的核心特征是指算法在执行过程中所表现出的时间复杂度和空间复杂度，它们分别衡量算法执行时间随输入规模增长的变化趋势以及算法执行过程中",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "24",
    "tail_offset": "30"
  },
  {
    "sentence": "简单排序的核心特征是通过比较和交换元素的位置，逐步将无序序列转换为有序序列，排序过程相对直观和易于理解，通常基于相邻元素或固定间隔元素之间",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "快速排序的核心特征是选择一个基准元素，通过一趟排序将数组分为两部分，使得左边部分的元素都小于等于基准元素，右边部分的元素都大于等于基准元素",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "指针具有指向变量存储地址、可通过其间接访问所指向变量、能进行指针运算如移动指针位置以指向相邻存储单元等特点且指针类型决定了其所能指向的数据",
    "head": "指针",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "非线性结构的核心特征是其中的数据元素之间存在一对多或多对多的关系，不像线性结构那样具有唯一的前驱和后继关系，数据元素的排列不是按照顺序依次",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的数据元素在物理位置上也相邻，从而可以通过数组下标直接访问元素的",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "20",
    "tail_offset": "25"
  },
  {
    "sentence": "时间复杂度是用来衡量算法执行时间随输入规模增长而变化的函数，它描述了算法运行时间的增长趋势，不同算法的时间复杂度不同，反映了算法效率随输入",
    "head": "时间复杂度",
    "tail": "时间复杂度",
    "head_offset": "0",
    "tail_offset": "51"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，具有在搜索过程中优先深入探索新发现的节点且",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，它由多个节点组成，每个节点包含数据元素以及一个指向后继节点的指针，通过这些节点的指针依次相连形成一个线性序列",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "链表是一种线性数据结构，其特点的核心特征包括每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表，数据在链表中的",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，按照一定的迭代公式不断重复计算以逐步逼近问题精确解的方法其特点包括计算过程相对简单易于实现能在有限步骤",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "单链表由一系列节点组成每个节点包含数据和指向下一个节点的指针且第一个节点为头节点最后一个节点的指针指向空值通过头节点可依次访问链表中的所有",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机中的存储表示及其存储方式，它包括数据元素的表示和关系的表示，其核心性质是描述数据在计算机内存或存储设备中的",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "双向链表是一种链表数据结构，其中每个节点除了包含数据域外，还有两个指针分别指向前一个节点和后一个节点，通过这些指针可以在两个方向上遍历链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "链表是一种通过指针将多个节点连接起来的数据结构，每个节点包含数据以及指向下一个节点的指针，其中头节点指向链表的第一个节点，尾节点的指针为空",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索的核心性质是从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标节点，然后回溯到前一步继续探索其他路径，以深度优先的",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "递归基础的核心特征是存在一种简单的、无需再次递归调用自身就能直接得出结果的终止条件或初始情况，使得递归过程能够在满足该条件时停止并返回最终",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "哈希表的核心性质是对于不同的关键字可能得到同一哈希地址即产生哈希冲突，通过哈希函数将关键字映射到哈希表中的一个位置，并且能高效地进行插入、",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "37"
  },
  {
    "sentence": "算法效率的核心性质是指算法执行所需要的时间和空间资源的有效程度包括时间复杂度和空间复杂度等方面它直接影响算法在实际应用中的可行性和性能表现",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "33",
    "tail_offset": "39"
  },
  {
    "sentence": "图是由顶点集合以及顶点之间的边集合组成的数据结构，顶点集合不能为空，边集合中的每条边都连接着顶点集合中的两个顶点，顶点之间的连接关系可以是",
    "head": "集合",
    "tail": "集合",
    "head_offset": "5",
    "tail_offset": "15"
  },
  {
    "sentence": "循环链表是一种特殊的链表结构，其特点是尾节点的指针不是指向NULL，而是指向链表的头节点，从而形成一个环形结构，使得链表中的节点可以依次遍历",
    "head": "循环链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用某种迭代公式不断重复计算以逐步逼近问题精确解的方法，其核心性质是通过多次迭代逐步改进近似解使其越来越",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "22"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心特征包括每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表，数据在链表中的存储顺序",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "哈希表通过哈希函数将键映射到特定位置以实现快速数据存储与检索，具有常数时间复杂度的查找、插入和删除操作，能高效处理大规模数据，但可能存在哈希",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "哈希表具有通过哈希函数将键映射到特定位置以实现快速数据查找插入删除，平均情况下时间复杂度接近常数，能高效利用内存且数据元素存储位置与键值相关",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "递归基础是递归定义中的一部分，其核心特征是明确给出递归终止的条件或初始值，即确定在某个特定情况下递归不再继续，而是直接给出结果，这个特定情况",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "5"
  },
  {
    "sentence": "数组是一种有序的数据集合，其特点的核心特征包括：元素具有相同的数据类型，通过连续的内存空间存储，可通过下标进行随机访问，内存空间的分配是连续",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "抽象数据类型的核心特征是将数据和操作数据的方法封装在一起，对外提供统一的接口，隐藏数据的具体实现细节，使得使用者只需关注抽象数据类型所提供的",
    "head": "抽象数据类型",
    "tail": "抽象数据类型",
    "head_offset": "0",
    "tail_offset": "60"
  },
  {
    "sentence": "稳定性是指在数据结构中，若两个相等的数据元素在原序列中的相对先后顺序和经过某种操作后在新序列中的相对先后顺序保持一致，则该数据结构具有稳定性",
    "head": "稳定性",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "哈希表具有通过哈希函数将键映射为特定位置以实现快速数据存储与检索、能高效处理大规模数据且在平均情况下查找插入删除操作时间复杂度为常数级等特点",
    "head": "哈希表",
    "tail": "哈希函数",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "非线性结构的核心特征是存在至少一个数据元素有不止一个前驱元素或不止一个后继元素，即数据元素之间的关系不再是一对一的线性关系，可能存在一对多、",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "快速排序的核心特征是选择一个基准元素，通过一趟排序将数组分为两部分，使得左边部分元素都小于等于基准元素，右边部分元素都大于等于基准元素，然后",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "深度优先搜索的核心性质是从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，直到遍历完所有节点",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "交换排序是一种通过不断比较和交换元素位置来将无序数据序列转换为有序序列的排序方法其特点在于相邻或不相邻元素之间基于比较结果进行位置互换以逐步",
    "head": "交换排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "单链表是一种链式存储的线性表，其核心特征包括每个节点包含数据元素和一个指向后继节点的指针，通过指针将各个节点依次连接起来形成链表结构，第一个",
    "head": "单链表",
    "tail": "线性表",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "存储结构的特点的核心特征是数据元素之间的逻辑关系在计算机中的存储表示，包括顺序存储结构中数据元素按逻辑顺序依次存放在一组连续存储单元里，链式",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，其核心性质包括数据元素的表示以及数据元素间关系的表示，它决定了数据在计算机中的存储方式和",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "单链表由节点组成每个节点包含数据和指向下一节点的指针且最后一个节点的指针为空第一个节点称为头节点通过头节点可访问整个链表每个节点只能直接访问",
    "head": "单链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "24"
  },
  {
    "sentence": "单链表的核心特征是每个节点包含数据元素以及指向下一个节点的指针，通过这些指针将各个节点依次连接起来形成线性序列，并且最后一个节点的指针指向空",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其核心特征为数据元素之间有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，其核心性质包括从起始节点开始，每次选择一个",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素在计算机内存中的存储方式以及它们之间的逻辑关系的表示方法 ，并且涉及到如何通过特定的存储布局来高效地进行",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索，直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，其核心性质包括总是优先往深度方向搜索，通过",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "链表的核心特征是通过节点之间的指针连接来存储数据元素，每个节点包含数据部分和指向下一个节点的指针，从而形成一种链式的数据结构，使得数据的存储",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "15"
  },
  {
    "sentence": "线性表是一种数据元素之间存在一对一线性关系的数据结构，其特点包括有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个直接前驱",
    "head": "线性表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构的核心性质是存在唯一的一个被称作“第一个”的数据元素，存在唯一的一个被称作“最后一个”的数据元素，除第一个之外，结构中的每个数据元素",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "线性结构的核心性质是存在唯一的一个被称作“第一个”的数据元素且存在唯一的一个被称作“最后一个”的数据元素以及除第一个之外的数据元素均有唯一的",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "深度优先搜索的核心性质是从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标节点，然后回溯到前一步继续探索其他路径，直到遍历完所有",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机存储器中的存储方式，包括数据元素的存储方式以及数据元素之间关系的存储方式，它具体体现为数据的存储结构形式如顺序",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "27"
  },
  {
    "sentence": "双向链表是一种线性数据结构，每个节点包含数据元素以及指向其前驱节点和后继节点的指针，从而支持双向遍历，在插入和删除操作时相较于单向链表更灵活",
    "head": "双向链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素之间的相对顺序从而实现排序，其核心特征在于通过比较不同元素的值来逐步构建有序序列，在排序过程中不断比较",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是数据元素在计算机中的存储表示，包括数据元素的存储方式、存储顺序以及数据元素之间的逻辑关系如何在存储结构中体现",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "16"
  },
  {
    "sentence": "存储结构的特点是指数据元素及其关系在计算机存储器中的表示方式所具有的特性包括数据元素的表示和关系的表示以及对数据元素进行操作的实现方式等方面",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据在计算机存储器中的存储方式包括顺序存储、链式存储、索引存储和散列存储等以及数据元素之间的逻辑关系如何",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "57"
  },
  {
    "sentence": "深度优先搜索的核心特征是沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步，选择其他分支继续深度探索，如此反复直到遍历完所有",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "16"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源的量度包括时间复杂度和空间复杂度分别衡量算法执行时间随输入规模增长的变化情况以及算法执行过程中所需",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "26",
    "tail_offset": "32"
  },
  {
    "sentence": "双向链表是一种链表数据结构，每个节点包含一个数据元素以及两个指针，一个指向前驱节点，另一个指向后继节点，通过这些指针可以在两个方向上遍历链表",
    "head": "双向链表",
    "tail": "链表",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机中的存储表示及其操作方式，它包括数据元素的表示和关系的表示，其核心性质是描述数据在计算机内存中的存储方式以及",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，具有优先深入探索当前路径的特点且会递归地处理",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，它包括数据元素的存储表示以及数据元素之间关系的存储表示，其核心特征在于明确数据在计算机存储设备上",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "25"
  },
  {
    "sentence": "深度优先搜索是从起始节点开始沿着一条路径尽可能深地探索直到无法继续或达到目标节点，然后回溯到前一步继续探索其他路径，其核心性质是优先沿着一条",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "递归基础的核心特征是存在递归终止条件，即在递归过程中能够明确地给出一个或多个不需要再进行递归调用的简单情况，这些简单情况是递归能够结束并返回",
    "head": "递归基础",
    "tail": "递归",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按顺序排列，有唯一的开始元素和结束元素，且除开始和结束元素外每个元素",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "比较排序是基于元素之间的比较来确定元素的相对次序从而对元素序列进行排序的排序算法其核心性质在于排序过程仅通过比较元素大小来决定元素的最终位置",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据以及指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表结构，并且链表的",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储方式，其特点包括数据元素的存储表示、存储结构与数据逻辑结构之间的映射关系以及数据元素之间的物理存储顺序，",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "26"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心特征包括每个节点包含数据和指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表结构，数据的存储顺序可以",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素之间的逻辑关系在计算机中的存储方式决定了数据的访问效率和操作方式以及数据的存储密度和扩展性等方面会受到其",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "存储结构的特点是指数据元素及其关系在计算机存储器中的表示方式所具有的特性，包括顺序存储结构中数据元素按逻辑顺序依次存放在一组连续存储单元里、",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针，通过指针将节点依次连接起来，从而形成一个链式结构，最后一个",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "38"
  },
  {
    "sentence": "数据类型的核心性质包括取值范围、操作集合以及数据表示方式等方面，取值范围限定了数据类型所能表示的值的集合，操作集合定义了对该数据类型的值可以",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "18"
  },
  {
    "sentence": "链表是一种线性数据结构，其核心特征包括每个节点包含数据和指向下一个节点的指针，通过指针依次连接各个节点形成链表，数据在链表中的存储位置不连续",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "存储结构的特点是指数据元素及其关系在计算机存储器中的表示方式所具有的特性，包括数据元素的存储方式、数据元素间关系的表示方法以及对数据元素进行",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "线性结构的核心性质是存在唯一的一个被称作“第一个”的数据元素，存在唯一的一个被称作“最后一个”的数据元素，除第一个之外，结构中的每个数据元素",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "26"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储表示形式，它不仅包括数据元素的表示，还包括数据元素之间关系的表示，具有存储方式明确、与计算机存储设备相关",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "28"
  },
  {
    "sentence": "快速排序的核心特征是选择一个基准元素，通过一趟排序将数组分为两部分，使得左边部分元素都小于等于基准元素，右边部分元素都大于等于基准元素，然后",
    "head": "快速排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "23"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储方式以及数据元素之间关系的存储方式其核心特征在于描述数据在物理存储介质上的具体",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "存储结构的特点是指数据元素及其关系在计算机存储器中的表示方式所具有的特性包括数据元素的表示和关系的表示以及对数据元素进行操作的实现方式等方面",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式不断重复计算逐步逼近问题精确解的方法，其特点包括计算过程相对简单、能有效处理大规模问题、收敛",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源的量度，包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化趋势，空间复杂度",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "27",
    "tail_offset": "33"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据在计算机中的存储方式包括顺序存储链式存储索引存储散列存储等以及数据元素之间的逻辑关系如何在存储结构中",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "51"
  },
  {
    "sentence": "存储结构的特点的核心特征包括数据元素在计算机内存中的存储方式、存储位置的组织和安排、数据元素之间的逻辑关系如何通过存储来体现以及对数据的访问",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "简单排序是对一组数据按照特定规则进行排列的操作，其核心特征在于通过比较数据元素之间的大小关系，将数据逐步调整为有序序列，排序过程基于直接比较",
    "head": "简单排序",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "35"
  },
  {
    "sentence": "简单排序的核心特征是其排序过程相对较为直接和基础，通常基于比较和交换元素的方式逐步将无序序列转化为有序序列，算法逻辑较为简单易懂，时间复杂度",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "11"
  },
  {
    "sentence": "算法效率的定义的核心特征是指算法执行所需的时间和空间资源与问题规模之间的关系，通常用时间复杂度和空间复杂度来衡量，时间复杂度反映算法执行时间",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "42",
    "tail_offset": "48"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储方式，其特点的核心性质包括数据元素在计算机内存中的存储地址是连续或离散的，以及数据元素之间的逻辑关系通过",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "31"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源的量度，包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "27",
    "tail_offset": "33"
  },
  {
    "sentence": "操作效率的核心特征是在一定时间内以最少的资源投入和最高的准确性完成最多的有效操作从而实现产出最大化并保证操作过程的流畅性与稳定性减少不必要的",
    "head": "操作效率",
    "tail": "稳定性",
    "head_offset": "0",
    "tail_offset": "61"
  },
  {
    "sentence": "简单排序是对给定数据序列按照特定规则进行排列，使其满足一定顺序要求的一种排序方式，其核心特征在于通过比较和交换等操作逐步将数据序列调整为有序",
    "head": "简单排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "36"
  },
  {
    "sentence": "链表是一种线性数据结构，其特点的核心性质包括每个节点包含数据和指向下一个节点的指针，通过指针依次连接各个节点从而形成链式结构，数据的存储顺序",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，其特点包括数据元素的存储方式如顺序存储、链式存储等决定了数据的访问效率、内存占用情况以及",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "深度优先搜索沿着一条路径尽可能深地探索直到无法继续或达到目标，然后回溯到前一步继续探索其他路径，具有优先扩展深度方向节点的特点且在未完全遍历",
    "head": "深度优先搜索",
    "tail": "路径",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性查找是从数据序列的开头开始，依次逐个检查元素，直到找到目标元素或遍历完整个序列为止的一种查找方法其特点包括时间复杂度在最坏情况下为O(n",
    "head": "查找",
    "tail": "遍历",
    "head_offset": "2",
    "tail_offset": "34"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式包括数据元素的表示及其关系的表示其核心特征是描述数据在存储设备上的存储形式体现数据元素及其关系如何",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "线性结构的特点的核心性质是存在唯一的一个被称作“第一个”的数据元素且存在唯一的一个被称作“最后一个”的数据元素除第一个之外的数据元素均有唯一",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "非线性结构的核心特征是存在至少一个数据元素有不止一个前驱元素或不止一个后继元素即元素之间的关系不再是一对一的线性关系而是呈现出较为复杂的多对",
    "head": "非线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "存储结构的核心特征是数据元素在计算机存储器中的存储方式以及它们之间的逻辑关系的表示，包括顺序存储、链式存储等方式，且要体现数据元素间逻辑关系",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "顺序表具有随机访问特性即可以通过下标直接访问元素，元素存储紧凑，内存利用率高，插入和删除操作效率低尤其是在中间位置操作时需要移动大量元素，其",
    "head": "访问",
    "tail": "访问",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "链表的核心性质是通过指针将一系列节点按顺序连接起来，每个节点包含数据和指向下一个节点的指针，最后一个节点的指针指向空，从而形成一种线性的数据",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "集合具有确定性即给定一个集合，任何一个对象是不是这个集合的元素就确定了、互异性即集合中的元素互不相同、无序性即集合中的元素没有顺序之分等特点",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "12"
  },
  {
    "sentence": "链表是一种线性数据结构，它由一系列节点组成，每个节点包含数据以及指向下一个节点的指针，通过指针将各个节点依次连接起来，形成一个链式结构，数据",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "40"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，在该结构中数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除第一个元素",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "顺序表具有随机访问特性即可以通过下标直接访问元素、存储密度高因为元素存储紧凑、逻辑上相邻的元素物理存储位置也相邻以及插入和删除操作效率低尤其是",
    "head": "访问",
    "tail": "访问",
    "head_offset": "7",
    "tail_offset": "20"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其核心性质包括有且仅有一个开始节点和一个终端节点，除开始节点外每个节点有且仅有一个前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构的特点的核心性质是存在唯一的一个被称为“第一个”的数据元素且存在唯一的一个被称为“最后一个”的数据元素并且除第一个之外的数据元素均只有",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "29"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种次序排列，且除第一个和最后一个数据元素外，每个元素都有唯一的前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机存储器中的存储方式包括数据元素的存储及其关系的表示它具体体现为数据元素在存储设备上的存储布局以及数据元素之间关系",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "26"
  },
  {
    "sentence": "比较排序是通过元素间的比较来确定元素间的相对次序从而实现排序，其核心性质包括比较排序在最坏情况下时间复杂度为Ω(n log n)且任何基于比较",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "数组是具有相同数据类型的一组数据元素的有序集合，其特点包括内存中连续存储可通过下标快速访问、元素类型一致方便处理、存储空间固定但可灵活定义大小",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是一种有序的数据集合，其核心特征包括：元素具有相同的数据类型，通过连续的内存空间存储，每个元素可以通过下标进行唯一访问，数组的大小在创建时",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储方式以及数据元素之间关系的存储方式其核心特征是描述数据在计算机内存或存储设备中的",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素在计算机内存中的存储方式以及它们之间的逻辑关系如何通过物理存储来体现 数据元素的存储位置反映其逻辑关系 且",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "单链表的核心性质是每个节点包含一个数据元素以及一个指向下一个节点的指针，通过指针依次连接各个节点形成线性序列，其中第一个节点无前驱称为头节点，",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "比较排序的核心特征是通过元素之间的比较来确定元素的相对顺序从而实现排序，其时间复杂度下限为O(n log n)，这意味着在最坏情况下，任何基于",
    "head": "比较排序",
    "tail": "排序",
    "head_offset": "0",
    "tail_offset": "33"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储及其关系的表示，它具体体现为数据元素在存储器中的存储位置以及数据元素之间逻辑关系",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机中的存储表示及其存储方式，其核心性质包括数据元素本身的表示以及元素之间关系的表示，并且它决定了数据在计算机内存",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储方式以及数据元素之间关系的存储方式其核心特征在于具体描述了数据在计算机存储设备上",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "集合具有确定性、互异性和无序性这三个核心特征，其中确定性是指集合中的元素必须是确定的，也就是说给定一个集合，任何一个元素是否属于这个集合是明确",
    "head": "集合",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "30"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源，通常用时间复杂度和空间复杂度来衡量，时间复杂度反映算法执行时间随输入规模增长的变化趋势，空间复杂度",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "25",
    "tail_offset": "31"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储方式，它具有紧密依赖计算机硬件、直接影响数据处理效率、决定数据在存储器中的存储位置及顺序、与数据的逻辑结构",
    "head": "物理结构",
    "tail": "逻辑结构",
    "head_offset": "3",
    "tail_offset": "67"
  },
  {
    "sentence": "操作效率的核心特征是在单位时间内以最少的资源投入获得最大的产出且保证操作的准确性和稳定性同时能够快速响应各种任务需求并高效地完成一系列相关操作",
    "head": "操作效率",
    "tail": "稳定性",
    "head_offset": "0",
    "tail_offset": "41"
  },
  {
    "sentence": "单链表的核心性质是每个节点包含一个数据元素以及一个指向链表中下一个节点的指针，通过这些节点之间的指针链接形成线性序列，且只有一个头指针指向链表",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "存储结构的特点的核心特征包括数据元素在存储器中的存储方式以及它们之间的逻辑关系如何通过存储来体现，涉及顺序存储中数据元素按顺序依次存放，可通过",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，其核心性质包括数据元素的表示方式、数据元素之间关系的表示方式以及对数据元素进行访问和修改的",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种顺序排列，且除第一个和最后一个数据元素外，每个元素都有唯一前驱和",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数组是一种有序的数据集合，其特点包括元素具有相同的数据类型，通过连续的内存存储，可通过下标进行快速访问，元素个数固定，内存空间预先分配，元素的",
    "head": "数组",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "链表是一种线性数据结构，由一系列节点组成，每个节点包含数据以及指向下一个节点的指针，通过指针将各个节点依次连接起来形成链表，其核心性质包括每个",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "39"
  },
  {
    "sentence": "迭代法是一种通过从一个初始估计出发，利用迭代公式不断重复计算以逐步逼近问题精确解的方法其核心性质是通过反复运用迭代公式逐步改进近似解使其越来越",
    "head": "迭代法",
    "tail": "迭代",
    "head_offset": "0",
    "tail_offset": "20"
  },
  {
    "sentence": "数据的物理结构的特点的核心性质包括数据元素在计算机中的存储方式以及数据元素之间的逻辑关系在计算机中的表示，它决定了数据在内存或存储设备中的具体",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其特点包括有且仅有一个开始节点和一个终端节点，除开始节点外每个节点有且仅有一个前驱节点",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是数据元素在计算机中的存储方式，包括顺序存储结构下数据元素按逻辑顺序依次存放，以及链式存储结构中通过指针表示数据",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "16"
  },
  {
    "sentence": "哈希表是一种根据关键码值(Key value)而直接进行访问的数据结构它通过一个哈希函数将关键码映射到表中的一个位置来访问记录以加快查找的速度",
    "head": "哈希表",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其核心特征包括有且仅有一个开始元素和一个终端元素，除开始元素外每个元素有且仅有一个前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "存储结构的核心特征是它描述了数据元素之间的逻辑关系如何在计算机内存中实际存储，包括数据元素自身的存储方式以及它们之间关系的存储方式，使得计算机",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机存储器中的存储方式，它具体包括数据元素的存储方式以及数据元素之间关系的存储方式，其特点是直接体现数据在计算机内部",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "30"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机存储器中的存储方式，包括数据元素的存储及其关系的表示，它具体体现为数据元素在内存中的存储位置以及它们之间通过何种",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "27"
  },
  {
    "sentence": "存储结构的特点的核心性质包括数据元素之间的逻辑关系在计算机中的存储表示、数据元素及其关系的存储方式以及数据元素之间关系的表示方法等方面所呈现出",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，包括数据元素的存储方式以及数据元素之间关系的存储方式其核心特征在于明确体现数据在计算机存储设备上的",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "24"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储表示，包括数据元素的表示及其关系的表示，具有与数据元素存储位置相关以及体现数据元素间逻辑关系存储方式的核心",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构其特点为有且仅有一个开始节点和一个终端节点除开始节点和终端节点外每个节点有且仅有一个前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储方式，其特点的核心性质包括数据元素在计算机存储器中的存储位置与逻辑关系相对应且具体体现为顺序存储结构中数据",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "31"
  },
  {
    "sentence": "哈希表是一种根据关键码值(Key value)而直接进行访问的数据结构，它通过一个哈希函数将关键码映射到表中的一个位置来访问记录，以加快查找的",
    "head": "哈希表",
    "tail": "访问",
    "head_offset": "0",
    "tail_offset": "28"
  },
  {
    "sentence": "数据的逻辑结构的特点的核心性质包括数据元素之间的逻辑关系，可分为线性结构和非线性结构，线性结构中数据元素存在一对一的关系，非线性结构中数据元素",
    "head": "逻辑结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "17"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构其特点为有且仅有一个开始结点和一个终端结点并且所有结点都最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据类型的特点的核心特征包括具有特定的数据表示形式规定了数据所能取值的范围和精度定义了对数据可执行的操作集合以及反映了数据在计算机内存中的存储",
    "head": "数据类型",
    "tail": "集合",
    "head_offset": "0",
    "tail_offset": "52"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，它具有能有效存储数据及数据间关系、支持高效的数据访问和修改操作、适应不同应用场景对数据存储",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机中的存储方式，其核心特征包括数据元素的存储表示以及数据元素之间关系的表示，具体体现为数据元素在存储器中的存储位置",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "29"
  },
  {
    "sentence": "存储结构定义的核心性质包括数据元素在计算机内存中的存储方式以及数据元素之间的逻辑关系如何通过存储方式来体现，还包括如何实现对数据元素的访问、插入",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "13"
  },
  {
    "sentence": "空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度其核心性质包括与输入规模相关不同算法的空间复杂度因实现方式和数据处理需求而异可能存在",
    "head": "空间复杂度",
    "tail": "空间复杂度",
    "head_offset": "0",
    "tail_offset": "49"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据在计算机中的存储方式包括顺序存储链式存储索引存储散列存储等以及数据元素之间的逻辑关系在计算机中的表示形式",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "51"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据在计算机存储器中的存储方式包括顺序存储链式存储索引存储散列存储等体现数据元素之间的逻辑关系以及数据元素在",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "54"
  },
  {
    "sentence": "数据的物理结构的特点的核心性质是描述数据在计算机存储器中的存储方式包括顺序存储链式存储索引存储散列存储等以及数据元素之间的逻辑关系如何在物理存储",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "54"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除了第一个元素无前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除了第一个元素无前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种次序排列，且除第一个和最后一个元素外每个元素有且仅有一个直接前驱和",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据元素在计算机存储空间中的存储方式包括顺序存储链式存储索引存储和散列存储等以及数据元素之间的逻辑关系如何在",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "18"
  },
  {
    "sentence": "在数据结构中稳定性是指在排序过程中相等元素的相对位置保持不变即如果两个元素相等排序前第一个元素在第二个元素之前排序后第一个元素仍在第二个元素之前",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "算法效率是指算法执行所需要的计算机资源量，通常用时间复杂度和空间复杂度来衡量，时间复杂度表示算法执行时间随输入规模增长的变化趋势，空间复杂度表示",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "24",
    "tail_offset": "30"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除了第一个元素无前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "在数据结构中稳定性是指在排序过程中相等元素的相对顺序保持不变即如果两个元素相等排序前第一个元素在第二个元素之前那么排序后第一个元素仍在第二个元素",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其特点包括有且仅有一个开始和一个终端结点，并且所有结点都最多有一个直接前驱和一个直接后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除了第一个元素无前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "算法效率是指算法执行所需要的时间和空间资源，其时间效率通过时间复杂度衡量算法执行时间随问题规模增长的变化趋势，空间效率通过空间复杂度衡量算法执行",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "29",
    "tail_offset": "61"
  },
  {
    "sentence": "数组是一种具有相同数据类型的元素按顺序存储在连续内存空间中的数据结构其特点包括有固定大小一旦创建大小难以动态改变元素存储紧凑可通过下标快速访问且",
    "head": "数组",
    "tail": "数据类型",
    "head_offset": "0",
    "tail_offset": "9"
  },
  {
    "sentence": "单链表的核心性质是每个节点包含一个数据元素以及一个指向后继节点的指针，通过这些指针依次连接形成线性序列，其中第一个节点无前驱，最后一个节点无后继",
    "head": "单链表",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "17"
  },
  {
    "sentence": "链表由一系列节点组成每个节点包含数据和指向下一个节点的指针且第一个节点称为头节点最后一个节点的指针指向空值通过指针顺序访问节点数据其内存空间可不",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据在计算机内存或存储设备中的实际存储方式包括存储位置存储顺序以及数据元素之间的物理连接关系等它直接影响数据",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "51"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除了第一个元素无前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "存储结构的定义的核心特征是以某种方式将数据元素及它们之间的关系存储到计算机内存或外部存储设备中，包括顺序存储结构通过连续存储单元存储数据元素及其",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "19"
  },
  {
    "sentence": "存储结构的核心特征是它描述了数据元素之间的逻辑关系在计算机存储器中的存储方式以及数据元素及其关系如何在内存中进行存储和组织包括数据元素自身的存储",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种顺序排列，且除第一个和最后一个元素外每个元素都有唯一前驱和唯一后继",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除了第一个元素无前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构的核心性质包括数据元素在计算机存储空间中的存储方式以及它们之间的逻辑关系的存储表示，涉及顺序存储、链式存储等具体形式，体现了数据在",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "14"
  },
  {
    "sentence": "算法效率是指算法执行所需的时间和空间资源，通常用时间复杂度和空间复杂度来衡量，时间复杂度表示算法执行时间随输入规模增长的变化趋势，空间复杂度表示",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "24",
    "tail_offset": "30"
  },
  {
    "sentence": "数据的物理结构是指数据在计算机存储器中的存储方式，包括数据元素的存储表示及其逻辑关系的表示，它具体体现为数据元素及其关系在计算机内存中的存储布局",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "27"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种顺序排列，有且仅有一个开始元素和一个终端元素，除开始元素外每个元素",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构是数据在计算机中的存储表示，包括数据元素的存储方式及数据元素间关系的存储方式，其特点涵盖存储密度、存储空间利用率、数据元素存储顺序",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "23"
  },
  {
    "sentence": "链表由一系列节点组成每个节点包含数据和指向下一个节点的指针通过指针将节点依次连接形成链表可灵活插入和删除节点无需移动大量数据但访问元素需从头遍历",
    "head": "链表",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "27"
  },
  {
    "sentence": "算法效率是指算法执行所需的时间和空间资源，通常用时间复杂度和空间复杂度来衡量，时间复杂度表示算法执行时间随输入规模增长的变化趋势，空间复杂度表示",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "24",
    "tail_offset": "30"
  },
  {
    "sentence": "指针具有指向内存地址、可通过指针间接访问其所指向内存单元的数据、能进行指针运算如移动指针以访问相邻内存单元等特点，不同类型指针指向不同类型数据且",
    "head": "指针",
    "tail": "指针",
    "head_offset": "0",
    "tail_offset": "14"
  },
  {
    "sentence": "数据的物理结构的特点的核心特征是描述数据在计算机内存或存储设备中的实际存储方式包括数据元素的存储顺序以及数据元素之间的逻辑关系如何通过存储结构来",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "41"
  },
  {
    "sentence": "存储结构是指数据元素及其关系在计算机存储器中的表示，其核心性质包括数据元素的表示方法以及数据元素之间关系的表示方法，并且不同存储结构对数据的存储",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "6"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其特点是数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除第一个元素无前",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其特点包括有且仅有一个开始结点和一个终端结点，并且所有结点都最多有一个直接前驱和一个直接",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除了第一个元素无前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中数据元素按顺序排列，每个元素有且仅有一个直接前驱和一个直接后继（除了第一个元素无前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素在计算机中的存储方式以及数据元素之间的逻辑关系在计算机中的存储表示，包括数据元素的存储位置以及它们之间的连接关系",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "存储结构的核心特征是数据元素之间的逻辑关系在计算机中的存储表示以及数据元素在存储空间中的相对位置关系，它决定了数据在计算机中的存储方式和访问方式，",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "存储结构的核心特征是数据元素在计算机存储器中的存储方式以及它们之间的逻辑关系的表示，包括顺序存储结构通过连续存储单元存储数据元素以体现其逻辑顺序，",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "数据的物理结构是数据元素在计算机中的存储表示及其存储方式，其核心性质包括数据元素的存储方式、存储位置关系以及数据元素之间的逻辑关系如何通过物理存储",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "8"
  },
  {
    "sentence": "在数据结构中稳定性是指在排序过程中相等元素的相对位置保持不变即如果两个元素相等排序前第一个元素在第二个元素之前那么排序后第一个元素仍然在第二个元素",
    "head": "稳定性",
    "tail": "排序",
    "head_offset": "6",
    "tail_offset": "12"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素在计算机中的存储方式以及数据元素之间的逻辑关系在计算机中的表示形式包括顺序存储链式存储索引存储散列存储等存储方式",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "存储结构的核心性质是数据元素及其关系在计算机存储器中的表示方式，包括顺序存储结构和链式存储结构等不同形式，不同存储结构具有不同特点和适用场景以满足",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构其中数据元素之间有且仅有一个开始元素一个终端元素且除开始元素和终端元素外每个元素有且仅有一个",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种顺序排列，除第一个和最后一个数据元素外，每个数据元素有且仅有一个前驱",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "哈希表的核心性质是对于不同的关键字可能得到同一哈希地址，即key1≠key2时，可能有Hash(key1)=Hash(key2)，并且哈希表通过哈希",
    "head": "哈希表",
    "tail": "哈希表",
    "head_offset": "0",
    "tail_offset": "67"
  },
  {
    "sentence": "算法效率的特点的核心特征包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化趋势，空间复杂度衡量算法执行过程中所需的额外空间随",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "算法效率的特点的核心性质包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需的额外空间随输入",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "算法效率的特点包括时间复杂度反映算法执行时间随问题规模增长的变化趋势、空间复杂度体现算法执行过程中所需存储空间随问题规模增长的变化情况等，不同算法的",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "9",
    "tail_offset": "35"
  },
  {
    "sentence": "存储结构的核心特征是数据元素在计算机存储器中的存储方式以及它们之间的逻辑关系如何通过存储来体现包括数据元素自身的存储表示和数据元素之间关系的存储表示",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "算法效率的特点包括时间复杂度反映算法执行时间随问题规模增长的变化趋势、空间复杂度体现算法执行过程中所需存储空间随问题规模增长的变化情况等，不同算法的",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "9",
    "tail_offset": "35"
  },
  {
    "sentence": "算法效率的特点的核心性质包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需的额外空间随输入",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "线性结构是一种数据元素之间存在一对一线性关系的数据结构，其中所有数据元素按某种顺序排列，每个元素最多有一个直接前驱和一个直接后继（除了第一个元素无前",
    "head": "线性结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "7"
  },
  {
    "sentence": "数据的物理结构的核心性质是数据元素在计算机存储空间中的存储方式以及它们之间的逻辑关系的实现方式包括顺序存储链式存储索引存储散列存储等不同存储方式具有",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "存储结构的核心特征是数据元素及其关系在计算机存储器中的表示方式决定了数据的存储和访问效率以及数据之间逻辑关系的实现方式等包括顺序存储结构通过连续存储",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "算法效率的特点的核心性质包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需的额外空间随输入",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "算法效率的特点的核心性质包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需的额外空间随输入",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "算法效率的特点的核心性质包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化趋势，空间复杂度衡量算法执行过程中所需额外空间随输入",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "算法效率的特点的核心性质包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需额外空间随输入规模",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "算法效率的特点的核心性质包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需额外空间随输入规模",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "算法效率的特点的核心性质包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需额外空间随输入规模",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "存储结构的核心特征是数据元素及其关系在计算机存储器中的表示方式，包括顺序存储结构通过连续存储单元存储数据元素及元素间关系，链式存储结构通过指针表示元素",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "算法效率的特点的核心性质包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需额外空间随输入规模",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "数据的物理结构的核心特征是数据元素在计算机存储空间中的存储方式以及它们之间的逻辑关系如何通过计算机内存或存储设备中的物理位置来体现，包括数据元素的存储",
    "head": "物理结构",
    "tail": "数据元素",
    "head_offset": "3",
    "tail_offset": "13"
  },
  {
    "sentence": "算法效率的特点包括时间复杂度反映算法执行时间随问题规模增长的变化趋势空间复杂度体现算法执行过程中所需存储空间随问题规模增长的变化情况最优、平均和最坏时间",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "9",
    "tail_offset": "34"
  },
  {
    "sentence": "算法效率的特点包括时间复杂度反映算法执行时间随问题规模增长的变化趋势空间复杂度体现算法执行过程中所需存储空间随问题规模增长的变化情况最优情况、最坏情况和",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "9",
    "tail_offset": "34"
  },
  {
    "sentence": "算法效率的特点包括时间复杂度和空间复杂度等方面，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需存储空间随输入规模增长的",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "9",
    "tail_offset": "15"
  },
  {
    "sentence": "时间复杂度的核心性质包括随着问题规模的增大算法执行时间的增长趋势体现算法效率高低，不同时间复杂度的算法在大规模数据下效率差异明显，常数时间复杂度算法效率",
    "head": "时间复杂度",
    "tail": "时间复杂度",
    "head_offset": "0",
    "tail_offset": "43"
  },
  {
    "sentence": "存储结构的核心特征是数据元素及其关系在计算机存储器中的存储方式，包括顺序存储结构通过连续存储单元存放数据元素及其关系，链式存储结构借助指针表示数据元素之间",
    "head": "存储结构",
    "tail": "数据元素",
    "head_offset": "0",
    "tail_offset": "10"
  },
  {
    "sentence": "算法效率的特点的核心特征包括时间复杂度和空间复杂度，时间复杂度衡量算法执行时间随输入规模增长的变化，空间复杂度衡量算法执行过程中所需存储空间随输入规模增长",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "14",
    "tail_offset": "20"
  },
  {
    "sentence": "算法效率的核心性质包括时间复杂度和空间复杂度，时间复杂度反映算法执行时间随输入规模增长的变化趋势，空间复杂度体现算法执行过程中所需存储空间随输入规模增长的",
    "head": "时间复杂度",
    "tail": "空间复杂度",
    "head_offset": "11",
    "tail_offset": "17"
  }
]